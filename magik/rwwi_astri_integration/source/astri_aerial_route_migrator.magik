#% text_encoding = iso8859_1

_package user
$

## ASTRI Design Migrator - Aerial Route Migration
## Contains methods for creating aerial routes and cables from KMZ placemarks

_private _method astri_design_migrator.create_aerial_route(pm)
	## Create aerial route (cable) from placemark with advanced mode:
	## - Cable folder validation (CABLE, KABEL, CABEL, DISTRIBUTION CABLE)
	## - Sling wire special handling
	## - Cable core detection (12-576 cores) from name
	## - Pole detection at start/end points (500m radius)
	## - Placeholder pole creation when poles not found
	## - Additional AR segments to connect to poles
	## - Sheath creation with structure placement

	_try _with errCon
		# Step 0: Parse folders
		_local folders << pm[:parent].default("")
		_local fol << _unset
		_local fsize << 0
		_local fparent << 0

		_if folders _isnt _unset _andif folders <> ""
		_then
			fol << folders.split_by("|")
			fsize << fol.size
			_if fsize > 1
			_then
				fparent << fsize - 1
			_else
				fparent << fsize
			_endif
		_else
			_return  # No folders - skip
		_endif

		# Step 1: Validate cable folder pattern
		_if fol[fsize] <> "KABEL" _andif
		   fol[fsize] <> "CABLE" _andif
		   fol[fsize] <> "CABEL" _andif
		   fol[fsize] <> "DISTRIBUTION CABLE" _andif
		   fol[fsize] <> "SLING WIRE"
		_then
			_return  # Not a cable - skip
		_endif

		write("  Processing aerial route: ", pm[:name])

		# Step 2: Parse route geometry
		_local route << _self.parse_line_geometry(pm[:coord])
		_local pc << pseudo_chain.new(route)
		pc.world << .database.world
		_local t_len << pc.line_length

		# Check minimum length
		_if t_len < 0.4
		_then
			write("    WARNING: Route too short (", t_len, "m) - skipping")
			_return
		_endif

		# Step 3: Detect cable core count
		_local m_cbl << _self.match_cable_core(pm[:name])
		_local fb_c << m_cbl
		_local s_sp << _unset
		_local s_cd << _unset

		# Map fiber count to spec_id and STF code
		_if m_cbl = "12"
		_then
			s_sp << "SM G652D-ADSS 12C"
			s_cd << ""
		_elif m_cbl = "24"
		_then
			s_sp << "SM G652D-ADSS 24C"
			s_cd << "200000100"
		_elif m_cbl = "36"
		_then
			s_sp << "SM G652D-ADSS 36C"
			s_cd << "200000975"
		_elif m_cbl = "48"
		_then
			s_sp << "SM G652D-ADSS 48C"
			s_cd << "200001038"
		_elif m_cbl = "72"
		_then
			s_sp << "SM G652D-ADSS 72C"
			s_cd << "FO_INV_FTTX_0796"
		_elif m_cbl = "96"
		_then
			s_sp << "SM G652D-ADSS 96C"
			s_cd << "200001630"
		_elif m_cbl = "144"
		_then
			s_sp << "SM G652D-ADSS 144C"
			s_cd << "200001030"
		_elif m_cbl = "288"
		_then
			s_sp << "SM G652D-ADSS 288C"
			s_cd << "200001015"
		_elif m_cbl = "576"
		_then
			s_sp << "SM G652D-ADSS 576C"
			s_cd << ""
		_else
			s_sp << "SM G652D-ADSS 24C"
			s_cd << "200000100"
			fb_c << "24"
		_endif

		write("    >> Detected fiber count: ", fb_c, " cores")

		# Step 4: Detect line type
		_local m_line << _self.match_line(folders)
		_if m_line _is _unset
		_then
			m_line << _self.match_line(pm[:name])
		_endif
		_local segment_id << _self.match_segment(folders)

		write("    >> Detected line: ", m_line)
		# Step 5: Check for SLING WIRE - special handling
		_if fol[fsize] = "SLING WIRE"
		_then
			_if t_len > 0.6
			_then
				write("    >> Creating sling wire (", t_len, "m)")
				_local prop_values_sw << property_list.new_with(
					:status, "Proposed",
					:name, pm[:name],
					:pop, .pop_name,
					:olt, .pop_name,
					:segment, segment_id,
					:fttx_network_type, "Cluster",
					:line_type, m_line,
					:route, route,
					:uuid, .uuid,
					:construction_status, "Proposed"
				)
				_local rec_trans_sw << record_transaction.new_insert(.sw_col, prop_values_sw)
				_local result_sw << rec_trans_sw.run()

				.stats[:sling_wires] +<< 1
				write("    [OK] Sling wire created: ", pm[:name])
				_return result_sw
			_else
				write("    WARNING: Sling wire too short - skipping")
				_return
			_endif
		_endif

		# Step 6: Create main aerial route
		write("     [OK] Creating aerial route...")
		_local l_prop_values << property_list.new_with(
			:construction_status, "Proposed",
			:name, pm[:name],
			:asset_ownership, "Owned",
			:pop, .pop_name,
			:olt, .pop_name,
			:fiber_count, fb_c,
			:fttx_network_type, "Cluster",
			:segment, segment_id,
			:line_type, m_line,
			:folders, folders,
			:route, route,
			:uuid, .uuid
		)

		_local l_rec_trans << record_transaction.new_insert(.ar_col, l_prop_values)
		_local l_result << l_rec_trans.run()

		.stats[:aerial_routes] +<< 1
		write("    [OK] Main aerial route created: ", pm[:name], " (", fb_c, " cores)")

		# Step 7: Handle START POINT
		_local l_location_start << route.first_coord
		_local pp << pseudo_point.new(l_location_start)
		pp.world << .database.world

		_local l_result_ar << _unset
		_local l_result_pl << _unset
		_local n_coord << _unset
		_local fs << _unset

		_local (k1, a_hub) << _self.scan_pole_st(pp, 500)

		_if k1 _is _true
		_then
			# Pole found at start
			n_coord << a_hub.location.coord
			_local ff << route.as_sector_rope()
			_local bb << sector.new_with(n_coord, ff.first_coord)
			_local bbb << pseudo_chain.new(bb)
			bbb.world << .database.world
			_local dist << bbb.line_length

			_if dist > 0.6
			_then
				# Create additional AR segment from pole to start
				write("    >> Creating start AR segment (", dist, "m)")
				_local l_prop_values_ar << property_list.new_with(
					:construction_status, "Proposed",
					:name, pm[:name],
					:asset_ownership, "Owned",
					:pop, .pop_name,
					:olt, .pop_name,
					:fiber_count, fb_c,
					:fttx_network_type, "Cluster",
					:segment, segment_id,
					:line_type, m_line,
					:folders, folders,
					:route, bbb,
					:uuid, .uuid
				)
				_local l_rec_trans_ar << record_transaction.new_insert(.ar_col, l_prop_values_ar)
				l_result_ar << l_rec_trans_ar.run()

				.stats[:aerial_routes] +<< 1
				fs << ff
			_endif

			l_result_pl << a_hub
			write("    >> Using existing pole at start: ", a_hub.telco_pole_tag)
		_else
			# No pole found - create placeholder
			fs << route.as_sector_rope()
			n_coord << route.first_coord

			write("    >> Creating placeholder pole at start")
			_local l_prop_values_pl << property_list.new_with(
				:location, n_coord,
				:telco_pole_tag, "Existing Pole AR",
				:usage, "Telco",
				:material_type, "Steel",
				:extension_arm, _false,
				:power_riser, _false,
				:telco_riser, _false,
				:bond, _false,
				:ground_status, _false,
				:type, "T7",
				:folders, folders,
				:pop, .pop_name,
				:olt, .pop_name,
				:line_type, m_line,
				:fttx_network_type, "Cluster",
				:segment, segment_id,
				:uuid, .uuid,
				:construction_status, "Proposed"
			)
			_local l_rec_trans_pl << record_transaction.new_insert(.pole_col, l_prop_values_pl)
			l_result_pl << l_rec_trans_pl.run()

			.stats[:poles] +<< 1
		_endif

		# Step 8: Handle END POINT
		_local l_location_end << route.last_coord
		_local ppr << pseudo_point.new(l_location_end)
		ppr.world << .database.world

		_local l_result_ar2 << _unset
		_local l_result_pl2 << _unset
		_local e_coord << _unset

		_local (k2, b_hub) << _self.scan_pole_st(ppr, 500)

		_if k2 _is _true
		_then
			# Pole found at end
			_local rr << fs
			_if rr _isnt _unset
			_then
				_local bn << rr.sectors[1]
				_local pss << pseudo_chain.new(bn)
				pss.world << .database.world

				e_coord << b_hub.location.coord
				_local sec << sector.new_with(pss.last_coord, e_coord)
				_local ps << pseudo_chain.new(sec)
				ps.world << .database.world
				_local dist << ps.line_length

				_if dist > 0.6
				_then
					# Create additional AR segment from end to pole
					write("    >> Creating end AR segment (", dist, "m)")
					_local l_prop_values_ar2 << property_list.new_with(
						:construction_status, "Proposed",
						:name, pm[:name],
						:asset_ownership, "Owned",
						:fttx_network_type, "Cluster",
						:segment, segment_id,
						:pop, .pop_name,
						:olt, .pop_name,
						:line_type, m_line,
						:fiber_count, fb_c,
						:folders, folders,
						:route, ps,
						:uuid, .uuid
					)
					_local l_rec_trans_ar2 << record_transaction.new_insert(.ar_col, l_prop_values_ar2)
					l_result_ar2 << l_rec_trans_ar2.run()

					.stats[:aerial_routes] +<< 1
				_endif
			_endif

			l_result_pl2 << b_hub
			write("    >> Using existing pole at end: ", b_hub.telco_pole_tag)
		_else
			# No pole found - create placeholder
			e_coord << route.last_coord

			write("    >> Creating placeholder pole at end")
			_local l_prop_values_pl2 << property_list.new_with(
				:location, e_coord,
				:telco_pole_tag, "Existing Pole AR",
				:usage, "Telco",
				:material_type, "Steel",
				:fttx_network_type, "Cluster",
				:extension_arm, _false,
				:power_riser, _false,
				:telco_riser, _false,
				:bond, _false,
				:ground_status, _false,
				:pop, .pop_name,
				:olt, .pop_name,
				:line_type, m_line,
				:segment, segment_id,
				:type, "T7",
				:folders, folders,
				:uuid, .uuid,
				:construction_status, "Proposed"
			)
			_local l_rec_trans_pl2 << record_transaction.new_insert(.pole_col, l_prop_values_pl2)
			l_result_pl2 << l_rec_trans_pl2.run()

			.stats[:poles] +<< 1
		_endif

		# Step 9: Collect all structures
		_local l_structures << rope.new()
		l_structures.add(l_result_pl)

		_if l_result_ar _isnt _unset
		_then
			l_structures.add(l_result_ar)
		_endif

		l_structures.add(l_result)

		_if l_result_ar2 _isnt _unset
		_then
			l_structures.add(l_result_ar2)
		_endif

		l_structures.add(l_result_pl2)

		# Step 10: Create sheath with structure placement
		_local ftri << _if fsize >= 3 _then >> fol[3] _else >> fol[fsize] _endif
		_local rtr << _if ftri.size > 120 _then >> ftri.slice(1, 120) _else >> ftri _endif

		write("    >> Creating sheath with ", l_structures.size, " structures")
		_local l_prop_values_swl << property_list.new_with(
			:name, pm[:name],
			:spec_id, s_sp,
			:construction_status, "Proposed",
			:sheath_network_type, "Cluster",
			:folders, folders,
			:pop, .pop_name,
			:olt, .pop_name,
			:line_type, m_line,
			:segment, segment_id,
			:cluster, rtr,
			:asset_owner, "Owned",
			:uuid, .uuid
		)

		_local l_rec_trans_swl << record_transaction.new_insert(.sheath_col, l_prop_values_swl)
		_local l_result_swl << l_rec_trans_swl.run()

		# Place sheath in structures
		l_result_swl.place_in_structures(l_structures)

		.stats[:sheaths] +<< 1
		write("    [OK] Sheath created and placed in structures")

		_return  l_result

	_when error
		write("ERROR in create_aerial_route():", errCon.report_contents_string)
		write("  Placemark name:", pm[:name].default("(unnamed)"))
		write("  Folders:", pm[:parent].default("(none)"))
		write("  Coordinates:", pm[:coord].default("(none)"))
		.stats[:errors] +<< 1
	_endtry
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
