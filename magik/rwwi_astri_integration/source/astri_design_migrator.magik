#% text_encoding = iso8859_1

_package user
$

## ASTRI Design Migrator
## Main entry point for migrating parsed KML placemarks to Smallworld design objects
## Creates project and design, orchestrates migration of all object types
##
## Individual migrators are defined in separate files:
## - astri_migrator_utilities.magik - Shared utility methods
## - astri_pole_migrator.magik - Pole creation
## - astri_aerial_route_migrator.magik - Aerial route and cable creation
## - astri_demand_point_migrator.magik - Demand point creation
## - astri_splice_migrator.magik - Sheath splice creation
## - astri_figure_eight_migrator.magik - Figure eight creation
## - astri_olt_migrator.magik - OLT creation
## - astri_riser_migrator.magik - Riser creation
## - astri_access_point_migrator.magik - Access point creation
## - astri_sheath_migrator.magik - Sheath creation
## - astri_micro_cell_migrator.magik - Micro cell creation

remex(:astri_design_migrator)
$

def_slotted_exemplar(:astri_design_migrator,
{
	{:database,        _unset, :writable},   # GIS database
	{:ace_view,        _unset, :writable},   # For coordinate system
	{:transform,       _unset, :writable},   # WGS84 >> local CS transform
	{:uuid,            _unset, :writable},   # KMZ UUID (used for uuid field)

	# Design management
	{:project,         _unset, :writable},   # swg_dsn_project
	{:scheme,          _unset, :writable},   # swg_dsn_scheme (design)
	{:design_manager,  _unset, :writable},   # swg_dsn_design_manager

	# Collection references
	{:ar_col,          _unset, :writable},   # aerial_route
	{:pole_col,        _unset, :writable},   # pole
	{:sheath_col,      _unset, :writable},   # sheath_with_loc
	{:sc_col,          _unset, :writable},   # sheath_splice
	{:fe_col,          _unset, :writable},   # figure_eight
	{:sw_col,          _unset, :writable},   # sling_wire
	{:dp_col,          _unset, :writable},   # ftth!demand_point
	{:os_col,          _unset, :writable},   # optical_splitter
	{:cell_col,        _unset, :writable},   # ftth!zone
	{:cs_col,          _unset, :writable},   # ftth!customer_premise
	{:pol_col,         _unset, :writable},   # pol_boundary
	{:bld_col,         _unset, :writable},   # building
	{:olt_col,         _unset, :writable},   # mit_hub (OLT)
	{:riser_col,       _unset, :writable},   # riser
	{:ap_col,          _unset, :writable},   # access_point

	# Migration context
	{:pop_name,             _unset, :writable},   # POP name (from OLT label)
	{:prj_id,               _unset, :writable},   # Project ID (from wo[:uuid])
	{:region,               _unset, :writable},   # Region (from area field)
	{:cluster,              _unset, :writable},   # Infrastructure name (from target infra_name)
	{:infra_type,           _unset, :writable},   # Infrastructure type (cluster/subfeeder/feeder)
	{:construction_status,  _unset, :writable},   # Construction status ("Proposed" or "In Service")

	# Database infrastructure codes
	{:cluster_code_db,      _unset, :writable},   # Cluster code from database
	{:subfeeder_code_db,    _unset, :writable},   # Subfeeder code from database
	{:feeder_code_db,       _unset, :writable},   # Feeder code from database
	{:olt_code,             _unset, :writable},   # OLT code from database

	# Statistics
	{:stats,           _unset, :writable}    # Migration results
})
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.new(database, wo_data, _optional construction_status)
	## Create new design migrator
	##
	## Parameters:
	##   database - GIS database (e.g., gis_program_manager.databases[:gis])
	##   wo_data - Work order property_list containing:
	##             :uuid - Project ID from work order
	##             :kmz_uuid - KMZ UUID for object tagging
	##             :olt_label - POP name from OLT label
	##             :area - Region from area field
	##             :infra_name - Infrastructure name
	##             :infrastructure_type - Infrastructure type (cluster/subfeeder/feeder)
	##             :cluster_code_db - Cluster code from database
	##             :subfeeder_code_db - Subfeeder code from database
	##             :feeder_code_db - Feeder code from database
	##             :olt_code - OLT code from database
	##   construction_status - Optional construction status ("Proposed" or "In Service", defaults to "Proposed")
	##
	## Returns: New astri_design_migrator instance

	>> _clone.init(database, wo_data, construction_status)
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.init(database, wo_data, _optional construction_status)
	## Initialize migrator
	##
	## Parameters:
	##   database - GIS database
	##   wo_data - Work order property_list
	##   construction_status - Optional construction status

	.database << database

	# Extract work order data from property_list
	.prj_id << wo_data[:uuid].default("")                    # Project ID
	.uuid << wo_data[:kmz_uuid].default("")                  # KMZ UUID for object tagging
	.pop_name << wo_data[:olt_label].default("")             # POP name from OLT label
	.region << wo_data[:area].default("")                    # Region
	.cluster << wo_data[:infra_name].default("")             # Infrastructure name
	.infra_type << wo_data[:infrastructure_type].default("cluster")  # Infrastructure type

	# Extract database infrastructure codes
	.cluster_code_db << wo_data[:cluster_code_db].default("")
	.subfeeder_code_db << wo_data[:subfeeder_code_db].default("")
	.feeder_code_db << wo_data[:feeder_code_db].default("")
	.olt_code << wo_data[:olt_code].default("")

	# Set construction status
	.construction_status << _if construction_status _is _unset _then >> "Proposed" _else >> construction_status _endif
	.ace_view << gis_program_manager.ace_view

	# Get design manager
	.design_manager << swg_dsn_admin_engine
	#gis_program_manager.cached_dataset(:design_admin).actual_dataset

	# Setup coordinate system transformation
	_local cs_local << .database.world.coordinate_system
	_local cs_wgs84 << .ace_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)
	.transform << transform.new_converting_cs_to_cs(cs_wgs84, cs_local)

	# Setup collection references
	.ar_col << .database.collections[:aerial_route]
	.pole_col << .database.collections[:pole]
	.sheath_col << .database.collections[:sheath_with_loc]
	.sc_col << .database.collections[:sheath_splice]
	.fe_col << .database.collections[:figure_eight]
	.sw_col << .database.collections[:sling_wire]
	.dp_col << .database.collections[:ftth!demand_point]
	.os_col << .database.collections[:optical_splitter]
	.cell_col << .database.collections[:ftth!zone]
	.cs_col << .database.collections[:ftth!customer_premise]
	.pol_col << .database.collections[:pol_boundary]
	.bld_col << .database.collections[:building]
	.olt_col << .database.collections[:mit_hub]
	.riser_col << .database.collections[:riser]
	.ap_col << .database.collections[:access_point]

	# Initialize statistics
	.stats << property_list.new_with(
		:aerial_routes, 0,
		:poles, 0,
		:sheaths, 0,
		:sheath_splices, 0,
		:optical_splitters, 0,
		:figure_eights, 0,
		:sling_wires, 0,
		:demand_points, 0,
		:customer_premises, 0,
		:buildings, 0,
		:micro_cells, 0,
		:olts, 0,
		:risers, 0,
		:access_points, 0,
		:areas_created, 0,
		:errors, 0,
		:skipped, 0
	)

	>> _self
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.get_fttx_network_type()
	## Remap infrastructure type to FTTX network type
	## Returns display-friendly version of infra_type
	##
	## Mapping:
	##   "cluster" -> "Cluster"
	##   "subfeeder" -> "Sub Feeder"
	##   "feeder" -> "Feeder"
	##
	## Returns:
	##   string - Remapped FTTX network type

	_local type << .infra_type.default("cluster").lowercase

	_if type = "cluster"
	_then
		_return "Cluster"
	_elif type = "subfeeder"
	_then
		_return "Sub Feeder"
	_elif type = "feeder"
	_then
		_return "Feeder"
	_else
		# Default to Cluster if unknown type
		_return "Cluster"
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.is_boundary_area?(pm)
	## Check if placemark is the project boundary area
	## Boundary area has parent = null or empty AND type = "area"
	##
	## Parameters:
	##   pm (property_list) - Placemark data
	##
	## Returns:
	##   boolean - True if this is the boundary area

	_local parent << pm[:parent]
	_local type << pm[:type]

	>> type = "area" _andif (parent _is _unset _orif parent = "")
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.extract_boundary_area(placemarks)
	## Extract boundary area placemark from placemarks
	## The boundary area is an area with parent = null or empty
	## If no boundary area is found, create a convex hull from all placemark points
	##
	## Parameters:
	##   placemarks (rope) - All placemarks
	##
	## Returns:
	##   property_list - Boundary area placemark (real or synthetic from convex hull)

	_dynamic !print_float_precision! << 16
	_for pm _over placemarks.fast_elements()
	_loop
		_if _self.is_boundary_area?(pm)
		_then
			write("  Found boundary area: ", pm[:name])
			_return _self.parse_line_geometry(pm[:coord])
		_endif
	_endloop

	write("  WARNING: No boundary area found (area with parent=null/empty)")
	write("  Creating convex hull from all placemark points...")

	# Collect all point coordinates from placemarks
	_local point_rope << sector.new()
	_for pm _over placemarks.fast_elements()
	_loop
		_if pm[:coord] _isnt _unset _andif pm[:coord] <> ""
		_then
			_try
				_local coord_string << pm[:coord]
				# Parse coordinate string
				_local coord_parts << coord_string.split_by(",")
				_if coord_parts.size >= 2
				_then
					_local lon << coord_parts[1].as_number()
					_local lat << coord_parts[2].as_number()
					_local wgs84_coord << coordinate.new(lon, lat)
					_local local_coord << .transform.convert(wgs84_coord)
					point_rope.add_last(local_coord)
				_endif
			_when error
				# Skip invalid coordinates
				write("  WARNING: Could not parse coordinate for placemark: ", pm[:name].default("(unnamed)"))
			_endtry
		_endif
	_endloop

	_if point_rope.size < 3
	_then
		write("  ERROR: Not enough points to create convex hull (need at least 3, found ", point_rope.size, ")")
		_return _unset
	_endif

	# Create convex hull from collected points
	_local convex_hull << sector_rope.new_convex_hull(point_rope)
	_if convex_hull _is _unset
	_then
		write("  WARNING: Convex hull creation failed, suspect line geometry, using buffered points instead")
		l_new_sectors << point_rope.buffer(200).sectors.an_element()
		_return sector_rope.new_convex_hull(l_new_sectors)
	_endif

	write("  Created convex hull boundary from ", point_rope.size, " placemark points")
	_return convex_hull.buffer(200).sectors
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.create_project_and_design(placemarks, wo_number, infra_code, infra_name)
	## Create new project and design for migration
	##
	## Parameters:
	##   placemarks (rope) - All placemarks (to extract boundary from)
	##   wo_number (string) - Work order number -> project name
	##   infra_code (string) - Infrastructure code (cluster/subfeeder/feeder) -> project title
	##   infra_name (string) - Infrastructure name -> design name
	##
	## Returns:
	##   (project, scheme) - Created project and scheme objects

	write("Creating project and design...")
	_local sch

 	_local prj << .design_manager.find_project_or_scheme(wo_number, :project)
	_if prj _isnt _unset
	_then
		# Check design is exist or not
		write("Project exist...")
		sch << prj.top_schemes.an_element()
	_endif

        # Get all GIS dataset names
	_local dsnames << set.new()
	_for i _over swg_dsn_project.configuration[:initial_dataset_names].default("").split_by(%,).fast_elements()
	_loop
		dsname << i.as_symbol()
		_if gis_program_manager.cached_dataset(dsname) _isnt _unset
		_then
			dsnames.add(dsname)
		_endif
	_endloop

	_if prj _is _unset
	_then
		write("Creating project...")
		# Extract boundary area from placemarks
		_local area_sr << _self.extract_boundary_area(placemarks)
		# Ensure it's closed

		_if area_sr.closed? _is _false
		_then
			write("  WARNING: Boundary area not closed, using world bounds")
			area_sr << _unset
		_endif
	

		# Create project
		# project_name = WO number
		# project_title = infra code
		_local prj_attrs << property_list.new_with(
					    :job_title, infra_code,
					    :job_type, "Physical NI Design Job",
					    :asset_owner, "Owned")
		prj << .design_manager.create_project(
			       wo_number,       # Project name from WO number 
			       dsnames,
			       area_sr,
			       prj_attrs
				       )
		write("  Project created: ", wo_number, " (Title: ", infra_code, ", ID: ", prj.id, ")")
		
	_endif
	_if sch _isnt unset
	_then
		write("Deleting existing scheme..")
		.design_manager.delete_scheme(sch)
	_endif

	#_if sch _is _unset
	#_then
	# Create scheme (design)
	# design_name = infra name
	_local area_sch << prj.project_areas.an_element().area
	_local sch_attrs << property_list.new()
	sch << .design_manager.create_scheme(
		prj,                  # Parent project
		_unset,               # No parent scheme
		infra_name,           # Scheme name from infra name
		dsnames,              # Dataset names
		prj.design_partition, # Design partition
		sch_attrs             # Additional attributes
	)
	write("  Design created: ", infra_name, " (ID: ", sch.id, ")")
	#_endif

	# Activate the design
	.design_manager.activate_design(sch)
	write("  Design activated")

	# Store references
	.project << prj
	.scheme << sch

	_return prj, sch
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.migrate_placemarks(placemarks)
	## Migrate placemarks to design objects
	## NOTE: For new projects, design must be activated before calling this method (call create_project_and_design() first)
	## NOTE: For existing alternatives (construction_status="In Service"), no design activation needed
	## NOTE: Boundary area (parent=null/empty) is automatically excluded
	##
	## Parameters:
	##   placemarks (rope) - Rope of property_lists from astri_kml_parser
	##
	## Returns:
	##   property_list - Migration statistics

	write("Starting design migration of ", placemarks.size, " placemarks...", .construction_status)

	# Only check for activated design if we're creating new objects (Proposed status)
	# For existing alternative migrations (In Service status), skip this check
	_if .scheme _is _unset _andif .construction_status = "Proposed"
	_then
		condition.raise(:error, :string, "Design not activated. Call create_project_and_design() first.")
	_endif

	# All object creation automatically goes into the activated design alternative
	# For existing alternatives, objects go into the current alternative
	# No need for database mode switching

	# First pass: Create OLTs (needed for cable snapping)
	write("  Pass 1: Creating OLTs...")
	_for pm _over placemarks.fast_elements()
	_loop
		# OLT (point-based: name contains "*OLT*")
		_local is_olt << _self.is_olt?(pm)
		#write("    Checking: ", pm[:name], " | is_olt?: ", is_olt, " | Folders: ", pm[:parent].default(""))
		_if is_olt
		_then
			_self.create_olt(pm)
		_endif
	_endloop
	# Second pass: Create cables/aerial routes
	write("  Pass 2: Creating cables and aerial routes...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_local is_cable << _self.is_cable?(pm)
		#write("    Checking: ", pm[:name], " | is_cable?: ", is_cable, " | Folders: ", pm[:parent].default(""))
		_if is_cable
		_then
			_self.create_aerial_route(pm)
		_endif
	_endloop

	write("  Pass 3: Creating poles...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_local is_pole << _self.is_pole?(pm)
		#write("    Checking: ", pm[:name], " | is_pole?: ", is_pole, " | Folders: ", pm[:parent].default(""))
		_if is_pole
		_then
			_self.create_pole(pm)
		_endif
	_endloop

	# Third pass: Create other objects (demand points, splices, zones, etc.)
	write("  Pass 4: Creating demand points, splices, and area-based objects...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area (ONLY areas with parent=null/empty)
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_local is_splice << _self.is_splice?(pm)
		_local is_fig8 << _self.is_figure_eight?(pm)
		_local is_dp << _self.is_demand_point?(pm[:parent])
		#write("    Checking: ", pm[:name], " | is_splice?: ", is_splice, " | is_figure_eight?: ", is_fig8, " | is_demand_point?: ", is_dp, " | Folders: ", pm[:parent].default(""))

		_if is_splice
		_then
			_self.create_sheath_splice(pm)

		# Figure eights (point-based: slack, coil)
		_elif is_fig8
		_then
			_self.create_figure_eight(pm)
		# Demand points
		_elif is_dp
		_then
			_self.create_demand_point(pm)
		_endif
	_endloop

	# Fourth: Create macro and micro cell
	write("  Pass 5: Creating micro/macro cells...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Sheath splices (point-based: Join Closure, FDT, FAT)
		# Micro cells / zones (area-based with parent folders)
		_local is_cell << _self.is_micro_cell?(pm)
		#write("    Checking: ", pm[:name], " | is_micro_cell?: ", is_cell, " | Folders: ", pm[:parent].default(""))
		_if is_cell
		_then
			_self.create_micro_cell(pm)
		_endif
	_endloop

	# Fifth pass: Create risers (point-based: vertical cables to buildings)
	write("  Pass 6: Creating risers...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Riser cables (point-based: name contains "*riser*")
		_local is_riser << _self.is_riser?(pm)
		#write("    Checking: ", pm[:name], " | is_riser?: ", is_riser, " | Folders: ", pm[:parent].default(""))
		_if is_riser
		_then
			_self.create_riser(pm)
		_endif
	_endloop

	# Sixth pass: Create access points (catch-all for remaining points)
	# write("  Pass 7: Creating access points...")
	# COMMENTED OUT: Access point migration disabled for now - may be useful later
	#_for pm _over placemarks.fast_elements()
	#_loop
	#	# Access points (point-based: catch-all for points not matching other types)
	#	_local is_ap << _self.is_access_point?(pm)
	#	#write("    Checking: ", pm[:name], " | is_access_point?: ", is_ap, " | Folders: ", pm[:parent].default(""))
	#	_if is_ap
	#	_then
	#		_self.create_access_point(pm)
	#	_endif
	#_endloop

	_self.print_statistics()
	>> .stats
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.print_statistics()
	## Print migration statistics

	write("")
	write("=" * 60)
	write("Design Migration Statistics")
	write("=" * 60)
	write("Aerial Routes:      ", .stats[:aerial_routes])
	write("Poles:              ", .stats[:poles])
	write("Sheaths:            ", .stats[:sheaths])
	write("Sheath Splices:     ", .stats[:sheath_splices])
	write("Optical Splitters:  ", .stats[:optical_splitters])
	write("Figure Eights:      ", .stats[:figure_eights])
	write("Sling Wires:        ", .stats[:sling_wires])
	write("Demand Points:      ", .stats[:demand_points])
	write("Customer Premises:  ", .stats[:customer_premises])
	write("Buildings:          ", .stats[:buildings])
	write("Micro Cells:        ", .stats[:micro_cells])
	write("OLTs:               ", .stats[:olts])
	write("Risers:             ", .stats[:risers])
	write("Access Points:      ", .stats[:access_points])
	write("Other Areas:        ", .stats[:areas_created])
	write("Errors:             ", .stats[:errors])
	write("Skipped:            ", .stats[:skipped])
	write("")
	_local total_created << .stats[:aerial_routes] + .stats[:poles] + .stats[:sheaths] +
	                         .stats[:sheath_splices] + .stats[:optical_splitters] +
	                         .stats[:figure_eights] + .stats[:sling_wires] +
	                         .stats[:demand_points] + .stats[:customer_premises] +
	                         .stats[:buildings] + .stats[:micro_cells] + .stats[:olts] +
	                         .stats[:risers] + .stats[:access_points] + .stats[:areas_created]
	write("Total objects:      ", total_created)
	write("=" * 60)
_endmethod
$
