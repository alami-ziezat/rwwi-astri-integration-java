#% text_encoding = iso8859_1

_package user
$

## ASTRI Design Migrator
## Main entry point for migrating parsed KML placemarks to Smallworld design objects
## Creates project and design, orchestrates migration of all object types
##
## Individual migrators are defined in separate files:
## - astri_migrator_utilities.magik - Shared utility methods
## - astri_pole_migrator.magik - Pole creation
## - astri_aerial_route_migrator.magik - Aerial route and cable creation
## - astri_demand_point_migrator.magik - Demand point creation
## - astri_splice_migrator.magik - Sheath splice creation
## - astri_figure_eight_migrator.magik - Figure eight creation
## - astri_olt_migrator.magik - OLT creation
## - astri_riser_migrator.magik - Riser creation
## - astri_access_point_migrator.magik - Access point creation
## - astri_sheath_migrator.magik - Sheath creation
## - astri_micro_cell_migrator.magik - Micro cell creation

remex(:astri_design_migrator)
$

def_slotted_exemplar(:astri_design_migrator,
{
	{:database,        _unset, :writable},   # GIS database
	{:ace_view,        _unset, :writable},   # For coordinate system
	{:transform,       _unset, :writable},   # WGS84 >> local CS transform
	{:uuid,            _unset, :writable},   # KMZ UUID (used for uuid field)

	# Design management
	{:project,         _unset, :writable},   # swg_dsn_project
	{:scheme,          _unset, :writable},   # swg_dsn_scheme (design)
	{:design_manager,  _unset, :writable},   # swg_dsn_design_manager

	# Collection references
	{:ar_col,          _unset, :writable},   # aerial_route
	{:pole_col,        _unset, :writable},   # pole
	{:sheath_col,      _unset, :writable},   # sheath_with_loc
	{:sc_col,          _unset, :writable},   # sheath_splice
	{:fe_col,          _unset, :writable},   # figure_eight
	{:sw_col,          _unset, :writable},   # sling_wire
	{:dp_col,          _unset, :writable},   # ftth!demand_point
	{:os_col,          _unset, :writable},   # optical_splitter
	{:cell_col,        _unset, :writable},   # ftth!zone
	{:cs_col,          _unset, :writable},   # ftth!customer_premise
	{:pol_col,         _unset, :writable},   # pol_boundary
	{:bld_col,         _unset, :writable},   # building
	{:olt_col,         _unset, :writable},   # mit_hub (OLT)
	{:riser_col,       _unset, :writable},   # riser
	{:ap_col,          _unset, :writable},   # access_point

	# Migration context
	{:pop_name,        _unset, :writable},   # POP name
	{:prj_id,          _unset, :writable},   # Project ID (from wo[:uuid])

	# Statistics
	{:stats,           _unset, :writable}    # Migration results
})
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.new(database, prj_id, kml_uuid, pop_name)
	## Create new design migrator
	##
	## Parameters:
	##   database - GIS database (e.g., gis_program_manager.databases[:gis])
	##   prj_id - Project ID from work order uuid field
	##   pop_name - POP name from work order
	##
	## Returns: New astri_design_migrator instance

	>> _clone.init(database, prj_id, kml_uuid, pop_name)
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.init(database, prj_id, kml_uuid, pop_name)
	## Initialize migrator

	.database << database
	.uuid << kml_uuid     # uuid field = wo[:kmz_uuid]
	.pop_name << pop_name
	.prj_id << prj_id       # From wo[:uuid]
	.ace_view << gis_program_manager.ace_view

	# Get design manager
	.design_manager << swg_dsn_admin_engine
	#gis_program_manager.cached_dataset(:design_admin).actual_dataset

	# Setup coordinate system transformation
	_local cs_local << .database.world.coordinate_system
	_local cs_wgs84 << .ace_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)
	.transform << transform.new_converting_cs_to_cs(cs_wgs84, cs_local)

	# Setup collection references
	.ar_col << .database.collections[:aerial_route]
	.pole_col << .database.collections[:pole]
	.sheath_col << .database.collections[:sheath_with_loc]
	.sc_col << .database.collections[:sheath_splice]
	.fe_col << .database.collections[:figure_eight]
	.sw_col << .database.collections[:sling_wire]
	.dp_col << .database.collections[:ftth!demand_point]
	.os_col << .database.collections[:optical_splitter]
	.cell_col << .database.collections[:ftth!zone]
	.cs_col << .database.collections[:ftth!customer_premise]
	.pol_col << .database.collections[:pol_boundary]
	.bld_col << .database.collections[:building]
	.olt_col << .database.collections[:mit_hub]
	.riser_col << .database.collections[:riser]
	.ap_col << .database.collections[:access_point]

	# Initialize statistics
	.stats << property_list.new_with(
		:aerial_routes, 0,
		:poles, 0,
		:sheaths, 0,
		:sheath_splices, 0,
		:optical_splitters, 0,
		:figure_eights, 0,
		:sling_wires, 0,
		:demand_points, 0,
		:customer_premises, 0,
		:buildings, 0,
		:micro_cells, 0,
		:olts, 0,
		:risers, 0,
		:access_points, 0,
		:areas_created, 0,
		:errors, 0,
		:skipped, 0
	)

	>> _self
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.is_boundary_area?(pm)
	## Check if placemark is the project boundary area
	## Boundary area has parent = null or empty AND type = "area"
	##
	## Parameters:
	##   pm (property_list) - Placemark data
	##
	## Returns:
	##   boolean - True if this is the boundary area

	_local parent << pm[:parent]
	_local type << pm[:type]

	>> type = "area" _andif (parent _is _unset _orif parent = "")
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.extract_boundary_area(placemarks)
	## Extract boundary area placemark from placemarks
	## The boundary area is an area with parent = null or empty
	## If no boundary area is found, create a convex hull from all placemark points
	##
	## Parameters:
	##   placemarks (rope) - All placemarks
	##
	## Returns:
	##   property_list - Boundary area placemark (real or synthetic from convex hull)

	_dynamic !print_float_precision! << 16
	_for pm _over placemarks.fast_elements()
	_loop
		_if _self.is_boundary_area?(pm)
		_then
			write("  Found boundary area: ", pm[:name])
			_return _self.parse_line_geometry(pm[:coord])
		_endif
	_endloop

	write("  WARNING: No boundary area found (area with parent=null/empty)")
	write("  Creating convex hull from all placemark points...")

	# Collect all point coordinates from placemarks
	_local point_rope << rope.new()
	_for pm _over placemarks.fast_elements()
	_loop
		_if pm[:coord] _isnt _unset _andif pm[:coord] <> ""
		_then
			_try
				_local coord_string << pm[:coord]
				# Parse coordinate string
				_local coord_parts << coord_string.split_by(",")
				_if coord_parts.size >= 2
				_then
					_local lon << coord_parts[1].as_number()
					_local lat << coord_parts[2].as_number()
					_local wgs84_coord << coordinate.new(lon, lat)
					_local local_coord << .transform.convert(wgs84_coord)
					point_rope.add_last(local_coord)
				_endif
			_when error
				# Skip invalid coordinates
				write("  WARNING: Could not parse coordinate for placemark: ", pm[:name].default("(unnamed)"))
			_endtry
		_endif
	_endloop

	_if point_rope.size < 3
	_then
		write("  ERROR: Not enough points to create convex hull (need at least 3, found ", point_rope.size, ")")
		_return _unset
	_endif

	# Create convex hull from collected points
	_local convex_hull << sector_rope.new_convex_hull(point_rope)
	_if convex_hull _is _unset
	_then
		write("  ERROR: Failed to create convex hull from placemark points")
		_return _unset
	_endif

	write("  Created convex hull boundary from ", point_rope.size, " placemark points")
	_return convex_hull
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.create_project_and_design(placemarks, wo_number, cluster_code, cluster_name)
	## Create new project and design for migration
	##
	## Parameters:
	##   placemarks (rope) - All placemarks (to extract boundary from)
	##   wo_number (string) - Work order number -> project name
	##   cluster_code (string) - Cluster code -> project title
	##   cluster_name (string) - Cluster name -> design name
	##
	## Returns:
	##   (project, scheme) - Created project and scheme objects

	write("Creating project and design...")
	_local sch

 	_local prj << .design_manager.find_project_or_scheme(wo_number, :project)
	_if prj _isnt _unset
	_then
		# Check design is exist or not
		write("Project exist...")
		sch << prj.top_schemes.an_element()
	_endif

        # Get all GIS dataset names
	_local dsnames << set.new()
	_for i _over swg_dsn_project.configuration[:initial_dataset_names].default("").split_by(%,).fast_elements()
	_loop
		dsname << i.as_symbol()
		_if gis_program_manager.cached_dataset(dsname) _isnt _unset
		_then
			dsnames.add(dsname)
		_endif
	_endloop

	_if prj _is _unset
	_then
		write("Creating project...")
		# Extract boundary area from placemarks
		_local area_sr << _self.extract_boundary_area(placemarks)
		# Ensure it's closed

		_if area_sr.closed? _is _false
		_then
			write("  WARNING: Boundary area not closed, using world bounds")
			area_sr << _unset
		_endif
	

		# Create project
		# project_name = WO number
		# project_title = cluster code
		_local prj_attrs << property_list.new_with(
					    :job_title, cluster_code,
					    :job_type, "Physical NI Design Job",
					    :asset_owner, "Owned")
		prj << .design_manager.create_project(
			       wo_number,       # Project name from WO number
			       dsnames,
			       area_sr,
			       prj_attrs
				       )
		write("  Project created: ", wo_number, " (Title: ", cluster_code, ", ID: ", prj.id, ")")
		
	_endif
	_if sch _isnt unset
	_then
		write("Deleting existing scheme..")
		.design_manager.delete_scheme(sch)
	_endif

	#_if sch _is _unset
	#_then
	# Create scheme (design)
	# design_name = cluster name
	_local area_sch << prj.project_areas.an_element().area
	_local sch_attrs << property_list.new()
	sch << .design_manager.create_scheme(
		prj,                  # Parent project
		_unset,               # No parent scheme
		cluster_name,         # Scheme name from cluster name
		dsnames,              # Dataset names
		prj.design_partition, # Design partition
		sch_attrs             # Additional attributes
	)
	write("  Design created: ", cluster_name, " (ID: ", sch.id, ")")
	#_endif

	# Activate the design
	.design_manager.activate_design(sch)
	write("  Design activated")

	# Store references
	.project << prj
	.scheme << sch

	_return prj, sch
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.migrate_placemarks(placemarks)
	## Migrate placemarks to design objects
	## NOTE: Design must be activated before calling this method
	## NOTE: Boundary area (parent=null/empty) is automatically excluded
	##
	## Parameters:
	##   placemarks (rope) - Rope of property_lists from astri_kml_parser
	##
	## Returns:
	##   property_list - Migration statistics

	write("Starting design migration of ", placemarks.size, " placemarks...")

	_if .scheme _is _unset
	_then
		condition.raise(:error, :string, "Design not activated. Call create_project_and_design() first.")
	_endif

	# All object creation automatically goes into the activated design alternative
	# No need for database mode switching

	# First pass: Create OLTs (needed for cable snapping)
	_for pm _over placemarks.fast_elements()
	_loop
		# OLT (point-based: name contains "*OLT*")
		_if _self.is_olt?(pm)
		_then
			_self.create_olt(pm)
		_endif 
	_endloop
	# Second pass: Create cables/aerial routes
	write("  Pass 2: Creating cables and aerial routes...: ",placemarks.size)
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_if _self.is_cable?(pm)
		_then
			_self.create_aerial_route(pm)
		_endif
	_endloop


	write("  Pass 3: Creating poles...: ",placemarks.size)
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_if _self.is_pole?(pm)
		_then
			_self.create_pole(pm)
		_endif
	_endloop

	# Third pass: Create other objects (demand points, splices, zones, etc.)
	write("  Pass 4: Creating demand points, splices, and area-based objects...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area (ONLY areas with parent=null/empty)
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_if _self.is_splice?(pm)
		_then
			_self.create_sheath_splice(pm)

		# Figure eights (point-based: slack, coil)
		_elif _self.is_figure_eight?(pm)
		_then
			_self.create_figure_eight(pm)
		# Demand points
		_elif _self.is_demand_point?(pm[:parent])
		_then
			_self.create_demand_point(pm)
		_endif
	_endloop

	# Fourth: Create macro and micro cell
	_for pm _over placemarks.fast_elements()
	_loop
		# Sheath splices (point-based: Join Closure, FDT, FAT)
		# Micro cells / zones (area-based with parent folders)
		_if _self.is_micro_cell?(pm)
		_then
			_self.create_micro_cell(pm)
		_endif
	_endloop

	# Fifth pass: Create risers (point-based: vertical cables to buildings)
	write("  Pass 6: Creating risers...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Riser cables (point-based: name contains "*riser*")
		_if _self.is_riser?(pm)
		_then
			_self.create_riser(pm)
		_endif
	_endloop

	# Sixth pass: Create access points (catch-all for remaining points)
	write("  Pass 7: Creating access points...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Access points (point-based: catch-all for points not matching other types)
		_if _self.is_access_point?(pm)
		_then
			_self.create_access_point(pm)
		_endif
	_endloop

	_self.print_statistics()
	>> .stats
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.print_statistics()
	## Print migration statistics

	write("")
	write("=" * 60)
	write("Design Migration Statistics")
	write("=" * 60)
	write("Aerial Routes:      ", .stats[:aerial_routes])
	write("Poles:              ", .stats[:poles])
	write("Sheaths:            ", .stats[:sheaths])
	write("Sheath Splices:     ", .stats[:sheath_splices])
	write("Optical Splitters:  ", .stats[:optical_splitters])
	write("Figure Eights:      ", .stats[:figure_eights])
	write("Sling Wires:        ", .stats[:sling_wires])
	write("Demand Points:      ", .stats[:demand_points])
	write("Customer Premises:  ", .stats[:customer_premises])
	write("Buildings:          ", .stats[:buildings])
	write("Micro Cells:        ", .stats[:micro_cells])
	write("OLTs:               ", .stats[:olts])
	write("Risers:             ", .stats[:risers])
	write("Access Points:      ", .stats[:access_points])
	write("Other Areas:        ", .stats[:areas_created])
	write("Errors:             ", .stats[:errors])
	write("Skipped:            ", .stats[:skipped])
	write("")
	_local total_created << .stats[:aerial_routes] + .stats[:poles] + .stats[:sheaths] +
	                         .stats[:sheath_splices] + .stats[:optical_splitters] +
	                         .stats[:figure_eights] + .stats[:sling_wires] +
	                         .stats[:demand_points] + .stats[:customer_premises] +
	                         .stats[:buildings] + .stats[:micro_cells] + .stats[:olts] +
	                         .stats[:risers] + .stats[:access_points] + .stats[:areas_created]
	write("Total objects:      ", total_created)
	write("=" * 60)
_endmethod
$
