#% text_encoding = iso8859_1

_package user
$

## ASTRI Design Migrator
## Main entry point for migrating parsed KML placemarks to Smallworld design objects
## Creates project and design, orchestrates migration of all object types
##
## Individual migrators are defined in separate files:
## - astri_migrator_utilities.magik - Shared utility methods
## - astri_pole_migrator.magik - Pole creation
## - astri_aerial_route_migrator.magik - Aerial route and cable creation
## - astri_demand_point_migrator.magik - Demand point creation
## - astri_splice_migrator.magik - Sheath splice creation
## - astri_figure_eight_migrator.magik - Figure eight creation
## - astri_olt_migrator.magik - OLT creation
## - astri_riser_migrator.magik - Riser creation
## - astri_access_point_migrator.magik - Access point creation
## - astri_sheath_migrator.magik - Sheath creation
## - astri_micro_cell_migrator.magik - Micro cell creation

remex(:astri_design_migrator)
$

def_slotted_exemplar(:astri_design_migrator,
{
	{:database,        _unset, :writable},   # GIS database
	{:ace_view,        _unset, :writable},   # For coordinate system
	{:transform,       _unset, :writable},   # WGS84 >> local CS transform
	{:uuid,            _unset, :writable},   # KMZ UUID (used for uuid field)

	# Design management
	{:project,         _unset, :writable},   # swg_dsn_project
	{:scheme,          _unset, :writable},   # swg_dsn_scheme (design)
	{:design_manager,  _unset, :writable},   # swg_dsn_design_manager

	# Collection references
	{:ar_col,          _unset, :writable},   # aerial_route
	{:pole_col,        _unset, :writable},   # pole
	{:sheath_col,      _unset, :writable},   # sheath_with_loc
	{:sc_col,          _unset, :writable},   # sheath_splice
	{:fe_col,          _unset, :writable},   # figure_eight
	{:sw_col,          _unset, :writable},   # sling_wire
	{:dp_col,          _unset, :writable},   # ftth!demand_point
	{:os_col,          _unset, :writable},   # optical_splitter
	{:cell_col,        _unset, :writable},   # ftth!zone
	{:cs_col,          _unset, :writable},   # ftth!customer_premise
	{:pol_col,         _unset, :writable},   # pol_boundary
	{:bld_col,         _unset, :writable},   # building
	{:olt_col,         _unset, :writable},   # mit_hub (OLT)
	{:riser_col,       _unset, :writable},   # riser
	{:ap_col,          _unset, :writable},   # access_point

	# Migration context
	{:pop_name,        _unset, :writable},   # POP name
	{:prj_id,          _unset, :writable},   # Project ID (from wo[:uuid])

	# Statistics
	{:stats,           _unset, :writable}    # Migration results
})
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.new(database, prj_id, kml_uuid, pop_name)
	## Create new design migrator
	##
	## Parameters:
	##   database - GIS database (e.g., gis_program_manager.databases[:gis])
	##   prj_id - Project ID from work order uuid field
	##   pop_name - POP name from work order
	##
	## Returns: New astri_design_migrator instance

	>> _clone.init(database, prj_id, kml_uuid, pop_name)
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.init(database, prj_id, kml_uuid, pop_name)
	## Initialize migrator

	.database << database
	.uuid << kml_uuid     # uuid field = wo[:kmz_uuid]
	.pop_name << pop_name
	.prj_id << prj_id       # From wo[:uuid]
	.ace_view << gis_program_manager.ace_view

	# Get design manager
	.design_manager << swg_dsn_admin_engine
	#gis_program_manager.cached_dataset(:design_admin).actual_dataset

	# Setup coordinate system transformation
	_local cs_local << .database.world.coordinate_system
	_local cs_wgs84 << .ace_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)
	.transform << transform.new_converting_cs_to_cs(cs_wgs84, cs_local)

	# Setup collection references
	.ar_col << .database.collections[:aerial_route]
	.pole_col << .database.collections[:pole]
	.sheath_col << .database.collections[:sheath_with_loc]
	.sc_col << .database.collections[:sheath_splice]
	.fe_col << .database.collections[:figure_eight]
	.sw_col << .database.collections[:sling_wire]
	.dp_col << .database.collections[:ftth!demand_point]
	.os_col << .database.collections[:optical_splitter]
	.cell_col << .database.collections[:ftth!zone]
	.cs_col << .database.collections[:ftth!customer_premise]
	.pol_col << .database.collections[:pol_boundary]
	.bld_col << .database.collections[:building]
	.olt_col << .database.collections[:mit_hub]
	.riser_col << .database.collections[:riser]
	.ap_col << .database.collections[:access_point]

	# Initialize statistics
	.stats << property_list.new_with(
		:aerial_routes, 0,
		:poles, 0,
		:sheaths, 0,
		:sheath_splices, 0,
		:optical_splitters, 0,
		:figure_eights, 0,
		:sling_wires, 0,
		:demand_points, 0,
		:customer_premises, 0,
		:buildings, 0,
		:micro_cells, 0,
		:olts, 0,
		:risers, 0,
		:access_points, 0,
		:areas_created, 0,
		:errors, 0,
		:skipped, 0
	)

	>> _self
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.is_boundary_area?(pm)
	## Check if placemark is the project boundary area
	## Boundary area has parent = null or empty AND type = "area"
	##
	## Parameters:
	##   pm (property_list) - Placemark data
	##
	## Returns:
	##   boolean - True if this is the boundary area

	_local parent << pm[:parent]
	_local type << pm[:type]

	>> type = "area" _andif (parent _is _unset _orif parent = "")
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_private _method astri_design_migrator.extract_boundary_area(placemarks)
	## Extract boundary area placemark from placemarks
	## The boundary area is an area with parent = null or empty
	##
	## Parameters:
	##   placemarks (rope) - All placemarks
	##
	## Returns:
	##   property_list - Boundary area placemark, or _unset if not found

	_for pm _over placemarks.fast_elements()
	_loop
		_if _self.is_boundary_area?(pm)
		_then
			write("  Found boundary area: ", pm[:name])
			_return pm
		_endif
	_endloop

	write("  WARNING: No boundary area found (area with parent=null/empty)")
	_return _unset
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.create_project_and_design(placemarks, wo_number, cluster_code, cluster_name)
	## Create new project and design for migration
	##
	## Parameters:
	##   placemarks (rope) - All placemarks (to extract boundary from)
	##   wo_number (string) - Work order number -> project name
	##   cluster_code (string) - Cluster code -> project title
	##   cluster_name (string) - Cluster name -> design name
	##
	## Returns:
	##   (project, scheme) - Created project and scheme objects

	!traceback!()
	write("Creating project and design...")
	_local sch

 	_local prj << .design_manager.find_project_or_scheme(wo_number, :project)
	_if prj _isnt _unset
	_then
		# Check design is exist or not
		sch << prj.top_schemes.an_element()
	_endif

        # Get all GIS dataset names
	_local dsnames << set.new()
	_for i _over swg_dsn_project.configuration[:initial_dataset_names].default("").split_by(%,).fast_elements()
	_loop
		dsname << i.as_symbol()
		_if gis_program_manager.cached_dataset(dsname) _isnt _unset
		_then
			dsnames.add(dsname)
		_endif
	_endloop

	_if prj _is _unset
	_then
	# Extract boundary area from placemarks
	_local boundary_pm << _self.extract_boundary_area(placemarks)
	_local area_sr << _unset
	_global wo,dsn,ageo,attr

	_if boundary_pm _isnt _unset
	_then
		# Parse boundary area geometry
		_try
			area_sr << _self.parse_line_geometry(boundary_pm[:coord])
			# Ensure it's closed
			_if area_sr.closed? _is _false
			_then
				write("  WARNING: Boundary area not closed, using world bounds")
				area_sr << _unset
			_endif
		_when error
			write("  ERROR parsing boundary area: ", condition.report_contents_string)
			area_sr << _unset
		_endtry
	_endif

	# Fallback to world bounds if no valid boundary area
	_if area_sr _is _unset
	_then
		write("  Using database world bounds for project area")
		_local bounds << .database.world.bounds
		area_sr << sector_rope.new_with(
			coordinate.new(bounds.xmin, bounds.ymin),
			coordinate.new(bounds.xmax, bounds.ymin),
			coordinate.new(bounds.xmax, bounds.ymax),
			coordinate.new(bounds.xmin, bounds.ymax),
			coordinate.new(bounds.xmin, bounds.ymin)
		)
	_endif

	# Create project
	# project_name = WO number
	# project_title = cluster code
	_local prj_attrs << property_list.new_with(
		:job_title, cluster_code,
		:job_type, "Physical NI Design Job",
		:asset_owner, "Owned")
	prj << .design_manager.create_project(
		wo_number,       # Project name from WO number
		dsnames,
		area_sr,
		prj_attrs
	)
	write("  Project created: ", wo_number, " (Title: ", cluster_code, ", ID: ", prj.id, ")")

	_endif

	_if sch _is _unset
	_then
	# Create scheme (design)
	# design_name = cluster name
	_local area_sch << prj.project_areas.an_element().area
	_local sch_attrs << property_list.new()
	sch << .design_manager.create_scheme(
		prj,                  # Parent project
		_unset,               # No parent scheme
		cluster_name,         # Scheme name from cluster name
		dsnames,              # Dataset names
		prj.design_partition, # Design partition
		sch_attrs             # Additional attributes
	)
	write("  Design created: ", cluster_name, " (ID: ", sch.id, ")")
	_endif

	# Activate the design
	.design_manager.activate_design(sch)
	write("  Design activated")

	# Store references
	.project << prj
	.scheme << sch

	_return prj, sch
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.migrate_placemarks(placemarks)
	## Migrate placemarks to design objects
	## NOTE: Design must be activated before calling this method
	## NOTE: Boundary area (parent=null/empty) is automatically excluded
	##
	## Parameters:
	##   placemarks (rope) - Rope of property_lists from astri_kml_parser
	##
	## Returns:
	##   property_list - Migration statistics

	write("Starting design migration of ", placemarks.size, " placemarks...")

	_if .scheme _is _unset
	_then
		condition.raise(:error, :string, "Design not activated. Call create_project_and_design() first.")
	_endif

	# All object creation automatically goes into the activated design alternative
	# No need for database mode switching

	# First pass: Create poles (needed for cable snapping)

	# Second pass: Create cables/aerial routes
	write("  Pass 1: Creating cables and aerial routes...: ",placemarks.size)
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_if _self.is_cable?(pm)
		_then
			_self.create_aerial_route(pm)
		_endif
	_endloop


	write("  Pass 2: Creating poles...: ",placemarks.size)
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_if _self.is_pole?(pm)
		_then
			_self.create_pole(pm)
		_endif
	_endloop

	# Third pass: Create other objects (demand points, splices, zones, etc.)
	write("  Pass 3: Creating demand points, splices, and area-based objects...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Skip boundary area (ONLY areas with parent=null/empty)
		_if _self.is_boundary_area?(pm)
		_then
			_continue
		_endif

		_if _self.is_splice?(pm)
		_then
			_self.create_sheath_splice(pm)

		# Figure eights (point-based: slack, coil)
		_elif _self.is_figure_eight?(pm)
		_then
			_self.create_figure_eight(pm)

		# OLT (point-based: name contains "*OLT*")
		_elif _self.is_olt?(pm)
		_then
			_self.create_olt(pm)

		# Demand points
		_elif _self.is_demand_point?(pm[:parent])
		_then
			_self.create_demand_point(pm)
		_endif
	_endloop

	# Fourth: Create macro and micro cell
	_for pm _over placemarks.fast_elements()
	_loop
		# Sheath splices (point-based: Join Closure, FDT, FAT)
		# Micro cells / zones (area-based with parent folders)
		_if _self.is_micro_cell?(pm)
		_then
			_self.create_micro_cell(pm)
		_endif
	_endloop

	# Fifth pass: Create risers (point-based: vertical cables to buildings)
	write("  Pass 5: Creating risers...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Riser cables (point-based: name contains "*riser*")
		_if _self.is_riser?(pm)
		_then
			_self.create_riser(pm)
		_endif
	_endloop

	# Sixth pass: Create access points (catch-all for remaining points)
	write("  Pass 6: Creating access points...")
	_for pm _over placemarks.fast_elements()
	_loop
		# Access points (point-based: catch-all for points not matching other types)
		_if _self.is_access_point?(pm)
		_then
			_self.create_access_point(pm)
		_endif
	_endloop

	_self.print_statistics()
	>> .stats
_endmethod
$

_pragma(classify_level=basic, topic={astri_integration})
_method astri_design_migrator.print_statistics()
	## Print migration statistics

	write("")
	write("=" * 60)
	write("Design Migration Statistics")
	write("=" * 60)
	write("Aerial Routes:      ", .stats[:aerial_routes])
	write("Poles:              ", .stats[:poles])
	write("Sheaths:            ", .stats[:sheaths])
	write("Sheath Splices:     ", .stats[:sheath_splices])
	write("Optical Splitters:  ", .stats[:optical_splitters])
	write("Figure Eights:      ", .stats[:figure_eights])
	write("Sling Wires:        ", .stats[:sling_wires])
	write("Demand Points:      ", .stats[:demand_points])
	write("Customer Premises:  ", .stats[:customer_premises])
	write("Buildings:          ", .stats[:buildings])
	write("Micro Cells:        ", .stats[:micro_cells])
	write("OLTs:               ", .stats[:olts])
	write("Risers:             ", .stats[:risers])
	write("Access Points:      ", .stats[:access_points])
	write("Other Areas:        ", .stats[:areas_created])
	write("Errors:             ", .stats[:errors])
	write("Skipped:            ", .stats[:skipped])
	write("")
	_local total_created << .stats[:aerial_routes] + .stats[:poles] + .stats[:sheaths] +
	                         .stats[:sheath_splices] + .stats[:optical_splitters] +
	                         .stats[:figure_eights] + .stats[:sling_wires] +
	                         .stats[:demand_points] + .stats[:customer_premises] +
	                         .stats[:buildings] + .stats[:micro_cells] + .stats[:olts] +
	                         .stats[:risers] + .stats[:access_points] + .stats[:areas_created]
	write("Total objects:      ", total_created)
	write("=" * 60)
_endmethod
$
