#% text_encoding = iso8859_1
_package user
$

## AERIAL KMZ EXPORTER
## Main class for exporting Smallworld network to FORMAT KMZ AERIAL hierarchy
## Integrates with ASTRI Work Order Dialog

remex(:rwi_export_to_aerial_kmz)
$

_pragma(classify_level=basic, topic={rwi_export})
def_slotted_exemplar(:rwi_export_to_aerial_kmz,
{
	{:gc, _unset, :writable},                    # GIS case
	{:project_name, _unset, :writable},          # Project name (from WO number)
	{:project_area, _unset, :writable},          # Design boundary area
	{:scheme_name, _unset, :writable},           # Design name (from Cluster Name)
	{:output_directory, _unset, :writable},      # Output directory
	{:infrastructure_type, _unset, :writable},   # Infrastructure type filter (cluster/feeder/subfeeder)
	{:infrastructure_code, _unset, :writable},   # Infrastructure code (e.g., "CLU001")
	{:style_manager, _unset, :writable},         # Style manager instance
	{:folder_builder, _unset, :writable},        # Folder builder instance
	{:object_writer, _unset, :writable},         # Object writer instance
	{:line_assigner, _unset, :writable},         # LINE assigner instance
	{:total_pole_count, _unset, :writable},      # Total poles exported
	{:pole_statistics, _unset, :writable},       # Property list tracking poles per folder
	{:total_fat_count, _unset, :writable},       # Total FATs exported
	{:total_fdt_count, _unset, :writable},       # Total FDTs exported
	{:total_closure_count, _unset, :writable},   # Total CLOSUREs exported
	{:total_slack_hanger_count, _unset, :writable},  # Total SLACK HANGERs exported
	{:total_sling_wire_count, _unset, :writable},    # Total SLING WIREs exported
	{:total_cable_count, _unset, :writable},         # Total CABLEs exported
	{:total_hp_count, _unset, :writable},            # Total HOME PASS (demand points) exported
	{:total_cell_count, _unset, :writable}           # Total CELLs (ftth!zone) exported
}, :object)
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_export_to_aerial_kmz.new()
	## Create new exporter instance
	>> _clone.init()
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.init()
	## Initialize exporter with helper instances

	# Create helper instances
	.style_manager << rwi_aerial_kmz_style_manager.new()
	.folder_builder << rwi_aerial_kmz_folder_builder.new()
	.object_writer << rwi_aerial_kmz_object_writer.new()
	.line_assigner << rwi_aerial_kmz_line_assigner.new()

	>> _self
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.get_pole_template_folder_name(p_pole)
	## Construct the template folder name for a pole based on its attributes
	## Used to match poles to template folders when folders field doesn't match exactly
	##
	## Parameters:
	##   p_pole - Pole object
	##
	## Returns:
	##   String - Expected template folder name (e.g., "NEW POLE 7-4", "EXISTING POLE EMR 9-5")

	pole_status << p_pole.perform(:construction_status).default("").uppercase
	asset_owner << p_pole.perform(:asset_owner).default("").uppercase
	pole_type << p_pole.perform(:type).default("")

	# Determine NEW vs EXISTING
	_local status_prefix << _if pole_status = "PROPOSED"
	                        _then >> "NEW POLE"
	                        _elif pole_status = "IN SERVICE"
	                        _then >> "EXISTING POLE"
	                        _else >> _unset
	                        _endif

	_if status_prefix _is _unset
	_then
		_return ""  # Can't determine status
	_endif

	# Determine owner for EXISTING poles (EMR = OWNED, PARTNER = not OWNED)
	_local owner_str << ""
	_if status_prefix = "EXISTING POLE"
	_then
		owner_str << _if asset_owner = "OWNED"
		             _then >> " EMR"
		             _else >> " PARTNER"
		             _endif
	_endif

	# Extract pole spec from type field (look for patterns like "7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5")
	_local pole_spec << ""
	_for spec _over {"7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5"}.fast_elements()
	_loop
		_if pole_type.index_of_seq(spec) _isnt _unset
		_then
			pole_spec << " " + spec
			_leave
		_endif
	_endloop

	# Construct folder name: "NEW POLE 7-4" or "EXISTING POLE EMR 9-5"
	>> status_prefix + owner_str + pole_spec
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_export_to_aerial_kmz.export_mixed_network(p_area, p_output_file)
	## Main export method - exports with automatic network level detection
	## and infrastructure type filtering
	##
	## Parameters:
	##   p_area - Design boundary area (pseudo_polygon)
	##   p_output_file - Output file path (e.g., "WO_12345.kmz")
	##
	## Returns:
	##   property_list - {:output_file, string, :statistics, property_list}

	write("Starting aerial KMZ export...")
	write("  Project:", .project_name)
	write("  Infrastructure Type:", .infrastructure_type)

	# Detect network levels in area
	levels << _self.detect_network_levels_in_area(p_area)
	levels.p
	# Filter based on infrastructure type
	_if .infrastructure_type _isnt _unset _and
	    .infrastructure_type <> :all
	_then
		write("  Filtering to infrastructure type:", .infrastructure_type)

		_if .infrastructure_type _is :cluster
		_then
			levels[:feeder] << _false
			levels[:subfeeder] << _false
		_elif .infrastructure_type _is :feeder
		_then
			# Special case: If feeder work order has FDTs+Closures (subfeeder network),
			# export as subfeeder but keep feeder flag for folder naming
			_if levels[:subfeeder] _is _true
			_then
				write("  Special case: Feeder work order with subfeeder network detected")
				write("  Will export as SUBFEEDER structure using FEEDER CODE as parent folder")
				# Keep both feeder (for folder naming) and subfeeder (for structure)
				levels[:feeder] << _true
				levels[:subfeeder] << _true
				levels[:cluster] << _false
			_else
				# Normal feeder - no subfeeder network
				levels[:subfeeder] << _false
				levels[:cluster] << _false
			_endif
		_elif .infrastructure_type _is :subfeeder
		_then
			levels[:feeder] << _false
			levels[:cluster] << _false
		_endif
	_endif

	write("  Network levels to export:")
	write("    FEEDER:", levels[:feeder])
	write("    SUBFEEDER:", levels[:subfeeder])
	write("    CLUSTER:", levels[:cluster])

	# Create KML file
	kml_file << _self.create_kml_file(p_output_file, p_area, levels)

	# Create KMZ (zip the KML) - COMMENTED OUT FOR NOW
	# kmz_file << _self.create_kmz_from_kml(kml_file)

	write("Export complete:", kml_file)

	# Return output file and statistics
	>> property_list.new_with(
		:output_file, kml_file,
		:total_poles, .total_pole_count,
		:pole_statistics, .pole_statistics,
		:total_fats, .total_fat_count,
		:total_fdts, .total_fdt_count,
		:total_closures, .total_closure_count,
		:total_slack_hangers, .total_slack_hanger_count,
		:total_sling_wires, .total_sling_wire_count,
		:total_cables, .total_cable_count,
		:total_home_pass, .total_hp_count,
		:total_cells, .total_cell_count,
		:project_name, .project_name,
		:infrastructure_type, .infrastructure_type)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.detect_network_levels_in_area(p_area)
	## Detect which network levels are present in the export area
	## Logic:
	##   1. FEEDER: Find if mit_hub is inside project area
	##   2. SUBFEEDER: Find poles in area, check if poles have sheath_splice with type Joint Closure/Closure AND FDT
	##   3. CLUSTER: Find poles in area, check if poles have sheath_splice with type FDT AND FAT
	##
	## Returns:
	##   property_list - {:feeder, boolean, :subfeeder, boolean, :cluster, boolean, :fdts, rope}

	levels << property_list.new_with(
		:feeder, _false,
		:subfeeder, _false,
		:cluster, _false,
		:fdts, rope.new())

	# 1. FEEDER: Check for mit_hub in area
	olts << .gc[:mit_hub].select(
		predicate.within(:location, p_area))

	_if olts.size > 0
	_then
		levels[:feeder] << _true
		write("  Detected FEEDER network (", olts.size, " OLTs/hubs)")
	_endif

	# Get all poles in area first
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	write("  Found ", all_poles.size, " poles in area")

	# Now check equipment on these poles
	has_joint_closure << _false
	has_fdt << _false
	has_fat << _false
	all_fdts << rope.new()
	all_closures << rope.new()

	_for pole _over all_poles.fast_elements()
	_loop
		# Get all equipment on this pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment _is _unset _then _continue _endif

		# Get sheath_splice from equipment
		pole_splices << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :sheath_splice)))

		# Check if sheath_splice exists on this pole
		_if _not pole_splices.empty?
		_then
			# Check each sheath_splice
			_for splice _over pole_splices.fast_elements()
			_loop
				splice_type << splice.sheath_splice_object_type
				_if splice_type _is _unset _then _continue _endif

				# Check for Joint Closure (SUBFEEDER indicator)
				_if splice_type.lowercase = "join closure" _or
				    splice_type.lowercase = "closure"
				_then
					has_joint_closure << _true
					all_closures.add_last(splice)
				_endif

				# Check for FDT (SUBFEEDER and CLUSTER indicator)
				_if splice_type.uppercase = "FDT"
				_then
					has_fdt << _true
					all_fdts.add_last(splice)
				_endif

				# Check for FAT (CLUSTER indicator)
				_if splice_type.uppercase = "FAT"
				_then
					has_fat << _true
				_endif
			_endloop
		_endif
	_endloop

	write(" Has Joint Closure: ", has_joint_closure, " | Has FDT: ", has_fdt, " | Has FAT: ", has_fat	)

	# Check for mit_terminal_enclosure directly in area (world geometry)
	terminal_enclosures << .gc[:mit_terminal_enclosure].select(
		predicate.within(:location, p_area))

	_if terminal_enclosures.size > 0
	_then
		has_fdt << _true
		_for terminal _over terminal_enclosures.fast_elements()
		_loop
			all_fdts.add_last(terminal)
		_endloop
		write("  Found ", terminal_enclosures.size, " mit_terminal_enclosures (FDTs) in area")
	_endif

	# Store all FDTs and closures found
	levels[:fdts] << all_fdts
	levels[:closures] << all_closures

	# 2. SUBFEEDER: Poles have Joint Closure AND FDT
	_if has_joint_closure _and has_fdt
	_then
		levels[:subfeeder] << _true
		write("  Detected SUBFEEDER network (has Joint Closures and FDTs on poles)")
	_endif

	# 3. CLUSTER: Poles have FDT AND FAT
	_if has_fdt _and has_fat
	_then
		levels[:cluster] << _true
		write("  Detected CLUSTER network (", all_fdts.size, " FDTs and FATs on poles)")
	_endif

	>> levels
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.create_kml_file(p_output_file, p_area, p_levels)
	## Create KML file with dynamic folder structure using template

	# Initialize counters and statistics
	.total_pole_count << 0
	.pole_statistics << property_list.new()
	.total_fat_count << 0
	.total_fdt_count << 0
	.total_closure_count << 0
	.total_slack_hanger_count << 0
	.total_sling_wire_count << 0
	.total_cable_count << 0
	.total_hp_count << 0
	.total_cell_count << 0

	# Replace .kmz with .kml for temp file
	kml_file << p_output_file.substitute_string(".kmz", ".kml")

	# Load template file (using new aerial_styles.kml)
	template_file << smallworld_product.get_data_file("aerial_styles.kml", :rwi_export_to_kml)
	_if template_file _is _unset
	_then
		condition.raise(:error, :string, "Template file aerial_styles.kml not found")
	_endif

	# Read template content
	template_stream << external_text_input_stream.new(template_file.write_string)
	template_content << rope.new()
	_loop
		line << template_stream.get_line()
		_if line _is _unset _then _leave _endif
		template_content.add_last(line)
	_endloop
	template_stream.close()

	# Create output stream
	kml_stream << external_text_output_stream.new(kml_file)

	# Write template header and styles (up to CONTENT_PLACEHOLDER)
	_for line _over template_content.fast_elements()
	_loop
		_if line.index_of_seq("CONTENT_PLACEHOLDER") _isnt _unset
		_then
			_leave  # Stop before placeholder
		_endif

		# Replace project name placeholder
		_local output_line << line
		_if line.index_of_seq("PROJECT_NAME_PLACEHOLDER") _isnt _unset
		_then
			output_line << line.substitute_string("PROJECT_NAME_PLACEHOLDER", .project_name.default("AERIAL_EXPORT"))
		_endif

		kml_stream.write(output_line, newline_char)
	_endloop

	# Write network level folders
	# Special case: If both feeder and subfeeder flags are true,
	# it means feeder work order has subfeeder network - export only subfeeder structure
	_if p_levels[:feeder] _and p_levels[:subfeeder]
	_then
		write("Exporting SUBFEEDER network structure with FEEDER CODE...")
		_self.write_subfeeder_section(kml_stream, p_area, p_levels[:closures])
	_else
		# Normal cases - export each level independently
		_if p_levels[:feeder]
		_then
			write("Exporting FEEDER network...")
			_self.write_feeder_section(kml_stream, p_area)
		_endif

		_if p_levels[:subfeeder]
		_then
			write("Exporting SUBFEEDER network...")
			_self.write_subfeeder_section(kml_stream, p_area, p_levels[:closures])
		_endif

		_if p_levels[:cluster]
		_then
			write("Exporting CLUSTER network...")
			_self.write_cluster_section(kml_stream, p_area, p_levels[:fdts])
		_endif
	_endif

	# Write KML footer
	_self.write_kml_footer(kml_stream)

	kml_stream.close()

	# Display detailed statistics report
	_self.print_export_statistics()

	>> kml_file
_endmethod
$


_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_kml_footer(p_stream)
	## Write KML document footer

	p_stream.write("</Document>", newline_char)
	p_stream.write("</kml>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.print_export_statistics()
	## Print detailed export statistics report

	write("="*60)
	write("AERIAL KML EXPORT - STATISTICS REPORT")
	write("="*60)
	write("Project: ", .project_name.default("Unknown"))
	write("Infrastructure Type: ", .infrastructure_type.default("All"))
	write("-"*60)
	write("POLE EXPORT SUMMARY:")
	write("-"*60)

	# Sort folders by name for consistent display
	folder_names << .pole_statistics.keys.as_sorted_collection()

	# Display poles per folder
	_if folder_names.size > 0
	_then
		_for folder_name _over folder_names.fast_elements()
		_loop
			count << .pole_statistics[folder_name]
			write("  ", folder_name, ": ", count)
		_endloop
	_else
		write("  No poles exported")
	_endif

	write("-"*60)
	write("TOTAL POLES EXPORTED: ", .total_pole_count)
	write("-"*60)
	write("EQUIPMENT EXPORT SUMMARY:")
	write("-"*60)
	write("  FAT: ", .total_fat_count)
	write("  FDT: ", .total_fdt_count)
	write("  CLOSURE: ", .total_closure_count)
	write("="*60)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_feeder_section(p_stream, p_area)
	## Write FEEDER CODE section - flat structure
	## All objects exported to folders based on their direct parent folder field

	# Use infrastructure code if available, otherwise default to "FEEDER CODE"
	folder_name << _if .infrastructure_code _isnt _unset
	               _then >> .infrastructure_code
	               _else >> "FEEDER CODE"
	               _endif

	p_stream.write("  <Folder>", newline_char)
	p_stream.write("    <name>", folder_name, "</name>", newline_char)

	# Get folder definitions and write each folder
	# Objects are exported based on their parent folder field
	folder_defs << .folder_builder.build_feeder_folders()
	_for folder_def _over folder_defs.fast_elements()
	_loop
		_self.write_feeder_folder(p_stream, folder_def, p_area, 4)
	_endloop

	p_stream.write("  </Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_subfeeder_section(p_stream, p_area, p_closures)
	## Write SUBFEEDER CODE section - flat structure
	## All objects exported to folders based on their direct parent folder field
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_closures - Rope of closure (sheath_splice) objects (unused, kept for compatibility)

	# Use infrastructure code if available, otherwise default to "SUBFEEDER CODE"
	folder_name << _if .infrastructure_code _isnt _unset
	               _then >> .infrastructure_code
	               _else >> "SUBFEEDER CODE"
	               _endif

	p_stream.write("  <Folder>", newline_char)
	p_stream.write("    <name>", folder_name, "</name>", newline_char)

	# Get folder definitions and write each folder
	# Objects are exported based on their parent folder field
	folder_defs << .folder_builder.build_subfeeder_folders()
	_for folder_def _over folder_defs.fast_elements()
	_loop
		_self.write_subfeeder_folder(p_stream, folder_def, p_area, 4)
	_endloop

	p_stream.write("  </Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_cluster_section(p_stream, p_area, p_fdts)
	## Write CLUSTER CODE section with dynamic FDT structure

	# Use infrastructure code if available, otherwise default to "CLUSTER CODE"
	folder_name << _if .infrastructure_code _isnt _unset
	               _then >> .infrastructure_code
	               _else >> "CLUSTER CODE"
	               _endif

	p_stream.write("  <Folder>", newline_char)
	p_stream.write("    <name>", folder_name, "</name>", newline_char)

	# Get folder definitions from builder (dynamic based on FDT count)
	folder_defs << .folder_builder.build_cluster_folders(p_fdts)

	# Write each folder
	_for folder_def _over folder_defs.fast_elements()
	_loop
		_self.write_folder(p_stream, folder_def, p_area, 4)
	_endloop

	p_stream.write("  </Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_folder(p_stream, p_folder_def, p_area, p_indent, _optional p_parent_line_id, p_parent_fdt_folder)
	## Write a folder and its contents recursively
	##
	## Parameters:
	##   p_parent_line_id - LINE ID from parent folder (propagated to children, first optional)
	##   p_parent_fdt_folder - FDT folder name from parent (propagated to children, second optional)

	indent << "".fill_up_with(% , p_indent)

	p_stream.write(indent, "<Folder>", newline_char)
	p_stream.write(indent, "  <name>", p_folder_def[:name], "</name>", newline_char)

	# Write visibility if specified
	_if p_folder_def[:visibility] _isnt _unset
	_then
		vis_str << _if p_folder_def[:visibility] _then "1" _else "0" _endif
		p_stream.write(indent, "  <visibility>", vis_str, "</visibility>", newline_char)
	_endif

	# Determine LINE ID for this folder level
	# If this folder defines a line_id, use it; otherwise inherit from parent
	current_line_id << p_folder_def[:line_id].default(p_parent_line_id)

	# Determine FDT folder name for this level
	# Check if this folder is FDT_* folder (cluster structure)
	folder_name << p_folder_def[:name]
	current_fdt_folder << p_parent_fdt_folder
	_if folder_name.index_of_seq("FDT_") _isnt _unset
	_then
		# This is an FDT folder, use its name
		current_fdt_folder << folder_name
	_endif

	# Write subfolders if present
	_if p_folder_def[:subfolders] _isnt _unset
	_then
		_for subfolder _over p_folder_def[:subfolders].fast_elements()
		_loop
			# Pass current_line_id and current_fdt_folder down to children
			_self.write_folder(p_stream, subfolder, p_area, p_indent + 2, current_line_id, current_fdt_folder)
		_endloop
	_endif

	# Write placemarks for this folder based on folder type
	# Pass current_line_id and current_fdt_folder so FAT folders know which FDT and LINE they belong to
	_self.write_folder_contents(p_stream, p_folder_def, p_area, indent + "  ", current_line_id, current_fdt_folder)

	p_stream.write(indent, "</Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_subfeeder_folder(p_stream, p_folder_def, p_area, p_indent)
	## Write a folder for subfeeder - exports objects based on parent folder field
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_folder_def - Folder definition property_list
	##   p_area - Design boundary area
	##   p_indent - Indentation level

	indent << "".fill_up_with(% , p_indent)
	folder_name << p_folder_def[:name]

	p_stream.write(indent, "<Folder>", newline_char)
	p_stream.write(indent, "  <name>", folder_name, "</name>", newline_char)

	# Write visibility if specified
	_if p_folder_def[:visibility] _isnt _unset
	_then
		vis_str << _if p_folder_def[:visibility] _then "1" _else "0" _endif
		p_stream.write(indent, "  <visibility>", vis_str, "</visibility>", newline_char)
	_endif

	# Write folder contents - objects exported based on their parent folder field
	_self.write_subfeeder_folder_contents(p_stream, folder_name, p_area, indent + "  ")

	p_stream.write(indent, "</Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_subfeeder_folder_contents(p_stream, p_folder_name, p_area, p_indent)
	## Write placemarks for subfeeder folders
	## Objects exported based on their parent folder field matching p_folder_name
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_folder_name - Name of current folder
	##   p_area - Design boundary area
	##   p_indent - Indentation string

	# Check if this is a pole folder (EXISTING POLE or NEW POLE)
	_if p_folder_name.index_of_seq("POLE") _isnt _unset
	_then
		# Query poles in area
		all_poles << .gc[:pole].select(
			predicate.interacts(:location, p_area))

		# Determine filtering criteria from folder name
		is_new_pole? << p_folder_name.index_of_seq("NEW POLE") _isnt _unset
		is_emr? << p_folder_name.index_of_seq("EMR") _isnt _unset
		is_partner? << p_folder_name.index_of_seq("PARTNER") _isnt _unset

		# Extract pole spec if present (e.g., "7-2.5", "7-3", "7-4", "9-4")
		pole_spec << _unset
		_for spec _over {"7-2.5", "7-3", "7-4", "9-4"}.fast_elements()
		_loop
			_if p_folder_name.index_of_seq(spec) _isnt _unset
			_then
				pole_spec << spec
				_leave
			_endif
		_endloop

		# Filter and write poles
		pole_count << 0
		_for pole _over all_poles.fast_elements()
		_loop
			# Construct template folder name from pole attributes
			pole_template_folder << _self.get_pole_template_folder_name(pole)

			# Check if constructed folder name matches current template folder
			_if pole_template_folder = p_folder_name
			_then
				.object_writer.write_pole(pole, p_stream, p_indent, p_folder_name)
				pole_count +<< 1
				.total_pole_count +<< 1
			_endif
		_endloop

		_if pole_count > 0
		_then
			.pole_statistics[p_folder_name] << pole_count
			write("  Wrote ", pole_count, " poles to folder: ", p_folder_name)
		_endif
	_endif

	# Handle FDT folders
	_if p_folder_name.index_of_seq("FDT") _isnt _unset
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "FDT", _unset)
	_endif

	# Handle JOINT CLOSURE folders
	_if p_folder_name.index_of_seq("JOINT CLOSURE") _isnt _unset
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "CLOSURE", _unset)
	_endif

	# Handle SLACK HANGER folders
	_if p_folder_name.index_of_seq("SLACK HANGER") _isnt _unset
	_then
		_self.write_figure_eight_for_folder(p_stream, p_area, p_indent, _unset, _unset)
	_endif

	# Handle CABLE folders
	_if p_folder_name.index_of_seq("CABLE") _isnt _unset _andif
	    p_folder_name.index_of_seq("BOUNDARY") _is _unset
	_then
		_self.write_cable_for_folder(p_stream, p_area, p_indent, _unset, _unset)
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_feeder_folder(p_stream, p_folder_def, p_area, p_indent)
	## Write a folder for feeder - exports objects based on parent folder field
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_folder_def - Folder definition property_list
	##   p_area - Design boundary area
	##   p_indent - Indentation level

	indent << "".fill_up_with(% , p_indent)
	folder_name << p_folder_def[:name]

	p_stream.write(indent, "<Folder>", newline_char)
	p_stream.write(indent, "  <name>", folder_name, "</name>", newline_char)

	# Write visibility if specified
	_if p_folder_def[:visibility] _isnt _unset
	_then
		vis_str << _if p_folder_def[:visibility] _then "1" _else "0" _endif
		p_stream.write(indent, "  <visibility>", vis_str, "</visibility>", newline_char)
	_endif

	# Write folder contents - objects exported based on their parent folder field
	_self.write_feeder_folder_contents(p_stream, folder_name, p_area, indent + "  ")

	p_stream.write(indent, "</Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_feeder_folder_contents(p_stream, p_folder_name, p_area, p_indent)
	## Write placemarks for feeder folders
	## Objects exported based on their parent folder field matching p_folder_name
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_folder_name - Name of current folder
	##   p_area - Design boundary area
	##   p_indent - Indentation string

	# Handle OLT folders
	_if p_folder_name.index_of_seq("OLT") _isnt _unset
	_then
		# Query OLT objects in area
		all_olts << .gc[:mit_hub].select(
			predicate.interacts(:location, p_area))

		olt_count << 0
		_for olt _over all_olts.fast_elements()
		_loop
			# Get OLT folders field
			olt_folders << olt.perform(:folders).default("")

			# Check if OLT's folders field contains this folder name
			_if olt_folders.index_of_seq(p_folder_name) _isnt _unset
			_then
				.object_writer.write_olt(olt, p_stream, p_indent, p_folder_name)
				olt_count +<< 1
			_endif
		_endloop

		_if olt_count > 0
		_then
			write("  Wrote ", olt_count, " OLTs to folder: ", p_folder_name)
		_endif
	_endif

	# Handle POLE folders (EXISTING POLE or NEW POLE)
	_if p_folder_name.index_of_seq("POLE") _isnt _unset
	_then
		# Query poles in area
		all_poles << .gc[:pole].select(
			predicate.interacts(:location, p_area))

		# Determine filtering criteria from folder name
		is_new_pole? << p_folder_name.index_of_seq("NEW POLE") _isnt _unset
		is_emr? << p_folder_name.index_of_seq("EMR") _isnt _unset
		is_partner? << p_folder_name.index_of_seq("PARTNER") _isnt _unset

		# Extract pole spec if present (e.g., "7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5")
		pole_spec << _unset
		_for spec _over {"7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5"}.fast_elements()
		_loop
			_if p_folder_name.index_of_seq(spec) _isnt _unset
			_then
				pole_spec << spec
				_leave
			_endif
		_endloop

		# Filter and write poles
		pole_count << 0
		_for pole _over all_poles.fast_elements()
		_loop
			# Construct template folder name from pole attributes
			pole_template_folder << _self.get_pole_template_folder_name(pole)

			# Check if constructed folder name matches current template folder
			_if pole_template_folder = p_folder_name
			_then
				.object_writer.write_pole(pole, p_stream, p_indent, p_folder_name)
				pole_count +<< 1
				.total_pole_count +<< 1
			_endif
		_endloop

		_if pole_count > 0
		_then
			.pole_statistics[p_folder_name] << pole_count
			write("  Wrote ", pole_count, " poles to folder: ", p_folder_name)
		_endif
	_endif

	# Handle JOINT CLOSURE folders
	_if p_folder_name.index_of_seq("JOINT CLOSURE") _isnt _unset
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "CLOSURE", _unset)
	_endif

	# Handle SLACK HANGER folders
	_if p_folder_name.index_of_seq("SLACK HANGER") _isnt _unset
	_then
		_self.write_figure_eight_for_folder(p_stream, p_area, p_indent, _unset, _unset)
	_endif

	# Handle CABLE folders
	_if p_folder_name.index_of_seq("CABLE") _isnt _unset _andif
	    p_folder_name.index_of_seq("BOUNDARY") _is _unset
	_then
		_self.write_cable_for_folder(p_stream, p_area, p_indent, _unset, _unset)
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_folder_contents(p_stream, p_folder_def, p_area, p_indent, _optional p_parent_line_id, p_parent_fdt_folder)
	## Write placemarks (poles, cables, equipment) for this folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_folder_def - Folder definition property_list
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_parent_line_id - LINE ID inherited from parent folder (first optional)
	##   p_parent_fdt_folder - FDT folder name inherited from parent (second optional)

	folder_name << p_folder_def[:name]
	# Use line_id from folder definition if present, otherwise use parent's line_id
	line_id << p_folder_def[:line_id].default(p_parent_line_id)
	line_type << "LINE " + line_id.default("A")

	# Check if this is a pole folder (EXISTING POLE or NEW POLE)
	_if folder_name.index_of_seq("POLE") _isnt _unset
	_then
		# Query poles in area
		all_poles << .gc[:pole].select(
			predicate.interacts(:location, p_area))

		# Determine filtering criteria from folder name
		is_new_pole? << folder_name.index_of_seq("NEW POLE") _isnt _unset
		is_emr? << folder_name.index_of_seq("EMR") _isnt _unset
		is_partner? << folder_name.index_of_seq("PARTNER") _isnt _unset

		# Extract pole spec if present (e.g., "7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5")
		pole_spec << _unset
		_for spec _over {"7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5"}.fast_elements()
		_loop
			_if folder_name.index_of_seq(spec) _isnt _unset
			_then
				pole_spec << spec
				_leave
			_endif
		_endloop

		# DEBUG: Print folder criteria
		#write("  Processing folder: ", folder_name, " (LINE: ", line_type, ")")
		#write("    NEW? ", is_new_pole?, " EMR? ", is_emr?, " PARTNER? ", is_partner?, " Spec: ", pole_spec)

		# Filter and write poles based on folder criteria
		pole_count << 0
		_for pole _over all_poles.fast_elements()
		_loop
			# Construct template folder name from pole attributes
			pole_template_folder << _self.get_pole_template_folder_name(pole)

			# Check if constructed folder name matches current template folder
			_if pole_template_folder = folder_name
			_then
				.object_writer.write_pole(pole, p_stream, p_indent, folder_name)
				pole_count +<< 1
				.total_pole_count +<< 1
			_endif
		_endloop

		# Store statistics for this folder
		_if pole_count > 0
		_then
			.pole_statistics[folder_name] << pole_count
			write("  Wrote ", pole_count, " poles to folder: ", folder_name, " (Total so far: ", .total_pole_count, ")")
		_endif

	_endif

	# Handle FAT folders - export FAT equipment
	_if folder_name.index_of_seq("FAT") _isnt _unset _andif
	    folder_name.index_of_seq("BOUNDARY") _is _unset  # Not BOUNDARY FAT
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "FAT", line_id, p_parent_fdt_folder)
	_endif

	# Handle FDT folders - export FDT equipment
	_if folder_name.index_of_seq("FDT") _isnt _unset
	_then
		# Export FDTs - they can be on poles or standalone (mit_terminal_enclosure)
		_self.write_fdt_equipment(p_stream, p_area, p_indent, p_parent_fdt_folder)
	_endif

	# Handle CLOSURE/JOINT CLOSURE folders - export CLOSURE equipment
	_if folder_name.index_of_seq("JOINT CLOSURE") _isnt	_unset _orif
		folder_name.index_of_seq("CLOSURE") _isnt _unset
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "CLOSURE", line_id)
	_endif

	# Handle SLACK HANGER folders - export figure_eight equipment
	_if folder_name.index_of_seq("SLACK HANGER") _isnt _unset
	_then
		_self.write_figure_eight_for_folder(p_stream, p_area, p_indent, line_id, p_parent_fdt_folder)
	_endif

	# Handle SLING WIRE folders - export sling_wire chains
	_if folder_name.index_of_seq("SLING WIRE") _isnt _unset
	_then
		_self.write_sling_wire_for_folder(p_stream, p_area, p_indent, line_id, p_parent_fdt_folder)
	_endif

	# Handle CABLE/DISTRIBUTION CABLE folders - export sheath_with_loc chains from poles
	_if folder_name.index_of_seq("CABLE") _isnt _unset _andif
	    folder_name.index_of_seq("BOUNDARY") _is _unset  # Not BOUNDARY folders
	_then
		_self.write_cable_for_folder(p_stream, p_area, p_indent, line_id, p_parent_fdt_folder)
	_endif

	# Handle HP COVER/HP UNCOVER folders - export demand points
	_if folder_name.index_of_seq("HP COVER") _isnt _unset _orif
	    folder_name.index_of_seq("HP UNCOVER") _isnt _unset
	_then
		_self.write_demand_points_for_folder(p_stream, p_area, p_indent, folder_name, line_id, p_parent_fdt_folder)
	_endif

	# Handle BOUNDARY CLUSTER folder - export project boundary polygon
	_if folder_name.uppercase = "BOUNDARY CLUSTER"
	_then
		_self.write_project_boundary(p_stream, p_area, p_indent, folder_name)
	_endif

	# Handle BOUNDARY folders - export cells (ftth!zone)
	_if folder_name.index_of_seq("BOUNDARY FAT") _isnt _unset _orif
	    folder_name.index_of_seq("FAT COVERAGE") _isnt _unset
	_then
		_self.write_cells_for_folder(p_stream, p_area, p_indent, folder_name, line_id, p_parent_fdt_folder)
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_fdt_equipment(p_stream, p_area, p_indent, _optional p_fdt_folder)
	## Write FDT equipment - handles both pole-mounted and standalone FDTs
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_fdt_folder - FDT folder name for filtering (optional)

	fdt_count << 0

	# 1. Export FDTs on poles (sheath_splice with type FDT)
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	_for pole _over all_poles.fast_elements()
	_loop
		pole_geom << pole.location
		_if pole_geom _is _unset _then _continue _endif

		# Get equipment on pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment.empty? _then _continue _endif

		# Get sheath_splice equipment
		pole_splices << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :sheath_splice)))

		_for splice _over pole_splices.fast_elements()
		_loop
			# Check if it's an FDT
			splice_type << splice.sheath_splice_object_type
			_if splice_type _is _unset _then _continue _endif

			_if splice_type.uppercase = "FDT"
			_then
				# Filter by FDT folder if specified
				_if p_fdt_folder _isnt _unset
				_then
					# Get FDT name from equipment
					fdt_name << splice.perform(:name).default("")
					# Extract expected name from folder (e.g., "FDT_FDT001" -> "FDT001")
					_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
					_then
						expected_fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)
						_if fdt_name.uppercase <> expected_fdt_name.uppercase
						_then
							_continue  # Skip if doesn't match this FDT folder
						_endif
					_endif
				_endif

				# Write the FDT
				.object_writer.write_sheath_splice(splice, pole_geom, p_stream, p_indent)
				fdt_count +<< 1
				.total_fdt_count +<< 1
			_endif
		_endloop
	_endloop

	# 2. Export standalone FDTs (mit_terminal_enclosure)
	terminal_enclosures << .gc[:mit_terminal_enclosure].select(
		predicate.within(:location, p_area))

	_for terminal _over terminal_enclosures.fast_elements()
	_loop
		terminal_geom << terminal.location
		_if terminal_geom _is _unset _then _continue _endif

		# Filter by FDT folder if specified
		_if p_fdt_folder _isnt _unset
		_then
			terminal_name << terminal.perform(:name).default("")
			_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
			_then
				expected_fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)
				_if terminal_name.uppercase <> expected_fdt_name.uppercase
				_then
					_continue
				_endif
			_endif
		_endif

		# Write terminal enclosure as FDT
		# Convert terminal to equipment-like format for writer
		.object_writer.write_terminal_enclosure(terminal, terminal_geom, p_stream, p_indent)
		fdt_count +<< 1
		.total_fdt_count +<< 1
	_endloop

	_if fdt_count > 0
	_then
		write("  Wrote ", fdt_count, " FDT equipment")
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_sheath_splices_for_folder(p_stream, p_area, p_indent, p_equipment_type, _optional p_line_id, p_fdt_folder)
	## Write sheath splice equipment to folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_equipment_type - "FAT", "FDT", or "CLOSURE"
	##   p_line_id - LINE ID (A/B/C/D) for filtering, _unset if not in LINE folder (first optional)
	##   p_fdt_folder - FDT folder name (e.g., "FDT_FDT001") for FAT filtering (second optional)

	# Query poles in area to find equipment on them
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	equipment_count << 0

	# DEBUG: Track processing
	poles_checked << 0
	splices_found << 0

	# Iterate through poles and find sheath splices
	_for pole _over all_poles.fast_elements()
	_loop
		poles_checked +<< 1
		pole_geom << pole.location
		_if pole_geom _is _unset _then _continue _endif

		# Get all equipment on this pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment.empty? _then _continue _endif

		# DEBUG: First few poles
		#write("    Pole ", pole.telco_pole_tag, " has ", pole_equipment.size, " equipment items")

		# Get sheath_splice from equipment using predicate
		pole_splices << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :sheath_splice)))

		_if pole_splices.empty? _then _continue _endif

		splices_found +<< pole_splices.size

		# DEBUG
		#write("    Found ", pole_splices.size, " sheath splices on pole ", pole.telco_pole_tag)

		_for splice _over pole_splices.fast_elements()
		_loop
			# Get splice type from equipment object (like in detect_network)
			splice_type << splice.sheath_splice_object_type
			_if splice_type _is _unset
			_then
				write("    WARNING: Could not get sheath_splice_object_type from equipment")
				_continue
			_endif

			# DEBUG
			#_if equipment_count < 3
			#_then
			#	write("    Splice equipment ID:", splice.id, " Type:", splice_type)
			#_endif

			# Filter by equipment type
			matches_type? << _false
			_if p_equipment_type = "FAT" _andif
			    splice_type.index_of_seq("FAT") _isnt _unset
			_then
				matches_type? << _true
			_elif p_equipment_type = "FDT" _andif
			      splice_type.index_of_seq("FDT") _isnt _unset
			_then
				matches_type? << _true
			_elif p_equipment_type = "CLOSURE" _andif
			      (splice_type.index_of_seq("Closure") _isnt _unset _orif
			       splice_type.index_of_seq("Joint") _isnt _unset)
			_then
				matches_type? << _true
			_endif

			_if _not matches_type? _then _continue _endif

			# For FAT in LINE folders, check if pole's line_type matches
			_if p_equipment_type = "FAT" _andif p_line_id _isnt _unset
			_then
				# Convert p_line_id to line_type format (e.g., "A" -> "LINE A")
				expected_line_type << "LINE " + p_line_id
				pole_line_type << pole.perform(:line_type).default("")

				# DEBUG
				#_if equipment_count < 3
				#_then
				#	write("      Checking LINE: pole line_type='", pole_line_type, "' expected='", expected_line_type, "'")
				#_endif

				_if pole_line_type.uppercase <> expected_line_type.uppercase
				_then
					_continue  # Skip FAT if pole doesn't match LINE
				_endif

				# Also check FAT ring_name matches FDT folder
				_if p_fdt_folder _isnt _unset
				_then
					# Get FAT ring_name
					fat_ring_name << splice.perform(:ring_name).default("")

					# FDT folder format is "FDT_<name>", extract the name part
					# Expected ring_name should match the FDT name
					_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
					_then
						# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
						fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)

						# DEBUG
						#_if equipment_count < 3
						#_then
						#	write("      Checking FDT: FAT ring_name='", fat_ring_name, "' expected FDT='", fdt_name, "'")
						#_endif

						# Check if ring_name matches FDT name
						_if fat_ring_name.uppercase <> fdt_name.uppercase
						_then
							_continue  # Skip FAT if it doesn't belong to this FDT
						_endif
					_endif
				_endif
			_endif

			# Write the sheath splice (pass equipment object)
			.object_writer.write_sheath_splice(splice, pole_geom, p_stream, p_indent)
			equipment_count +<< 1

			# Increment global counters
			_if p_equipment_type = "FAT"
			_then
				.total_fat_count +<< 1
			_elif p_equipment_type = "FDT"
			_then
				.total_fdt_count +<< 1
			_elif p_equipment_type = "CLOSURE"
			_then
				.total_closure_count +<< 1
			_endif
		_endloop
	_endloop

	write("  ", p_equipment_type, " summary: Checked ", poles_checked, " poles, found ", splices_found, " total splices, wrote ", equipment_count, " matching ", p_equipment_type)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_figure_eight_for_folder(p_stream, p_area, p_indent, _optional p_line_id, p_fdt_folder)
	## Write figure_eight (SLACK HANGER) equipment to folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_line_id - LINE ID (A/B/C/D) for filtering, _unset if not in LINE folder (first optional)
	##   p_fdt_folder - FDT folder name (e.g., "FDT_FDT001") for filtering (second optional)

	# Query poles in area to find figure_eight equipment on them
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	equipment_count << 0

	# Iterate through poles and find figure_eight equipment
	_for pole _over all_poles.fast_elements()
	_loop
		pole_geom << pole.location
		_if pole_geom _is _unset _then _continue _endif

		# Get all equipment on this pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment.empty? _then _continue _endif

		# Get figure_eight from equipment using predicate
		pole_figure_eights << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :figure_eight)))

		_if pole_figure_eights.empty? _then _continue _endif

		_for fig8 _over pole_figure_eights.fast_elements()
		_loop
			# Filter by LINE if we're in a LINE folder
			_if p_line_id _isnt _unset
			_then
				# Convert p_line_id to line_type format (e.g., "A" -> "LINE A")
				expected_line_type << "LINE " + p_line_id
				pole_line_type << pole.perform(:line_type).default("")

				_if pole_line_type.uppercase <> expected_line_type.uppercase
				_then
					_continue  # Skip figure_eight if pole doesn't match LINE
				_endif
			_endif

			# Filter by FDT folder if we're inside an FDT folder (cluster structure)
			_if p_fdt_folder _isnt _unset
			_then
				# Get figure_eight ring_name or pole ring_name
				fig8_ring_name << fig8.perform(:ring_name).default("")
				_if fig8_ring_name = ""
				_then
					# Fall back to pole's ring_name
					fig8_ring_name << pole.perform(:ring_name).default("")
				_endif

				# FDT folder format is "FDT_<name>", extract the name part
				_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
				_then
					# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
					fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)

					# Check if ring_name matches FDT name
					_if fig8_ring_name.uppercase <> fdt_name.uppercase
					_then
						_continue  # Skip figure_eight if it doesn't belong to this FDT
					_endif
				_endif
			_endif

			# Write the figure_eight using pole coordinates
			.object_writer.write_figure_eight(fig8, pole_geom, p_stream, p_indent)
			equipment_count +<< 1
			.total_slack_hanger_count +<< 1
		_endloop
	_endloop

	_if equipment_count > 0
	_then
		write("  Wrote ", equipment_count, " SLACK HANGER equipment")
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_sling_wire_for_folder(p_stream, p_area, p_indent, _optional p_line_id, p_fdt_folder)
	## Write sling_wire chains to folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_line_id - LINE ID (A/B/C/D) for filtering, _unset if not in LINE folder (first optional)
	##   p_fdt_folder - FDT folder name (e.g., "FDT_FDT001") for filtering (second optional)

	# Query sling_wire chains in area
	all_sling_wires << .gc[:sling_wire].select(
		predicate.interacts(:route, p_area))

	chain_count << 0

	# Iterate through sling_wire chains
	_for sling_wire _over all_sling_wires.fast_elements()
	_loop
		# Get sling_wire route geometry
		route_geom << sling_wire.route
		_if route_geom _is _unset _then _continue _endif

		# Filter by LINE if we're in a LINE folder
		_if p_line_id _isnt _unset
		_then
			# Convert p_line_id to line_type format (e.g., "A" -> "LINE A")
			expected_line_type << "LINE " + p_line_id
			sling_line_type << sling_wire.perform(:line_type).default("")

			_if sling_line_type.uppercase <> expected_line_type.uppercase
			_then
				_continue  # Skip sling_wire if it doesn't match LINE
			_endif
		_endif

		# Filter by FDT folder if we're inside an FDT folder (cluster structure)
		_if p_fdt_folder _isnt _unset
		_then
			# Get sling_wire ring_name
			sling_ring_name << sling_wire.perform(:ring_name).default("")

			# FDT folder format is "FDT_<name>", extract the name part
			_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
			_then
				# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
				fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)

				# Check if ring_name matches FDT name
				_if sling_ring_name.uppercase <> fdt_name.uppercase
				_then
					_continue  # Skip sling_wire if it doesn't belong to this FDT
				_endif
			_endif
		_endif

		# Write the sling_wire using its route geometry
		.object_writer.write_sling_wire(sling_wire, route_geom, p_stream, p_indent)
		chain_count +<< 1
		.total_sling_wire_count +<< 1
	_endloop

	_if chain_count > 0
	_then
		write("  Wrote ", chain_count, " SLING WIRE chains")
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_cable_for_folder(p_stream, p_area, p_indent, _optional p_line_id, p_fdt_folder)
	## Write cable/sheath_with_loc chains to folder
	## Queries aerial_route in area, collects cables from each route
	## Merges sectors for cables with same name
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_line_id - LINE ID (A/B/C/D) for filtering, _unset if not in LINE folder (first optional)
	##   p_fdt_folder - FDT folder name (e.g., "FDT_FDT001") for filtering (second optional)

	# Step 1: Query aerial_route objects in area
	all_aerial_routes << .gc[:aerial_route].select(
		predicate.interacts(:route, p_area))

	# Step 2: Collect unique cables from all aerial routes using equality_set
	unique_cables << equality_set.new()

	_for aerial_route _over all_aerial_routes.fast_elements()
	_loop
		# Get cables from this aerial_route
		route_cables << aerial_route.cables()
		_if route_cables _is _unset _then _continue _endif

		# Add cables to set (automatically handles duplicates)
		_for cable _over route_cables.fast_elements()
		_loop
			unique_cables.add(cable)
		_endloop
	_endloop

	# Step 3: Group cables by name and collect their sectors
	cables_by_name << property_list.new()

	_for cable _over unique_cables.fast_elements()
	_loop
		# Filter by LINE if we're in a LINE folder
		_if p_line_id _isnt _unset
		_then
			# Convert p_line_id to line_type format (e.g., "A" -> "LINE A")
			expected_line_type << "LINE " + p_line_id
			cable_line_type << cable.perform(:line_type).default("")

			_if cable_line_type.uppercase <> expected_line_type.uppercase
			_then
				_continue  # Skip cable if it doesn't match LINE
			_endif
		_endif

		# Filter by FDT folder if we're inside an FDT folder (cluster structure)
		_if p_fdt_folder _isnt _unset
		_then
			# Get cable ring_name
			cable_ring_name << cable.perform(:ring_name).default("")

			# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
			_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
			_then
				expected_fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)

				# Check if ring_name matches FDT name
				_if cable_ring_name.uppercase <> expected_fdt_name.uppercase
				_then
					_continue  # Skip cable if it doesn't belong to this FDT
				_endif
			_endif
		_endif

		# Get cable name for grouping
		cable_name << cable.perform(:name).default("Unknown").as_symbol()

		# Get cable geometry using route_sectors()
		cable_sectors << cable.route_sectors()
		_if cable_sectors _is _unset _orif cable_sectors.empty? _then _continue _endif

		# Group by name - store cable and its sectors
		_if cables_by_name[cable_name] _is _unset
		_then
			cables_by_name[cable_name] << property_list.new_with(
				:cable, cable,
				:sector_list, rope.new())
		_endif

		# Add sectors to the list
		cables_by_name[cable_name][:sector_list].add_last(cable_sectors)
	_endloop

	# Step 4: Merge sectors for each cable name and export
	# Cable count is based on unique cable names (after merging)
	cable_count << cables_by_name.size

	_for cable_name, cable_data _over cables_by_name.fast_keys_and_elements()
	_loop
		write("  Processing CABLE: ", cable_name)
		cable << cable_data[:cable]
		sector_list << cable_data[:sector_list]
		# Merge sectors that connect (last coord of one = first coord of next)
		merged_sectors << _self.merge_cable_sectors(sector_list)

		# Write the cable using merged sectors
		.object_writer.write_cable(cable, merged_sectors, p_stream, p_indent)
	_endloop

	# Update total cable count (based on unique cable names)
	.total_cable_count +<< cable_count

	_if cable_count > 0
	_then
		write("  Wrote ", cable_count, " CABLE chains (merged by name)")
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_demand_points_for_folder(p_stream, p_area, p_indent, p_folder_name, _optional p_line_id, p_fdt_folder)
	## Write demand points (home pass) to folder based on folder name and filters
	## For HP COVER: Creates subfolders based on last part of notes field (after last |)
	## For HP UNCOVER: Exports directly without subfolders
	## Filters by line_type field and FDT ring_name
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_folder_name - Folder name (HP COVER or HP UNCOVER)
	##   p_line_id - LINE ID for filtering (optional)
	##   p_fdt_folder - FDT folder name for filtering (optional)

	# Get all demand points in area
	all_demand_points << .gc[:ftth!demand_point].select(
		predicate.interacts(:location, p_area))

	write("  Found ", all_demand_points.size, " demand points in area for folder: ", p_folder_name)

	# Determine if this is HP COVER or HP UNCOVER
	is_hp_cover? << p_folder_name.uppercase.index_of_seq("HP COVER") _isnt _unset
	is_hp_uncover? << p_folder_name.uppercase.index_of_seq("HP UNCOVER") _isnt _unset

	# For HP COVER: Group DPs by subfolder name (from notes)
	# For HP UNCOVER: Write directly
	_if is_hp_cover?
	_then
		# Group demand points by subfolder (last part of notes after |)
		dp_by_subfolder << equality_hash_table.new()

		_for dp _over all_demand_points.fast_elements()
		_loop
			# Get location geometry
			dp_geom << dp.location
			_if dp_geom _is _unset _then _continue _endif

			# Get notes and line_type
			notes << dp.perform(:notes).default("")
			line_type << dp.perform(:line_type).default("")
			_if notes = "" _then _continue _endif

			# Parse notes to extract ring_name and subfolder_name
			# Format: "ring_name|full_folders"
			# Example: "FDT 01|CLU001|LINE A|FDT 01|HP COVER|A01"
			# We want the last part after last |
			pipe_positions << rope.new()
			_for i _over 1.upto(notes.size)
			_loop
				_if notes[i] = %| _then pipe_positions.add(i) _endif
			_endloop

			_if pipe_positions.empty?
			_then
				ring_name << notes
				subfolder_name << ""
			_else
				first_pipe << pipe_positions.first
				ring_name << notes.slice(1, first_pipe - 1)
				last_pipe << pipe_positions.last
				subfolder_name << notes.slice_to_end(last_pipe + 1)
			_endif

			# Check if this DP belongs to HP COVER (has subfolder name in notes)
			_if subfolder_name = "" _orif
			    notes.uppercase.index_of_seq("HP COVER") _is _unset
			_then
				_continue  # Not for HP COVER
			_endif

			# Filter by LINE if specified (use line_type field)
			_if p_line_id _isnt _unset _andif line_type <> ""
			_then
				expected_line << p_line_id
				_if line_type.uppercase.index_of_seq(expected_line.uppercase) _is _unset
				_then
					_continue
				_endif
			_endif

			# Filter by FDT folder if specified
			_if p_fdt_folder _isnt _unset _andif ring_name <> ""
			_then
				expected_fdt_name << p_fdt_folder
				_if ring_name.uppercase.index_of_seq(expected_fdt_name.uppercase) _is _unset
				_then
					_continue
				_endif
			_endif

			# Add to appropriate subfolder
			_if dp_by_subfolder[subfolder_name] _is _unset
			_then
				dp_by_subfolder[subfolder_name] << rope.new()
			_endif
			dp_by_subfolder[subfolder_name].add(dp)
		_endloop

		# Write each subfolder with its DPs
		dp_count << 0
		_for subfolder_name, dps _over dp_by_subfolder.fast_keys_and_elements()
		_loop
			# Open subfolder
			p_stream.write(p_indent, "<Folder>", newline_char)
			p_stream.write(p_indent, "  <name>", subfolder_name, "</name>", newline_char)
			p_stream.write(p_indent, "  <open>0</open>", newline_char)

			# Write all DPs in this subfolder
			subfolder_indent << p_indent + "  "
			_for dp _over dps.fast_elements()
			_loop
				.object_writer.write_demand_point(dp, p_stream, subfolder_indent, p_folder_name)
				dp_count +<< 1
			_endloop

			# Close subfolder
			p_stream.write(p_indent, "</Folder>", newline_char)
			write("    Wrote ", dps.size, " demand points to subfolder: ", subfolder_name)
		_endloop

		# Update total counter
		.total_hp_count +<< dp_count

	_elif is_hp_uncover?
	_then
		# HP UNCOVER: Write directly without subfolders
		dp_count << 0

		_for dp _over all_demand_points.fast_elements()
		_loop
			# Get location geometry
			dp_geom << dp.location
			_if dp_geom _is _unset _then _continue _endif

			# Get notes and line_type
			notes << dp.perform(:notes).default("")
			line_type << dp.perform(:line_type).default("")
			_if notes = "" _then _continue _endif

			# Parse notes to extract ring_name
			pipe_pos << notes.index_of(%|)
			_if pipe_pos _isnt _unset
			_then
				ring_name << notes.slice(1, pipe_pos - 1)
			_else
				ring_name << notes
			_endif

			# Check if this DP belongs to HP UNCOVER (doesn't have HP COVER in notes)
			_if notes.uppercase.index_of_seq("HP UNCOVER") _is _unset
			_then
				_continue  # Not for HP UNCOVER
			_endif

			# Filter by LINE if specified (use line_type field)
			_if p_line_id _isnt _unset _andif line_type <> ""
			_then
				expected_line << p_line_id
				_if line_type.uppercase.index_of_seq(expected_line.uppercase) _is _unset
				_then
					_continue
				_endif
			_endif

			# Filter by FDT folder if specified
			_if p_fdt_folder _isnt _unset _andif ring_name <> ""
			_then
				expected_fdt_name << p_fdt_folder
				_if ring_name.uppercase.index_of_seq(expected_fdt_name.uppercase) _is _unset
				_then
					_continue
				_endif
			_endif

			# Write demand point directly
			.object_writer.write_demand_point(dp, p_stream, p_indent, p_folder_name)
			dp_count +<< 1
		_endloop

		# Update total counter
		.total_hp_count +<< dp_count

		_if dp_count > 0
		_then
			write("  Wrote ", dp_count, " demand points to folder: ", p_folder_name)
		_endif
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_cells_for_folder(p_stream, p_area, p_indent, p_folder_name, _optional p_line_id, p_fdt_folder)
	## Write cells (ftth!zone) to folder based on folder name and filters
	## Filters by LINE and FDT ring_name from note field
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_folder_name - Folder name (BOUNDARY CLUSTER, BOUNDARY FAT, FAT COVERAGE, etc.)
	##   p_line_id - LINE ID for filtering (optional)
	##   p_fdt_folder - FDT folder name for filtering (optional)

	# Get all cells in area
	all_cells << .gc[:ftth!zone].select(
		predicate.interacts(:location, p_area))

	write("  Found ", all_cells.size, " cells in area for folder: ", p_folder_name)

	cell_count << 0

	_for cell _over all_cells.fast_elements()
	_loop
		# Get location geometry (polygon)
		cell_geom << cell.location
		_if cell_geom _is _unset _then _continue _endif

		# Get note field containing ring_name and folders
		# Format: "ring_name|folders"
		note << cell.perform(:note).default("")
		_if note = "" _then _continue _endif

		# Parse note to extract ring_name and folders
		pipe_pos << note.index_of(%|)
		_if pipe_pos _is _unset
		_then
			ring_name << note
			cell_folders << ""
		_else
			ring_name << note.slice(1, pipe_pos - 1)
			cell_folders << note.slice_to_end(pipe_pos + 1)
		_endif

		# Check if this cell belongs to current folder by matching parent folders
		# The cell_folders should contain the current p_folder_name hierarchy
		_if cell_folders = "" _orif
		    cell_folders.uppercase.index_of_seq(p_folder_name.uppercase) _is _unset
		_then
			_continue
		_endif

		# Filter by LINE if specified
		_if p_line_id _isnt _unset _andif cell_folders <> ""
		_then
			# Check if folders contain the LINE pattern
			expected_line << write_string("LINE ", p_line_id)
			_if cell_folders.uppercase.index_of_seq(expected_line.uppercase) _is _unset
			_then
				_continue
			_endif
		_endif

		# Filter by FDT folder if specified (ring_name matching)
		_if p_fdt_folder _isnt _unset _andif ring_name <> ""
		_then
			# Extract FDT name from folder (e.g., "FDT 01" -> "FDT 01")
			expected_fdt_name << p_fdt_folder
			_if ring_name.uppercase.index_of_seq(expected_fdt_name.uppercase) _is _unset
			_then
				_continue
			_endif
		_endif

		# Write cell
		.object_writer.write_cell(cell, p_stream, p_indent, p_folder_name)
		cell_count +<< 1
	_endloop

	# Update total counter
	.total_cell_count +<< cell_count

	_if cell_count > 0
	_then
		write("  Wrote ", cell_count, " cells to folder: ", p_folder_name)
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_project_boundary(p_stream, p_area, p_indent, p_folder_name)
	## Write project boundary polygon using project_area and project_name
	## Creates a single boundary polygon placemark with the scheme/project name
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area (polygon geometry)
	##   p_indent - Indentation string
	##   p_folder_name - Folder name (BOUNDARY CLUSTER)

	write("  Exporting project boundary for: ", .project_name)

	# Check if we have project area
	_if .project_area _is _unset
	_then
		write("  WARNING: No project area available for boundary export")
		_return
	_endif

	# Use project_name as the boundary name and project_area as the geometry
	boundary_name << .scheme_name
	boundary_geom << .project_area

	# Write the boundary polygon using object writer
	.object_writer.write_boundary(boundary_name, boundary_geom, p_stream, p_indent, p_folder_name)

	write("  Wrote project boundary: ", boundary_name)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.merge_cable_sectors(p_sector_list)
	## Merge cable sectors that connect end-to-end
	## If last coord of sector1 = first coord of sector2, merge them
	## If first coord of sector1 = last coord of sector2, reverse sector2 and merge
	##
	## Parameters:
	##   p_sector_list - Rope of sector lists
	##
	## Returns:
	##   Rope of merged sectors

	_if p_sector_list.empty? _then _return p_sector_list _endif

	# Convert to working list
	remaining_sectors << rope.new_from(p_sector_list)
	write("    Merging ", remaining_sectors.size, " sectors")	
	
	# Start with first sector
	merged_sectors << remaining_sectors.remove_first()

	# Keep trying to merge until no more connections found
	_loop
		found_match? << _false
		current_first << merged_sectors.first_coord
		current_last << merged_sectors.last_coord

		# Try to find a sector that connects to current
		_for i _over 1.upto(remaining_sectors.size)
		_loop
			test_sector << remaining_sectors[i]
			test_first << test_sector.first_coord
			test_last << test_sector.last_coord

			# Check if test_sector connects to end of current (forward)
			# current.last = test.first
			_if current_last = test_first
			_then
				# Connects forward - append it
				merged_sectors.add_all_last(test_sector)
				remaining_sectors.remove_nth(i)
				found_match? << _true
				_leave
			# Check if test_sector connects to start of current 
			# current.first = test.last
			_elif current_first = test_last
			_then
				# Connects in reverse - reverse test_sector and prepend
				merged_sectors.add_all_first(test_sector)
				remaining_sectors.remove_nth(i)
				found_match? << _true
				_leave
			_endif
		_endloop

		# If no match found and remaining sectors is empty then leave
		_if _not found_match? _orif remaining_sectors.empty?
		_then
			write("    No connecting sector found: ", remaining_sectors.size, " sectors remaining")
			_leave
		_endif
	_endloop

	>> merged_sectors
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.create_kmz_from_kml(p_kml_file)
	## Create KMZ file (zipped KML)

	kmz_file << p_kml_file.substitute_string(".kml", ".kmz")

	# Use system zip command (Windows compatible)
	_if system.getenv("OS").default("").matches?("Windows")
	_then
		# Windows: use PowerShell Compress-Archive
		# PowerShell handles paths with spaces correctly
		zip_cmd << write_string("powershell -Command ",
			%", "Compress-Archive -Force -Path '", p_kml_file, "' -DestinationPath '", kmz_file, "'", %")

		system.do_command(zip_cmd)
	_else
		# Unix/Linux: use zip command
		# Get directory and basename for zip command
		last_slash << p_kml_file.rindex_of(%\)
		_if last_slash _is _unset
		_then
			last_slash << p_kml_file.rindex_of(%/)
		_endif

		_if last_slash _isnt _unset
		_then
			kml_dir << p_kml_file.slice(1, last_slash - 1)
			kml_basename << p_kml_file.slice_to_end(last_slash + 1)
		_else
			kml_dir << "."
			kml_basename << p_kml_file
		_endif

		kmz_basename << kml_basename.substitute_string(".kml", ".kmz")

		zip_cmd << write_string("cd ", %", kml_dir, %", " && zip -q ", %", kmz_basename, %", " ", %", kml_basename, %")
		system.do_command(zip_cmd)
	_endif

	# Delete temporary KML file
	system.unlink(p_kml_file)

	>> kmz_file
_endmethod
$
