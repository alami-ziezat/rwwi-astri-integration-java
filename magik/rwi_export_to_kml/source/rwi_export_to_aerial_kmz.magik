#% text_encoding = iso8859_1
_package user
$

## AERIAL KMZ EXPORTER
## Main class for exporting Smallworld network to FORMAT KMZ AERIAL hierarchy
## Integrates with ASTRI Work Order Dialog

remex(:rwi_export_to_aerial_kmz)
$

_pragma(classify_level=basic, topic={rwi_export})
def_slotted_exemplar(:rwi_export_to_aerial_kmz,
{
	{:gc, _unset, :writable},                    # GIS case
	{:project_name, _unset, :writable},          # Project name (from WO number)
	{:project_area, _unset, :writable},          # Design boundary area
	{:output_directory, _unset, :writable},      # Output directory
	{:infrastructure_type, _unset, :writable},   # Infrastructure type filter (cluster/feeder/subfeeder)
	{:infrastructure_code, _unset, :writable},   # Infrastructure code (e.g., "CLU001")
	{:style_manager, _unset, :writable},         # Style manager instance
	{:folder_builder, _unset, :writable},        # Folder builder instance
	{:object_writer, _unset, :writable},         # Object writer instance
	{:line_assigner, _unset, :writable},         # LINE assigner instance
	{:total_pole_count, _unset, :writable},      # Total poles exported
	{:pole_statistics, _unset, :writable},       # Property list tracking poles per folder
	{:total_fat_count, _unset, :writable},       # Total FATs exported
	{:total_fdt_count, _unset, :writable},       # Total FDTs exported
	{:total_closure_count, _unset, :writable},   # Total CLOSUREs exported
	{:total_slack_hanger_count, _unset, :writable}  # Total SLACK HANGERs exported
}, :object)
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_export_to_aerial_kmz.new()
	## Create new exporter instance
	>> _clone.init()
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.init()
	## Initialize exporter with helper instances

	# Create helper instances
	.style_manager << rwi_aerial_kmz_style_manager.new()
	.folder_builder << rwi_aerial_kmz_folder_builder.new()
	.object_writer << rwi_aerial_kmz_object_writer.new()
	.line_assigner << rwi_aerial_kmz_line_assigner.new()

	>> _self
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_export_to_aerial_kmz.export_mixed_network(p_area, p_output_file)
	## Main export method - exports with automatic network level detection
	## and infrastructure type filtering
	##
	## Parameters:
	##   p_area - Design boundary area (pseudo_polygon)
	##   p_output_file - Output file path (e.g., "WO_12345.kmz")
	##
	## Returns:
	##   property_list - {:output_file, string, :statistics, property_list}

	write("Starting aerial KMZ export...")
	write("  Project:", .project_name)
	write("  Infrastructure Type:", .infrastructure_type)

	# Detect network levels in area
	levels << _self.detect_network_levels_in_area(p_area)

	# Filter based on infrastructure type
	_if .infrastructure_type _isnt _unset _and
	    .infrastructure_type <> :all
	_then
		write("  Filtering to infrastructure type:", .infrastructure_type)

		_if .infrastructure_type _is :cluster
		_then
			levels[:feeder] << _false
			levels[:subfeeder] << _false
		_elif .infrastructure_type _is :feeder
		_then
			levels[:subfeeder] << _false
			levels[:cluster] << _false
		_elif .infrastructure_type _is :subfeeder
		_then
			levels[:feeder] << _false
			levels[:cluster] << _false
		_endif
	_endif

	write("  Network levels to export:")
	write("    FEEDER:", levels[:feeder])
	write("    SUBFEEDER:", levels[:subfeeder])
	write("    CLUSTER:", levels[:cluster])

	# Create KML file
	kml_file << _self.create_kml_file(p_output_file, p_area, levels)

	# Create KMZ (zip the KML) - COMMENTED OUT FOR NOW
	# kmz_file << _self.create_kmz_from_kml(kml_file)

	write("Export complete:", kml_file)

	# Return output file and statistics
	>> property_list.new_with(
		:output_file, kml_file,
		:total_poles, .total_pole_count,
		:pole_statistics, .pole_statistics,
		:total_fats, .total_fat_count,
		:total_fdts, .total_fdt_count,
		:total_closures, .total_closure_count,
		:total_slack_hangers, .total_slack_hanger_count,
		:project_name, .project_name,
		:infrastructure_type, .infrastructure_type)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.detect_network_levels_in_area(p_area)
	## Detect which network levels are present in the export area
	## Logic:
	##   1. FEEDER: Find if mit_hub is inside project area
	##   2. SUBFEEDER: Find poles in area, check if poles have sheath_splice with type Joint Closure/Closure AND FDT
	##   3. CLUSTER: Find poles in area, check if poles have sheath_splice with type FDT AND FAT
	##
	## Returns:
	##   property_list - {:feeder, boolean, :subfeeder, boolean, :cluster, boolean, :fdts, rope}

	levels << property_list.new_with(
		:feeder, _false,
		:subfeeder, _false,
		:cluster, _false,
		:fdts, rope.new())

	# 1. FEEDER: Check for mit_hub in area
	olts << .gc[:mit_hub].select(
		predicate.within(:location, p_area))

	_if olts.size > 0
	_then
		levels[:feeder] << _true
		write("  Detected FEEDER network (", olts.size, " OLTs/hubs)")
	_endif

	# Get all poles in area first
	all_poles << .gc[:pole].select(
		predicate.within(:location, p_area))

	write("  Found ", all_poles.size, " poles in area")

	# Now check equipment on these poles
	has_joint_closure << _false
	has_fdt << _false
	has_fat << _false
	all_fdts << rope.new()

	_for pole _over all_poles.fast_elements()
	_loop
		# Get all equipment on this pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment _is _unset _then _continue _endif

		# Get sheath_splice from equipment
		pole_splices << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :sheath_splice)))

		# Check if sheath_splice exists on this pole
		_if _not pole_splices.empty?
		_then
			# Check each sheath_splice
			_for splice _over pole_splices.fast_elements()
			_loop
				splice_type << splice.sheath_splice_object_type
				_if splice_type _is _unset _then _continue _endif

				# Check for Joint Closure (SUBFEEDER indicator)
				_if splice_type.lowercase = "joint closure" _or
				    splice_type.lowercase = "closure"
				_then
					has_joint_closure << _true
				_endif

				# Check for FDT (SUBFEEDER and CLUSTER indicator)
				_if splice_type.uppercase = "FDT"
				_then
					has_fdt << _true
					all_fdts.add_last(splice)
				_endif

				# Check for FAT (CLUSTER indicator)
				_if splice_type.uppercase = "FAT"
				_then
					has_fat << _true
				_endif
			_endloop
		_endif
	_endloop

	# Check for mit_terminal_enclosure directly in area (world geometry)
	terminal_enclosures << .gc[:mit_terminal_enclosure].select(
		predicate.within(:location, p_area))

	_if terminal_enclosures.size > 0
	_then
		has_fdt << _true
		_for terminal _over terminal_enclosures.fast_elements()
		_loop
			all_fdts.add_last(terminal)
		_endloop
		write("  Found ", terminal_enclosures.size, " mit_terminal_enclosures (FDTs) in area")
	_endif

	# Store all FDTs found
	levels[:fdts] << all_fdts

	# 2. SUBFEEDER: Poles have Joint Closure AND FDT
	_if has_joint_closure _and has_fdt
	_then
		levels[:subfeeder] << _true
		write("  Detected SUBFEEDER network (has Joint Closures and FDTs on poles)")
	_endif

	# 3. CLUSTER: Poles have FDT AND FAT
	_if has_fdt _and has_fat
	_then
		levels[:cluster] << _true
		write("  Detected CLUSTER network (", all_fdts.size, " FDTs and FATs on poles)")
	_endif

	>> levels
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.create_kml_file(p_output_file, p_area, p_levels)
	## Create KML file with dynamic folder structure using template

	# Initialize counters and statistics
	.total_pole_count << 0
	.pole_statistics << property_list.new()
	.total_fat_count << 0
	.total_fdt_count << 0
	.total_closure_count << 0
	.total_slack_hanger_count << 0

	# Replace .kmz with .kml for temp file
	kml_file << p_output_file.substitute_string(".kmz", ".kml")

	# Load template file
	template_file << smallworld_product.get_data_file("aerial_template.kml", :rwi_export_to_kml)
	_if template_file _is _unset
	_then
		condition.raise(:error, :string, "Template file aerial_template.kml not found")
	_endif

	# Read template content
	template_stream << external_text_input_stream.new(template_file.write_string)
	template_content << rope.new()
	_loop
		line << template_stream.get_line()
		_if line _is _unset _then _leave _endif
		template_content.add_last(line)
	_endloop
	template_stream.close()

	# Create output stream
	kml_stream << external_text_output_stream.new(kml_file)

	# Write template header and styles (up to CONTENT_PLACEHOLDER)
	_for line _over template_content.fast_elements()
	_loop
		_if line.index_of_seq("CONTENT_PLACEHOLDER") _isnt _unset
		_then
			_leave  # Stop before placeholder
		_endif

		# Replace project name placeholder
		_local output_line << line
		_if line.index_of_seq("PROJECT_NAME_PLACEHOLDER") _isnt _unset
		_then
			output_line << line.substitute_string("PROJECT_NAME_PLACEHOLDER", .project_name.default("AERIAL_EXPORT"))
		_endif

		kml_stream.write(output_line, newline_char)
	_endloop

	# Write network level folders
	_if p_levels[:feeder]
	_then
		write("Exporting FEEDER network...")
		_self.write_feeder_section(kml_stream, p_area)
	_endif

	_if p_levels[:subfeeder]
	_then
		write("Exporting SUBFEEDER network...")
		_self.write_subfeeder_section(kml_stream, p_area)
	_endif

	_if p_levels[:cluster]
	_then
		write("Exporting CLUSTER network...")
		_self.write_cluster_section(kml_stream, p_area, p_levels[:fdts])
	_endif

	# Write KML footer
	_self.write_kml_footer(kml_stream)

	kml_stream.close()

	# Display detailed statistics report
	_self.print_export_statistics()

	>> kml_file
_endmethod
$


_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_kml_footer(p_stream)
	## Write KML document footer

	p_stream.write("</Document>", newline_char)
	p_stream.write("</kml>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.print_export_statistics()
	## Print detailed export statistics report

	write("="*60)
	write("AERIAL KML EXPORT - STATISTICS REPORT")
	write("="*60)
	write("Project: ", .project_name.default("Unknown"))
	write("Infrastructure Type: ", .infrastructure_type.default("All"))
	write("-"*60)
	write("POLE EXPORT SUMMARY:")
	write("-"*60)

	# Sort folders by name for consistent display
	folder_names << .pole_statistics.keys.as_sorted_collection()

	# Display poles per folder
	_if folder_names.size > 0
	_then
		_for folder_name _over folder_names.fast_elements()
		_loop
			count << .pole_statistics[folder_name]
			write("  ", folder_name, ": ", count)
		_endloop
	_else
		write("  No poles exported")
	_endif

	write("-"*60)
	write("TOTAL POLES EXPORTED: ", .total_pole_count)
	write("-"*60)
	write("EQUIPMENT EXPORT SUMMARY:")
	write("-"*60)
	write("  FAT: ", .total_fat_count)
	write("  FDT: ", .total_fdt_count)
	write("  CLOSURE: ", .total_closure_count)
	write("="*60)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_feeder_section(p_stream, p_area)
	## Write FEEDER CODE section with 15 folders

	p_stream.write("  <Folder>", newline_char)
	p_stream.write("    <name>FEEDER CODE</name>", newline_char)

	# Get folder definitions from builder
	folder_defs << .folder_builder.build_feeder_folders()

	# Write each folder
	_for folder_def _over folder_defs.fast_elements()
	_loop
		_self.write_folder(p_stream, folder_def, p_area, 4)
	_endloop

	p_stream.write("  </Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_subfeeder_section(p_stream, p_area)
	## Write SUBFEEDER CODE section with 14 folders

	p_stream.write("  <Folder>", newline_char)
	p_stream.write("    <name>SUBFEEDER CODE</name>", newline_char)

	# Get folder definitions from builder
	folder_defs << .folder_builder.build_subfeeder_folders()

	# Write each folder
	_for folder_def _over folder_defs.fast_elements()
	_loop
		_self.write_folder(p_stream, folder_def, p_area, 4)
	_endloop

	p_stream.write("  </Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_cluster_section(p_stream, p_area, p_fdts)
	## Write CLUSTER CODE section with dynamic FDT structure

	# Use infrastructure code if available, otherwise default to "CLUSTER CODE"
	folder_name << _if .infrastructure_code _isnt _unset
	               _then >> .infrastructure_code
	               _else >> "CLUSTER CODE"
	               _endif

	p_stream.write("  <Folder>", newline_char)
	p_stream.write("    <name>", folder_name, "</name>", newline_char)

	# Get folder definitions from builder (dynamic based on FDT count)
	folder_defs << .folder_builder.build_cluster_folders(p_fdts)

	# Write each folder
	_for folder_def _over folder_defs.fast_elements()
	_loop
		_self.write_folder(p_stream, folder_def, p_area, 4)
	_endloop

	p_stream.write("  </Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_folder(p_stream, p_folder_def, p_area, p_indent, _optional p_parent_line_id, p_parent_fdt_folder)
	## Write a folder and its contents recursively
	##
	## Parameters:
	##   p_parent_line_id - LINE ID from parent folder (propagated to children, first optional)
	##   p_parent_fdt_folder - FDT folder name from parent (propagated to children, second optional)

	indent << "".fill_up_with(% , p_indent)

	p_stream.write(indent, "<Folder>", newline_char)
	p_stream.write(indent, "  <name>", p_folder_def[:name], "</name>", newline_char)

	# Write visibility if specified
	_if p_folder_def[:visibility] _isnt _unset
	_then
		vis_str << _if p_folder_def[:visibility] _then "1" _else "0" _endif
		p_stream.write(indent, "  <visibility>", vis_str, "</visibility>", newline_char)
	_endif

	# Determine LINE ID for this folder level
	# If this folder defines a line_id, use it; otherwise inherit from parent
	current_line_id << p_folder_def[:line_id].default(p_parent_line_id)

	# Determine FDT folder name for this level
	# Check if this folder is FDT_* folder (cluster structure)
	folder_name << p_folder_def[:name]
	current_fdt_folder << p_parent_fdt_folder
	_if folder_name.index_of_seq("FDT_") _isnt _unset
	_then
		# This is an FDT folder, use its name
		current_fdt_folder << folder_name
	_endif

	# Write subfolders if present
	_if p_folder_def[:subfolders] _isnt _unset
	_then
		_for subfolder _over p_folder_def[:subfolders].fast_elements()
		_loop
			# Pass current_line_id and current_fdt_folder down to children
			_self.write_folder(p_stream, subfolder, p_area, p_indent + 2, current_line_id, current_fdt_folder)
		_endloop
	_endif

	# Write placemarks for this folder based on folder type
	# Pass current_line_id and current_fdt_folder so FAT folders know which FDT and LINE they belong to
	_self.write_folder_contents(p_stream, p_folder_def, p_area, indent + "  ", current_line_id, current_fdt_folder)

	p_stream.write(indent, "</Folder>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_folder_contents(p_stream, p_folder_def, p_area, p_indent, _optional p_parent_line_id, p_parent_fdt_folder)
	## Write placemarks (poles, cables, equipment) for this folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_folder_def - Folder definition property_list
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_parent_line_id - LINE ID inherited from parent folder (first optional)
	##   p_parent_fdt_folder - FDT folder name inherited from parent (second optional)

	folder_name << p_folder_def[:name]
	# Use line_id from folder definition if present, otherwise use parent's line_id
	line_id << p_folder_def[:line_id].default(p_parent_line_id)
	line_type << "LINE " + line_id.default("A")

	# Check if this is a pole folder (EXISTING POLE or NEW POLE)
	_if folder_name.index_of_seq("POLE") _isnt _unset
	_then
		# Query poles in area
		all_poles << .gc[:pole].select(
			predicate.interacts(:location, p_area))

		# Determine filtering criteria from folder name
		is_new_pole? << folder_name.index_of_seq("NEW POLE") _isnt _unset
		is_emr? << folder_name.index_of_seq("EMR") _isnt _unset
		is_partner? << folder_name.index_of_seq("PARTNER") _isnt _unset

		# Extract pole spec if present (e.g., "7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5")
		pole_spec << _unset
		_for spec _over {"7-2.5", "7-3", "7-4", "9-3", "9-4", "9-5"}.fast_elements()
		_loop
			_if folder_name.index_of_seq(spec) _isnt _unset
			_then
				pole_spec << spec
				_leave
			_endif
		_endloop

		# DEBUG: Print folder criteria
		#write("  Processing folder: ", folder_name, " (LINE: ", line_type, ")")
		#write("    NEW? ", is_new_pole?, " EMR? ", is_emr?, " PARTNER? ", is_partner?, " Spec: ", pole_spec)

		# Filter and write poles based on folder criteria
		pole_count << 0
		_for pole _over all_poles.fast_elements()
		_loop
			# Get pole attributes for filtering
			asset_owner << pole.perform(:asset_owner).default("")
			pole_status << pole.perform(:construction_status).default("")
			pole_type << pole.perform(:type).default("")  # e.g., "Pole 7-2.5"
			pole_line_type << pole.perform(:line_type).default("")  # e.g., "A", "B", "C", "D"

			# DEBUG: Print first 3 poles
			_if pole_count < 3
			_then
			#	write("    Checking pole ID:", pole.id, " Type:", pole_type, " Status:", pole_status, " Owner:", asset_owner, " Line:", pole_line_type)
			_endif

			# Check if pole matches folder criteria
			matches? << _true

			# Filter by LINE (A, B, C, D) if we're inside a LINE folder
			#write("    Current LINE TYPE: ", line_type, " Pole LINE Type: ", pole_line_type)
			_if line_type _isnt _unset
			_then
				_if pole_line_type.uppercase <> line_type.uppercase
				_then
					matches? << _false
					# DEBUG: Show why pole was rejected
					_if pole_count < 3
					_then
			#			write("      REJECTED: pole line_type '", pole_line_type, "' does not match folder LINE '", line_id, "'")
					_endif
				_endif
			_endif

			# Filter by NEW vs EXISTING (construction_status)
			_if is_new_pole?
			_then
				# NEW POLE: construction_status should be "Proposed"
				_if pole_status.uppercase <> "PROPOSED"
				_then
					matches? << _false
				_endif
			_else
				# EXISTING POLE: construction_status should be "In Service"
				_if pole_status.uppercase <> "IN SERVICE"
				_then
					matches? << _false
				_endif
			_endif

			# Filter by owner (EMR vs PARTNER)
			_if is_emr?
			_then
				# EMR means asset_owner is "Owned"
				_if asset_owner.default("").uppercase <> "OWNED"
				_then
					matches? << _false
				_endif
			_elif is_partner?
			_then
				# PARTNER means asset_owner is NOT "Owned"
				_if asset_owner.default("").uppercase = "OWNED"
				_then
					matches? << _false
				_endif
			_endif

			# Filter by pole type spec (e.g., "7-2.5" in "Pole 7-2.5")
			_if pole_spec _isnt _unset
			_then
				# Check if pole type contains the spec (e.g., "Pole 7-2.5" contains "7-2.5")
				_if pole_type.index_of_seq(pole_spec) _is _unset
				_then
					matches? << _false
				_endif
			_endif

			# Filter by FDT folder if we're inside an FDT_* folder (cluster structure)
			_if p_parent_fdt_folder _isnt _unset
			_then
				# Get pole ring_name
				pole_ring_name << pole.perform(:ring_name).default("")

				# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
				_if p_parent_fdt_folder.index_of_seq("FDT_") _isnt _unset
				_then
					expected_fdt_name << p_parent_fdt_folder.slice(5, p_parent_fdt_folder.size)

					# Check if ring_name matches FDT name
					_if pole_ring_name.uppercase <> expected_fdt_name.uppercase
					_then
						matches? << _false
					_endif
				_endif
			_endif

			# Write pole if it matches
			_if matches?
			_then
				.object_writer.write_pole(pole, p_stream, p_indent)
				pole_count +<< 1
				.total_pole_count +<< 1  # Increment total counter
			_endif
		_endloop

		# Store statistics for this folder
		_if pole_count > 0
		_then
			.pole_statistics[folder_name] << pole_count
			write("  Wrote ", pole_count, " poles to folder: ", folder_name, " (Total so far: ", .total_pole_count, ")")
		_endif

	_endif

	# Handle FAT folders - export FAT equipment
	_if folder_name.index_of_seq("FAT") _isnt _unset _andif
	    folder_name.index_of_seq("BOUNDARY") _is _unset  # Not BOUNDARY FAT
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "FAT", line_id, p_parent_fdt_folder)
	_endif

	# Handle FDT folders - export FDT equipment
	_if folder_name.index_of_seq("FDT") _isnt _unset
	_then
		# Export FDTs - they can be on poles or standalone (mit_terminal_enclosure)
		_self.write_fdt_equipment(p_stream, p_area, p_indent, p_parent_fdt_folder)
	_endif

	# Handle CLOSURE/JOINT CLOSURE folders - export CLOSURE equipment
	_if folder_name.index_of_seq("JOINT CLOSURE") _isnt	_unset _orif
		folder_name.index_of_seq("CLOSURE") _isnt _unset
	_then
		_self.write_sheath_splices_for_folder(p_stream, p_area, p_indent, "CLOSURE", line_id)
	_endif

	# Handle SLACK HANGER folders - export figure_eight equipment
	_if folder_name.index_of_seq("SLACK HANGER") _isnt _unset
	_then
		_self.write_figure_eight_for_folder(p_stream, p_area, p_indent, line_id, p_parent_fdt_folder)
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_fdt_equipment(p_stream, p_area, p_indent, _optional p_fdt_folder)
	## Write FDT equipment - handles both pole-mounted and standalone FDTs
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_fdt_folder - FDT folder name for filtering (optional)

	fdt_count << 0

	# 1. Export FDTs on poles (sheath_splice with type FDT)
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	_for pole _over all_poles.fast_elements()
	_loop
		pole_geom << pole.location
		_if pole_geom _is _unset _then _continue _endif

		# Get equipment on pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment.empty? _then _continue _endif

		# Get sheath_splice equipment
		pole_splices << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :sheath_splice)))

		_for splice _over pole_splices.fast_elements()
		_loop
			# Check if it's an FDT
			splice_type << splice.sheath_splice_object_type
			_if splice_type _is _unset _then _continue _endif

			_if splice_type.uppercase = "FDT"
			_then
				# Filter by FDT folder if specified
				_if p_fdt_folder _isnt _unset
				_then
					# Get FDT name from equipment
					fdt_name << splice.perform(:name).default("")
					# Extract expected name from folder (e.g., "FDT_FDT001" -> "FDT001")
					_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
					_then
						expected_fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)
						_if fdt_name.uppercase <> expected_fdt_name.uppercase
						_then
							_continue  # Skip if doesn't match this FDT folder
						_endif
					_endif
				_endif

				# Write the FDT
				.object_writer.write_sheath_splice(splice, pole_geom, p_stream, p_indent)
				fdt_count +<< 1
				.total_fdt_count +<< 1
			_endif
		_endloop
	_endloop

	# 2. Export standalone FDTs (mit_terminal_enclosure)
	terminal_enclosures << .gc[:mit_terminal_enclosure].select(
		predicate.within(:location, p_area))

	_for terminal _over terminal_enclosures.fast_elements()
	_loop
		terminal_geom << terminal.location
		_if terminal_geom _is _unset _then _continue _endif

		# Filter by FDT folder if specified
		_if p_fdt_folder _isnt _unset
		_then
			terminal_name << terminal.perform(:name).default("")
			_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
			_then
				expected_fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)
				_if terminal_name.uppercase <> expected_fdt_name.uppercase
				_then
					_continue
				_endif
			_endif
		_endif

		# Write terminal enclosure as FDT
		# Convert terminal to equipment-like format for writer
		.object_writer.write_terminal_enclosure(terminal, terminal_geom, p_stream, p_indent)
		fdt_count +<< 1
		.total_fdt_count +<< 1
	_endloop

	_if fdt_count > 0
	_then
		write("  Wrote ", fdt_count, " FDT equipment")
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_sheath_splices_for_folder(p_stream, p_area, p_indent, p_equipment_type, _optional p_line_id, p_fdt_folder)
	## Write sheath splice equipment to folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_equipment_type - "FAT", "FDT", or "CLOSURE"
	##   p_line_id - LINE ID (A/B/C/D) for filtering, _unset if not in LINE folder (first optional)
	##   p_fdt_folder - FDT folder name (e.g., "FDT_FDT001") for FAT filtering (second optional)

	# Query poles in area to find equipment on them
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	equipment_count << 0

	# DEBUG: Track processing
	poles_checked << 0
	splices_found << 0

	# Iterate through poles and find sheath splices
	_for pole _over all_poles.fast_elements()
	_loop
		poles_checked +<< 1
		pole_geom << pole.location
		_if pole_geom _is _unset _then _continue _endif

		# Get all equipment on this pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment.empty? _then _continue _endif

		# DEBUG: First few poles
		#write("    Pole ", pole.telco_pole_tag, " has ", pole_equipment.size, " equipment items")

		# Get sheath_splice from equipment using predicate
		pole_splices << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :sheath_splice)))

		_if pole_splices.empty? _then _continue _endif

		splices_found +<< pole_splices.size

		# DEBUG
		#write("    Found ", pole_splices.size, " sheath splices on pole ", pole.telco_pole_tag)

		_for splice _over pole_splices.fast_elements()
		_loop
			# Get splice type from equipment object (like in detect_network)
			splice_type << splice.sheath_splice_object_type
			_if splice_type _is _unset
			_then
				write("    WARNING: Could not get sheath_splice_object_type from equipment")
				_continue
			_endif

			# DEBUG
			#_if equipment_count < 3
			#_then
			#	write("    Splice equipment ID:", splice.id, " Type:", splice_type)
			#_endif

			# Filter by equipment type
			matches_type? << _false
			_if p_equipment_type = "FAT" _andif
			    splice_type.index_of_seq("FAT") _isnt _unset
			_then
				matches_type? << _true
			_elif p_equipment_type = "FDT" _andif
			      splice_type.index_of_seq("FDT") _isnt _unset
			_then
				matches_type? << _true
			_elif p_equipment_type = "CLOSURE" _andif
			      (splice_type.index_of_seq("Closure") _isnt _unset _orif
			       splice_type.index_of_seq("Joint") _isnt _unset)
			_then
				matches_type? << _true
			_endif

			_if _not matches_type? _then _continue _endif

			# For FAT in LINE folders, check if pole's line_type matches
			_if p_equipment_type = "FAT" _andif p_line_id _isnt _unset
			_then
				# Convert p_line_id to line_type format (e.g., "A" -> "LINE A")
				expected_line_type << "LINE " + p_line_id
				pole_line_type << pole.perform(:line_type).default("")

				# DEBUG
				#_if equipment_count < 3
				#_then
				#	write("      Checking LINE: pole line_type='", pole_line_type, "' expected='", expected_line_type, "'")
				#_endif

				_if pole_line_type.uppercase <> expected_line_type.uppercase
				_then
					_continue  # Skip FAT if pole doesn't match LINE
				_endif

				# Also check FAT ring_name matches FDT folder
				_if p_fdt_folder _isnt _unset
				_then
					# Get FAT ring_name
					fat_ring_name << splice.perform(:ring_name).default("")

					# FDT folder format is "FDT_<name>", extract the name part
					# Expected ring_name should match the FDT name
					_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
					_then
						# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
						fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)

						# DEBUG
						#_if equipment_count < 3
						#_then
						#	write("      Checking FDT: FAT ring_name='", fat_ring_name, "' expected FDT='", fdt_name, "'")
						#_endif

						# Check if ring_name matches FDT name
						_if fat_ring_name.uppercase <> fdt_name.uppercase
						_then
							_continue  # Skip FAT if it doesn't belong to this FDT
						_endif
					_endif
				_endif
			_endif

			# Write the sheath splice (pass equipment object)
			.object_writer.write_sheath_splice(splice, pole_geom, p_stream, p_indent)
			equipment_count +<< 1

			# Increment global counters
			_if p_equipment_type = "FAT"
			_then
				.total_fat_count +<< 1
			_elif p_equipment_type = "FDT"
			_then
				.total_fdt_count +<< 1
			_elif p_equipment_type = "CLOSURE"
			_then
				.total_closure_count +<< 1
			_endif
		_endloop
	_endloop

	write("  ", p_equipment_type, " summary: Checked ", poles_checked, " poles, found ", splices_found, " total splices, wrote ", equipment_count, " matching ", p_equipment_type)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.write_figure_eight_for_folder(p_stream, p_area, p_indent, _optional p_line_id, p_fdt_folder)
	## Write figure_eight (SLACK HANGER) equipment to folder
	##
	## Parameters:
	##   p_stream - Output stream
	##   p_area - Design boundary area
	##   p_indent - Indentation string
	##   p_line_id - LINE ID (A/B/C/D) for filtering, _unset if not in LINE folder (first optional)
	##   p_fdt_folder - FDT folder name (e.g., "FDT_FDT001") for filtering (second optional)

	# Query poles in area to find figure_eight equipment on them
	all_poles << .gc[:pole].select(
		predicate.interacts(:location, p_area))

	equipment_count << 0

	# Iterate through poles and find figure_eight equipment
	_for pole _over all_poles.fast_elements()
	_loop
		pole_geom << pole.location
		_if pole_geom _is _unset _then _continue _endif

		# Get all equipment on this pole
		pole_equipment << pole.get_equipment()
		_if pole_equipment.empty? _then _continue _endif

		# Get figure_eight from equipment using predicate
		pole_figure_eights << pole_equipment.select(
			predicate.navigate({:source_collection},
				predicate.eq(:name, :figure_eight)))

		_if pole_figure_eights.empty? _then _continue _endif

		_for fig8 _over pole_figure_eights.fast_elements()
		_loop
			# Filter by LINE if we're in a LINE folder
			_if p_line_id _isnt _unset
			_then
				# Convert p_line_id to line_type format (e.g., "A" -> "LINE A")
				expected_line_type << "LINE " + p_line_id
				pole_line_type << pole.perform(:line_type).default("")

				_if pole_line_type.uppercase <> expected_line_type.uppercase
				_then
					_continue  # Skip figure_eight if pole doesn't match LINE
				_endif
			_endif

			# Filter by FDT folder if we're inside an FDT folder (cluster structure)
			_if p_fdt_folder _isnt _unset
			_then
				# Get figure_eight ring_name or pole ring_name
				fig8_ring_name << fig8.perform(:ring_name).default("")
				_if fig8_ring_name = ""
				_then
					# Fall back to pole's ring_name
					fig8_ring_name << pole.perform(:ring_name).default("")
				_endif

				# FDT folder format is "FDT_<name>", extract the name part
				_if p_fdt_folder.index_of_seq("FDT_") _isnt _unset
				_then
					# Extract FDT name from folder (e.g., "FDT_FDT001" -> "FDT001")
					fdt_name << p_fdt_folder.slice(5, p_fdt_folder.size)

					# Check if ring_name matches FDT name
					_if fig8_ring_name.uppercase <> fdt_name.uppercase
					_then
						_continue  # Skip figure_eight if it doesn't belong to this FDT
					_endif
				_endif
			_endif

			# Write the figure_eight using pole coordinates
			.object_writer.write_figure_eight(fig8, pole_geom, p_stream, p_indent)
			equipment_count +<< 1
			.total_slack_hanger_count +<< 1
		_endloop
	_endloop

	_if equipment_count > 0
	_then
		write("  Wrote ", equipment_count, " SLACK HANGER equipment")
	_endif
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_export_to_aerial_kmz.create_kmz_from_kml(p_kml_file)
	## Create KMZ file (zipped KML)

	kmz_file << p_kml_file.substitute_string(".kml", ".kmz")

	# Use system zip command (Windows compatible)
	_if system.getenv("OS").default("").matches?("Windows")
	_then
		# Windows: use PowerShell Compress-Archive
		# PowerShell handles paths with spaces correctly
		zip_cmd << write_string("powershell -Command ",
			%", "Compress-Archive -Force -Path '", p_kml_file, "' -DestinationPath '", kmz_file, "'", %")

		system.do_command(zip_cmd)
	_else
		# Unix/Linux: use zip command
		# Get directory and basename for zip command
		last_slash << p_kml_file.rindex_of(%\)
		_if last_slash _is _unset
		_then
			last_slash << p_kml_file.rindex_of(%/)
		_endif

		_if last_slash _isnt _unset
		_then
			kml_dir << p_kml_file.slice(1, last_slash - 1)
			kml_basename << p_kml_file.slice_to_end(last_slash + 1)
		_else
			kml_dir << "."
			kml_basename << p_kml_file
		_endif

		kmz_basename << kml_basename.substitute_string(".kml", ".kmz")

		zip_cmd << write_string("cd ", %", kml_dir, %", " && zip -q ", %", kmz_basename, %", " ", %", kml_basename, %")
		system.do_command(zip_cmd)
	_endif

	# Delete temporary KML file
	system.unlink(p_kml_file)

	>> kmz_file
_endmethod
$
