#% text_encoding = iso8859_1
_package user
$

## AERIAL KMZ OBJECT WRITER
## Writes individual objects as KML placemarks

remex(:rwi_aerial_kmz_object_writer)
$

_pragma(classify_level=basic, topic={rwi_export})
def_slotted_exemplar(:rwi_aerial_kmz_object_writer,
{
}, :object)
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.new()
	## Create new object writer
	>> _clone
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.convert_coord_to_wgs84_string(p_coord)
	## Convert coordinate from current coordinate system to WGS84 and format as string
	## Returns: String in format "lon,lat,0" for KML

	# Get database and view
	v << gis_program_manager.databases[:gis]
	a_view << gis_program_manager.ace_view

	# Set up dynamics for coordinate system
	_dynamic !current_world! << v.collections[:sw_gis!world].at(0,0)
	_dynamic !current_coordinate_system! << v.collections[:sw_gis!world].at(0,0).coordinate_system

	# Get current coordinate system and WGS84 coordinate system
	cs1 << v.world.coordinate_system
	cs2 << a_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)

	# Create transform
	t << transform.new_converting_cs_to_cs(cs1, cs2)

	# Convert coordinate
	t_coord << t.convert(p_coord)

	# Format as string with precision
	_dynamic !print_float_precision! << 16
	l_str << write_string(t_coord.x, ",", t_coord.y, ",0")

	>> l_str
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_pole(p_pole, p_stream, p_indent)
	## Write pole placemark with coordinates and styling
	##
	## Parameters:
	##   p_pole - Pole object
	##   p_stream - Output stream
	##   p_indent - Indentation string

	# Get pole geometry (location point)
	pole_geom << p_pole.location
	_if pole_geom _is _unset _then _return _endif

	# Get coordinate
	coord << pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84 (Google Earth coordinate system)
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get pole attributes
	pole_id << p_pole.perform(:id).default("Unknown")
	telco_pole_tag << p_pole.perform(:telco_pole_tag).default("")
	asset_owner << p_pole.perform(:asset_owner).default("")
	# SKIP: pole_height and pole_class not needed
	#pole_height << p_pole.perform(:height).default("")
	#pole_class << p_pole.perform(:class_value).default("")

	# Determine owner and style based on asset_owner
	# If asset_owner is "Owned" then EMR, otherwise PARTNER
	_if asset_owner.default("").uppercase = "OWNED"
	_then
		pole_owner << "EMR"
		style_url << "#pole_emr_map"
	_else
		pole_owner << "PARTNER"
		style_url << "#pole_partner_map"
	_endif

	# Build pole name/label using telco_pole_tag if available, otherwise pole ID
	_if telco_pole_tag <> ""
	_then
		pole_name << telco_pole_tag
	_else
		pole_name << write_string("Pole ", pole_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", pole_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with pole attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", pole_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Owner'>", newline_char)
	p_stream.write(p_indent, "      <value>", pole_owner, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	# SKIP: pole_height and pole_class not needed in export
	#_if pole_height _isnt ""
	#_then
	#	p_stream.write(p_indent, "    <Data name='Height'>", newline_char)
	#	p_stream.write(p_indent, "      <value>", pole_height, "</value>", newline_char)
	#	p_stream.write(p_indent, "    </Data>", newline_char)
	#_endif
	#_if pole_class _isnt ""
	#_then
	#	p_stream.write(p_indent, "    <Data name='Class'>", newline_char)
	#	p_stream.write(p_indent, "      <value>", pole_class, "</value>", newline_char)
	#	p_stream.write(p_indent, "    </Data>", newline_char)
	#_endif
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_terminal_enclosure(p_terminal, p_terminal_geom, p_stream, p_indent)
	## Write terminal enclosure (FDT) placemark
	##
	## Parameters:
	##   p_terminal - Terminal enclosure object (mit_terminal_enclosure)
	##   p_terminal_geom - Terminal geometry
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_terminal_geom _is _unset _then _return _endif

	# Get coordinate from terminal geometry
	coord << p_terminal_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get terminal attributes
	terminal_id << p_terminal.perform(:id).default("Unknown")
	terminal_name << p_terminal.perform(:name).default("")

	# Build equipment name
	_if terminal_name <> ""
	_then
		equipment_name << terminal_name
	_else
		equipment_name << write_string("FDT ", terminal_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#fdt_map</styleUrl>", newline_char)

	# Write ExtendedData
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", terminal_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>FDT</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_cable(p_cable, p_stream, p_indent)
	## Write cable placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_sheath_splice(p_splice_equipment, p_pole_geom, p_stream, p_indent)
	## Write sheath splice placemark (FAT/FDT/CLOSURE)
	##
	## Parameters:
	##   p_splice_equipment - Equipment object containing sheath splice
	##   p_pole_geom - Pole geometry to use as coordinate
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_pole_geom _is _unset _then _return _endif

	# Get coordinate from pole geometry
	coord << p_pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get splice type from equipment
	splice_type << p_splice_equipment.sheath_splice_object_type
	_if splice_type _is _unset _then _return _endif

	# Get splice attributes (p_splice_equipment IS the sheath_splice)
	splice_id << p_splice_equipment.perform(:id).default("Unknown")
	splice_name << p_splice_equipment.perform(:name).default("")

	# Determine equipment type (FAT, FDT, or CLOSURE)
	equip_type << _unset
	_if splice_type.index_of_seq("FAT") _isnt _unset
	_then
		equip_type << "FAT"
		style_url << "#fat_map"
	_elif splice_type.index_of_seq("FDT") _isnt _unset
	_then
		equip_type << "FDT"
		style_url << "#fdt_map"
	_elif splice_type.index_of_seq("Closure") _isnt _unset _orif
	      splice_type.index_of_seq("Joint") _isnt _unset
	_then
		equip_type << "CLOSURE"
		style_url << "#closure_map"
	_else
		# Unknown type, skip
		_return
	_endif

	# Build equipment name using name if available, otherwise type + ID
	_if splice_name <> ""
	_then
		equipment_name << splice_name
	_else
		equipment_name << write_string(equip_type, " ", splice_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with splice attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", splice_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>", splice_type, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_figure_eight(p_figure_eight, p_pole_geom, p_stream, p_indent)
	## Write figure_eight (SLACK HANGER) placemark with coordinates and styling
	##
	## Parameters:
	##   p_figure_eight - Figure eight object
	##   p_pole_geom - Pole geometry to use as coordinate
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_pole_geom _is _unset _then _return _endif

	# Get coordinate from pole geometry
	coord << p_pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get figure_eight attributes
	fig8_id << p_figure_eight.perform(:id).default("Unknown")
	fig8_name << p_figure_eight.perform(:name).default("")

	# Build equipment name
	_if fig8_name <> ""
	_then
		equipment_name << fig8_name
	_else
		equipment_name << write_string("SLACK HANGER ", fig8_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#slack_hanger_map</styleUrl>", newline_char)

	# Write ExtendedData with figure_eight attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", fig8_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>SLACK HANGER</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_hp_point(p_hp, p_stream, p_indent)
	## Write homepass point placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_boundary(p_boundary, p_stream, p_indent)
	## Write polygon boundary placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$
