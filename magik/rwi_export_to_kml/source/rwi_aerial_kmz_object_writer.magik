#% text_encoding = iso8859_1
_package user
$

## AERIAL KMZ OBJECT WRITER
## Writes individual objects as KML placemarks

remex(:rwi_aerial_kmz_object_writer)
$

_pragma(classify_level=basic, topic={rwi_export})
def_slotted_exemplar(:rwi_aerial_kmz_object_writer,
{
}, :object)
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.new()
	## Create new object writer
	>> _clone
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.convert_coord_to_wgs84_string(p_coord)
	## Convert coordinate from current coordinate system to WGS84 and format as string
	## Returns: String in format "lon,lat,0" for KML

	# Get database and view
	v << gis_program_manager.databases[:gis]
	a_view << gis_program_manager.ace_view

	# Set up dynamics for coordinate system
	_dynamic !current_world! << v.collections[:sw_gis!world].at(0,0)
	_dynamic !current_coordinate_system! << v.collections[:sw_gis!world].at(0,0).coordinate_system

	# Get current coordinate system and WGS84 coordinate system
	cs1 << v.world.coordinate_system
	cs2 << a_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)

	# Create transform
	t << transform.new_converting_cs_to_cs(cs1, cs2)

	# Convert coordinate
	t_coord << t.convert(p_coord)

	# Format as string with precision
	_dynamic !print_float_precision! << 16
	l_str << write_string(t_coord.x, ",", t_coord.y, ",0")

	>> l_str
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_pole(p_pole, p_stream, p_indent, _optional p_folder_name)
	## Write pole placemark with coordinates and styling
	##
	## Parameters:
	##   p_pole - Pole object
	##   p_stream - Output stream
	##   p_indent - Indentation string
	##   p_folder_name - Optional folder name for style determination

	# Get pole geometry (location point)
	pole_geom << p_pole.location
	_if pole_geom _is _unset _then _return _endif

	# Get coordinate
	coord << pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84 (Google Earth coordinate system)
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get pole attributes
	pole_id << p_pole.perform(:id).default("Unknown")
	telco_pole_tag << p_pole.perform(:telco_pole_tag).default("")
	asset_owner << p_pole.perform(:asset_owner).default("")
	# SKIP: pole_height and pole_class not needed
	#pole_height << p_pole.perform(:height).default("")
	#pole_class << p_pole.perform(:class_value).default("")

	# Determine style based on folder name using new aerial_styles.kml
	_if p_folder_name _isnt _unset
	_then
		style_url << _self.get_pole_style_from_folder(p_folder_name)
	_else
		# Fallback to old logic if no folder name provided
		_if asset_owner.default("").uppercase = "OWNED"
		_then
			style_url << "#existing_pole_emr_map"
		_else
			style_url << "#existing_pole_partner_map"
		_endif
	_endif

	# Determine owner for ExtendedData
	_if asset_owner.default("").uppercase = "OWNED"
	_then
		pole_owner << "EMR"
	_else
		pole_owner << "PARTNER"
	_endif

	# Build pole name/label using telco_pole_tag if available, otherwise pole ID
	_if telco_pole_tag <> ""
	_then
		pole_name << telco_pole_tag
	_else
		pole_name << write_string("Pole ", pole_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", pole_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with pole attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", pole_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Owner'>", newline_char)
	p_stream.write(p_indent, "      <value>", pole_owner, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	# SKIP: pole_height and pole_class not needed in export
	#_if pole_height _isnt ""
	#_then
	#	p_stream.write(p_indent, "    <Data name='Height'>", newline_char)
	#	p_stream.write(p_indent, "      <value>", pole_height, "</value>", newline_char)
	#	p_stream.write(p_indent, "    </Data>", newline_char)
	#_endif
	#_if pole_class _isnt ""
	#_then
	#	p_stream.write(p_indent, "    <Data name='Class'>", newline_char)
	#	p_stream.write(p_indent, "      <value>", pole_class, "</value>", newline_char)
	#	p_stream.write(p_indent, "    </Data>", newline_char)
	#_endif
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.get_pole_style_from_folder(p_folder_name)
	## Determine pole style based on folder name
	## Maps folder names to style IDs from aerial_styles.kml
	##
	## Parameters:
	##   p_folder_name - Folder name (e.g., "NEW POLE 7-3", "EXISTING POLE EMR 7-4")
	##
	## Returns:
	##   Style URL string (e.g., "#new_pole_7_3_map")

	folder_upper << p_folder_name.uppercase

	# NEW POLE folders - map to specific size styles
	_if folder_upper.index_of_seq("NEW POLE") _isnt _unset
	_then
		_if folder_upper.index_of_seq("7-2.5") _isnt _unset _orif
		    folder_upper.index_of_seq("7-2,5") _isnt _unset
		_then
			_return "#new_pole_7_2_5_map"
		_elif folder_upper.index_of_seq("7-3") _isnt _unset
		_then
			_return "#new_pole_7_3_map"
		_elif folder_upper.index_of_seq("7-4") _isnt _unset
		_then
			_return "#new_pole_7_4_map"
		_elif folder_upper.index_of_seq("9-3") _isnt _unset
		_then
			_return "#new_pole_9_3_map"
		_elif folder_upper.index_of_seq("9-4") _isnt _unset
		_then
			_return "#new_pole_9_4_map"
		_elif folder_upper.index_of_seq("9-5") _isnt _unset
		_then
			_return "#new_pole_9_5_map"
		_else
			# Default to 7-3 for NEW POLE if size not specified
			_return "#new_pole_7_3_map"
		_endif
	_endif

	# EXISTING POLE folders - map based on owner
	_if folder_upper.index_of_seq("EXISTING POLE") _isnt _unset
	_then
		_if folder_upper.index_of_seq("EMR") _isnt _unset
		_then
			_return "#existing_pole_emr_map"
		_elif folder_upper.index_of_seq("PARTNER") _isnt _unset
		_then
			_return "#existing_pole_partner_map"
		_elif folder_upper.index_of_seq("TELKOM") _isnt _unset
		_then
			_return "#existing_pole_telkom_map"
		_else
			# Default to EMR for EXISTING POLE if owner not specified
			_return "#existing_pole_emr_map"
		_endif
	_endif

	# Default fallback - existing pole EMR
	_return "#existing_pole_emr_map"
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_terminal_enclosure(p_terminal, p_terminal_geom, p_stream, p_indent)
	## Write terminal enclosure (FDT) placemark
	##
	## Parameters:
	##   p_terminal - Terminal enclosure object (mit_terminal_enclosure)
	##   p_terminal_geom - Terminal geometry
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_terminal_geom _is _unset _then _return _endif

	# Get coordinate from terminal geometry
	coord << p_terminal_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get terminal attributes
	terminal_id << p_terminal.perform(:id).default("Unknown")
	terminal_name << p_terminal.perform(:name).default("")

	# Build equipment name
	_if terminal_name <> ""
	_then
		equipment_name << terminal_name
	_else
		equipment_name << write_string("FDT ", terminal_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#fdt_map</styleUrl>", newline_char)

	# Write ExtendedData
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", terminal_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>FDT</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_cable(p_cable, p_stream, p_indent)
	## Write cable placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_sheath_splice(p_splice_equipment, p_pole_geom, p_stream, p_indent)
	## Write sheath splice placemark (FAT/FDT/CLOSURE)
	##
	## Parameters:
	##   p_splice_equipment - Equipment object containing sheath splice
	##   p_pole_geom - Pole geometry to use as coordinate
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_pole_geom _is _unset _then _return _endif

	# Get coordinate from pole geometry
	coord << p_pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get splice type from equipment
	splice_type << p_splice_equipment.sheath_splice_object_type
	_if splice_type _is _unset _then _return _endif

	# Get splice attributes (p_splice_equipment IS the sheath_splice)
	splice_id << p_splice_equipment.perform(:id).default("Unknown")
	splice_name << p_splice_equipment.perform(:name).default("")

	# Determine equipment type (FAT, FDT, or CLOSURE)
	equip_type << _unset
	_if splice_type.index_of_seq("FAT") _isnt _unset
	_then
		equip_type << "FAT"
		style_url << "#fat_map"
	_elif splice_type.index_of_seq("FDT") _isnt _unset
	_then
		equip_type << "FDT"
		style_url << "#fdt_map"
	_elif splice_type.index_of_seq("Closure") _isnt _unset _orif
	      splice_type.index_of_seq("Joint") _isnt _unset
	_then
		equip_type << "CLOSURE"
		style_url << "#closure_map"
	_else
		# Unknown type, skip
		_return
	_endif

	# Build equipment name using name if available, otherwise type + ID
	_if splice_name <> ""
	_then
		equipment_name << splice_name
	_else
		equipment_name << write_string(equip_type, " ", splice_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with splice attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", splice_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>", splice_type, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_figure_eight(p_figure_eight, p_pole_geom, p_stream, p_indent)
	## Write figure_eight (SLACK HANGER) placemark with coordinates and styling
	##
	## Parameters:
	##   p_figure_eight - Figure eight object
	##   p_pole_geom - Pole geometry to use as coordinate
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_pole_geom _is _unset _then _return _endif

	# Get coordinate from pole geometry
	coord << p_pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get figure_eight attributes
	fig8_id << p_figure_eight.perform(:id).default("Unknown")
	fig8_name << p_figure_eight.perform(:name).default("")

	# Build equipment name
	_if fig8_name <> ""
	_then
		equipment_name << fig8_name
	_else
		equipment_name << write_string("SLACK HANGER ", fig8_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#slack_hanger_map</styleUrl>", newline_char)

	# Write ExtendedData with figure_eight attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", fig8_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>SLACK HANGER</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_sling_wire(p_sling_wire, p_route_geom, p_stream, p_indent)
	## Write sling_wire chain as LineString with coordinates and styling
	##
	## Parameters:
	##   p_sling_wire - Sling wire object
	##   p_route_geom - Route geometry (chain)
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_route_geom _is _unset _then _return _endif

	# Get database and view for coordinate conversion
	v << gis_program_manager.databases[:gis]
	a_view << gis_program_manager.ace_view

	# Set up dynamics for coordinate system
	_dynamic !current_world! << v.collections[:sw_gis!world].at(0,0)
	_dynamic !current_coordinate_system! << v.collections[:sw_gis!world].at(0,0).coordinate_system

	# Get current coordinate system and WGS84 coordinate system
	cs1 << v.world.coordinate_system
	cs2 << a_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)

	# Create transform
	t << transform.new_converting_cs_to_cs(cs1, cs2)

	# Convert route sectors to coordinate string
	_dynamic !print_float_precision! << 16
	coord_string << ""

	# Get route sectors and convert each coordinate
	route_sectors << p_route_geom.sectors
	_for sector _over route_sectors.fast_elements()
	_loop
		_for coord _over sector.coords.fast_elements()
		_loop
			# Convert coordinate to WGS84
			t_coord << t.convert(coord)
			# Format as "lon,lat,0 "
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endloop
	_endloop

	# Get sling_wire attributes
	sling_id << p_sling_wire.perform(:id).default("Unknown")
	sling_name << p_sling_wire.perform(:name).default("")

	# Build chain name
	_if sling_name <> ""
	_then
		chain_name << sling_name
	_else
		chain_name << write_string("SLING WIRE ", sling_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", chain_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#sling_wire_map</styleUrl>", newline_char)

	# Write ExtendedData with sling_wire attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", sling_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>SLING WIRE</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write LineString geometry
	p_stream.write(p_indent, "  <LineString>", newline_char)
	p_stream.write(p_indent, "    <tessellate>1</tessellate>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </LineString>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_cable(p_cable, p_route_sectors, p_stream, p_indent)
	## Write cable/sheath_with_loc chain as LineString with coordinates and styling
	##
	## Parameters:
	##   p_cable - Cable (sheath_with_loc) object
	##   p_route_sectors - Route sectors from cable.route_sectors()
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_route_sectors _is _unset _then _return _endif

	# Get database and view for coordinate conversion
	v << gis_program_manager.databases[:gis]
	a_view << gis_program_manager.ace_view

	# Set up dynamics for coordinate system
	_dynamic !current_world! << v.collections[:sw_gis!world].at(0,0)
	_dynamic !current_coordinate_system! << v.collections[:sw_gis!world].at(0,0).coordinate_system

	# Get current coordinate system and WGS84 coordinate system
	cs1 << v.world.coordinate_system
	cs2 << a_view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)

	# Create transform
	t << transform.new_converting_cs_to_cs(cs1, cs2)

	# Convert route sectors to coordinate string
	_dynamic !print_float_precision! << 16
	coord_string << ""

	# p_route_sectors is already the sectors collection from route_sectors()
	# Iterate through sectors and coordinates (like write_line in rwi_export_to_kml)
	_for sector _over p_route_sectors.fast_elements()
	_loop
		_for coord _over sector.fast_elements()
		_loop
			# Convert coordinate to WGS84
			t_coord << t.convert(coord)
			# Format as "lon,lat,0 "
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endloop
	_endloop

	# Get cable attributes
	cable_id << p_cable.perform(:id).default("Unknown")
	cable_name << p_cable.perform(:name).default("")

	# Build chain name
	_if cable_name <> ""
	_then
		chain_name << cable_name
	_else
		chain_name << write_string("CABLE ", cable_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", chain_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#cable_map</styleUrl>", newline_char)

	# Write ExtendedData with cable attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", cable_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>CABLE</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write LineString geometry
	p_stream.write(p_indent, "  <LineString>", newline_char)
	p_stream.write(p_indent, "    <tessellate>1</tessellate>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </LineString>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_hp_point(p_hp, p_stream, p_indent)
	## Write homepass point placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_boundary(p_boundary, p_stream, p_indent)
	## Write polygon boundary placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$
