#% text_encoding = iso8859_1
_package user
$

## AERIAL KMZ OBJECT WRITER
## Writes individual objects as KML placemarks

remex(:rwi_aerial_kmz_object_writer)
$

_pragma(classify_level=basic, topic={rwi_export})
def_slotted_exemplar(:rwi_aerial_kmz_object_writer,
{
	{:database, _unset, :writable},           # GIS database
	{:view, _unset, :writable},               # ACE view
	{:cs_transform, _unset, :writable}        # Coordinate system transform (local to WGS84)
}, :object)
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.new()
	## Create new object writer and initialize coordinate system
	>> _clone.init()
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_private _method rwi_aerial_kmz_object_writer.init()
	## Initialize database, view, and coordinate transform

	# Get database and view
	.database << gis_program_manager.databases[:gis]
	.view << gis_program_manager.ace_view

	# Set up coordinate system transform (local to WGS84)
	_if .database _isnt _unset _andif .view _isnt _unset
	_then
		# Set up dynamics for coordinate system
		_dynamic !current_world! << .database.collections[:sw_gis!world].at(0,0)
		_dynamic !current_coordinate_system! << .database.collections[:sw_gis!world].at(0,0).coordinate_system

		# Get current coordinate system and WGS84 coordinate system
		cs1 << .database.world.coordinate_system
		cs2 << .view.collections[:sw_gis!coordinate_system].at(:world_longlat_wgs84_degree)

		# Create transform
		.cs_transform << transform.new_converting_cs_to_cs(cs1, cs2)
	_endif

	>> _self
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.convert_coord_to_wgs84_string(p_coord)
	## Convert coordinate from current coordinate system to WGS84 and format as string
	## Returns: String in format "lon,lat,0" for KML

	# Use stored coordinate transform
	_if .cs_transform _is _unset
	_then
		# Fallback: return empty string if transform not initialized
		>> ""
	_endif

	# Convert coordinate
	t_coord << .cs_transform.convert(p_coord)

	# Format as string with precision
	_dynamic !print_float_precision! << 16
	l_str << write_string(t_coord.x, ",", t_coord.y, ",0")

	>> l_str
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_pole(p_pole, p_stream, p_indent, _optional p_folder_name)
	## Write pole placemark with coordinates and styling
	##
	## Parameters:
	##   p_pole - Pole object
	##   p_stream - Output stream
	##   p_indent - Indentation string
	##   p_folder_name - Optional folder name for style determination

	# Get pole geometry (location point)
	pole_geom << p_pole.location
	_if pole_geom _is _unset _then _return _endif

	# Get coordinate
	coord << pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84 (Google Earth coordinate system)
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get pole attributes
	pole_id << p_pole.perform(:id).default("Unknown")
	telco_pole_tag << p_pole.perform(:telco_pole_tag).default("")
	asset_owner << p_pole.perform(:asset_owner).default("")
	# SKIP: pole_height and pole_class not needed
	#pole_height << p_pole.perform(:height).default("")
	#pole_class << p_pole.perform(:class_value).default("")

	# Determine style based on folder name using new aerial_styles.kml
	_if p_folder_name _isnt _unset
	_then
		style_url << _self.get_pole_style_from_folder(p_folder_name)
	_else
		# Fallback to old logic if no folder name provided
		_if asset_owner.default("").uppercase = "OWNED"
		_then
			style_url << "#existing_pole_emr_map"
		_else
			style_url << "#existing_pole_partner_map"
		_endif
	_endif

	# Determine owner for ExtendedData
	_if asset_owner.default("").uppercase = "OWNED"
	_then
		pole_owner << "EMR"
	_else
		pole_owner << "PARTNER"
	_endif

	# Build pole name/label using telco_pole_tag if available, otherwise pole ID
	_if telco_pole_tag <> ""
	_then
		pole_name << telco_pole_tag
	_else
		pole_name << write_string("Pole ", pole_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", pole_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with pole attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", pole_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Owner'>", newline_char)
	p_stream.write(p_indent, "      <value>", pole_owner, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.get_pole_style_from_folder(p_folder_name)
	## Determine pole style based on folder name
	## Maps folder names to style IDs from aerial_styles.kml
	##
	## Parameters:
	##   p_folder_name - Folder name (e.g., "NEW POLE 7-3", "EXISTING POLE EMR 7-4")
	##
	## Returns:
	##   Style URL string (e.g., "#new_pole_7_3_map")

	folder_upper << p_folder_name.uppercase

	# NEW POLE folders - map to specific size styles
	_if folder_upper.index_of_seq("NEW POLE") _isnt _unset
	_then
		_if folder_upper.index_of_seq("7-2.5") _isnt _unset _orif
		    folder_upper.index_of_seq("7-2,5") _isnt _unset
		_then
			_return "#new_pole_7_2_5_map"
		_elif folder_upper.index_of_seq("7-3") _isnt _unset
		_then
			_return "#new_pole_7_3_map"
		_elif folder_upper.index_of_seq("7-4") _isnt _unset
		_then
			_return "#new_pole_7_4_map"
		_elif folder_upper.index_of_seq("9-3") _isnt _unset
		_then
			_return "#new_pole_9_3_map"
		_elif folder_upper.index_of_seq("9-4") _isnt _unset
		_then
			_return "#new_pole_9_4_map"
		_elif folder_upper.index_of_seq("9-5") _isnt _unset
		_then
			_return "#new_pole_9_5_map"
		_else
			# Default to 7-3 for NEW POLE if size not specified
			_return "#new_pole_7_3_map"
		_endif
	_endif

	# EXISTING POLE folders - map based on owner
	_if folder_upper.index_of_seq("EXISTING POLE") _isnt _unset
	_then
		_if folder_upper.index_of_seq("EMR") _isnt _unset
		_then
			_return "#existing_pole_emr_map"
		_elif folder_upper.index_of_seq("PARTNER") _isnt _unset
		_then
			_return "#existing_pole_partner_map"
		_elif folder_upper.index_of_seq("TELKOM") _isnt _unset
		_then
			_return "#existing_pole_telkom_map"
		_else
			# Default to EMR for EXISTING POLE if owner not specified
			_return "#existing_pole_emr_map"
		_endif
	_endif

	# Default fallback - existing pole EMR
	_return "#existing_pole_emr_map"
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_terminal_enclosure(p_terminal, p_terminal_geom, p_stream, p_indent)
	## Write terminal enclosure (FDT) placemark
	##
	## Parameters:
	##   p_terminal - Terminal enclosure object (mit_terminal_enclosure)
	##   p_terminal_geom - Terminal geometry
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_terminal_geom _is _unset _then _return _endif

	# Get coordinate from terminal geometry
	coord << p_terminal_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get terminal attributes
	terminal_id << p_terminal.perform(:id).default("Unknown")
	terminal_name << p_terminal.perform(:name).default("")

	# Build equipment name
	_if terminal_name <> ""
	_then
		equipment_name << terminal_name
	_else
		equipment_name << write_string("FDT ", terminal_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#fdt_map</styleUrl>", newline_char)

	# Write ExtendedData
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", terminal_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>FDT</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_cable(p_cable, p_stream, p_indent)
	## Write cable placemark
	## TODO: Implement in Phase 3

	# Placeholder
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_sheath_splice(p_splice_equipment, p_pole_geom, p_stream, p_indent)
	## Write sheath splice placemark (FAT/FDT/CLOSURE)
	##
	## Parameters:
	##   p_splice_equipment - Equipment object containing sheath splice
	##   p_pole_geom - Pole geometry to use as coordinate
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_pole_geom _is _unset _then _return _endif

	# Get coordinate from pole geometry
	coord << p_pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get splice type from equipment
	splice_type << p_splice_equipment.sheath_splice_object_type
	_if splice_type _is _unset _then _return _endif

	# Get splice attributes (p_splice_equipment IS the sheath_splice)
	splice_id << p_splice_equipment.perform(:id).default("Unknown")
	splice_name << p_splice_equipment.perform(:name).default("")

	# Determine equipment type (FAT, FDT, or CLOSURE)
	equip_type << _unset
	_if splice_type.index_of_seq("FAT") _isnt _unset
	_then
		equip_type << "FAT"
		style_url << "#fat_map"
	_elif splice_type.index_of_seq("FDT") _isnt _unset
	_then
		equip_type << "FDT"
		style_url << "#fdt_map"
	_elif splice_type.index_of_seq("Closure") _isnt _unset _orif
	      splice_type.index_of_seq("Joint") _isnt _unset
	_then
		equip_type << "CLOSURE"
		style_url << "#closure_map"
	_else
		# Unknown type, skip
		_return
	_endif

	# Build equipment name using name if available, otherwise type + ID
	_if splice_name <> ""
	_then
		equipment_name << splice_name
	_else
		equipment_name << write_string(equip_type, " ", splice_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with splice attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", splice_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>", splice_type, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_figure_eight(p_figure_eight, p_pole_geom, p_stream, p_indent)
	## Write figure_eight (SLACK HANGER) placemark with coordinates and styling
	##
	## Parameters:
	##   p_figure_eight - Figure eight object
	##   p_pole_geom - Pole geometry to use as coordinate
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_pole_geom _is _unset _then _return _endif

	# Get coordinate from pole geometry
	coord << p_pole_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get figure_eight attributes
	fig8_id << p_figure_eight.perform(:id).default("Unknown")
	fig8_name << p_figure_eight.perform(:name).default("")

	# Build equipment name
	_if fig8_name <> ""
	_then
		equipment_name << fig8_name
	_else
		equipment_name << write_string("SLACK HANGER ", fig8_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", equipment_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#slack_hanger_map</styleUrl>", newline_char)

	# Write ExtendedData with figure_eight attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", fig8_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>SLACK HANGER</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_sling_wire(p_sling_wire, p_route_geom, p_stream, p_indent)
	## Write sling_wire chain as LineString with coordinates and styling
	##
	## Parameters:
	##   p_sling_wire - Sling wire object
	##   p_route_geom - Route geometry (chain)
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_route_geom _is _unset _then _return _endif
	_if .cs_transform _is _unset _then _return _endif

	# Convert route sectors to coordinate string
	_dynamic !print_float_precision! << 16
	coord_string << ""

	# Get route sectors and convert each coordinate
	route_sectors << p_route_geom.sectors
	_for sector _over route_sectors.fast_elements()
	_loop
		_for coord _over sector.coords.fast_elements()
		_loop
			# Convert coordinate to WGS84
			t_coord << .cs_transform.convert(coord)
			# Format as "lon,lat,0 "
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endloop
	_endloop

	# Get sling_wire attributes
	sling_id << p_sling_wire.perform(:id).default("Unknown")
	sling_name << p_sling_wire.perform(:name).default("")

	# Build chain name
	_if sling_name <> ""
	_then
		chain_name << sling_name
	_else
		chain_name << write_string("SLING WIRE ", sling_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", chain_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#sling_wire_map</styleUrl>", newline_char)

	# Write ExtendedData with sling_wire attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", sling_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>SLING WIRE</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write LineString geometry
	p_stream.write(p_indent, "  <LineString>", newline_char)
	p_stream.write(p_indent, "    <tessellate>1</tessellate>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </LineString>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_cable(p_cable, p_route_sectors, p_stream, p_indent)
	## Write cable/sheath_with_loc chain as LineString with coordinates and styling
	##
	## Parameters:
	##   p_cable - Cable (sheath_with_loc) object
	##   p_route_sectors - Route sectors from cable.route_sectors()
	##   p_stream - Output stream
	##   p_indent - Indentation string

	_if p_route_sectors _is _unset _then _return _endif
	_if .cs_transform _is _unset _then _return _endif

	# Convert route sectors to coordinate string
	_dynamic !print_float_precision! << 16
	coord_string << ""

	# p_route_sectors is already the sectors collection from route_sectors()
	# Iterate through sectors and coordinates (like write_line in rwi_export_to_kml)
	_for sector _over p_route_sectors.fast_elements()
	_loop
		_for coord _over sector.fast_elements()
		_loop
			# Convert coordinate to WGS84
			t_coord << .cs_transform.convert(coord)
			# Format as "lon,lat,0 "
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endloop
	_endloop

	# Get cable attributes
	cable_id << p_cable.perform(:id).default("Unknown")
	cable_name << p_cable.perform(:name).default("")

	# Build chain name
	_if cable_name <> ""
	_then
		chain_name << cable_name
	_else
		chain_name << write_string("CABLE ", cable_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", chain_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>#cable_map</styleUrl>", newline_char)

	# Write ExtendedData with cable attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", cable_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>CABLE</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write LineString geometry
	p_stream.write(p_indent, "  <LineString>", newline_char)
	p_stream.write(p_indent, "    <tessellate>1</tessellate>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </LineString>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_demand_point(p_dp, p_stream, p_indent, p_folder_name)
	## Write demand point (home pass) placemark with coordinates and styling
	##
	## Parameters:
	##   p_dp - Demand point object
	##   p_stream - Output stream
	##   p_indent - Indentation string
	##   p_folder_name - Folder name (HP COVER or HP UNCOVER) for style determination

	# Get demand point geometry (location point)
	dp_geom << p_dp.location
	_if dp_geom _is _unset _then _return _endif

	# Get coordinate
	coord << dp_geom.coord
	_if coord _is _unset _then _return _endif

	# Convert coordinate to WGS84 (Google Earth coordinate system)
	coord_string << _self.convert_coord_to_wgs84_string(coord)

	# Get demand point attributes
	dp_id << p_dp.perform(:identification).default("Unknown")
	dp_name << p_dp.perform(:name).default("")
	notes << p_dp.perform(:notes).default("")
	line_type << p_dp.perform(:line_type).default("")

	# Parse notes to extract ring_name (before pipe character)
	pipe_pos << notes.index_of(%|)
	_if pipe_pos _isnt _unset
	_then
		ring_name << notes.slice(1, pipe_pos - 1)
	_else
		ring_name << notes
	_endif

	# Determine style based on folder name
	_if p_folder_name.uppercase.index_of_seq("HP COVER") _isnt _unset
	_then
		style_url << "#hp_cover_map"
	_elif p_folder_name.uppercase.index_of_seq("HP UNCOVER") _isnt _unset
	_then
		style_url << "#hp_uncover_map"
	_else
		# Default to hp_cover_map
		style_url << "#hp_cover_map"
	_endif

	# Build demand point label - use name if available, otherwise identification
	_if dp_name <> ""
	_then
		placemark_name << dp_name
	_else
		placemark_name << write_string("HP ", dp_id)
	_endif

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", placemark_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with demand point attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", dp_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	_if ring_name <> ""
	_then
		p_stream.write(p_indent, "    <Data name='Ring'>", newline_char)
		p_stream.write(p_indent, "      <value>", ring_name, "</value>", newline_char)
		p_stream.write(p_indent, "    </Data>", newline_char)
	_endif
	_if line_type <> ""
	_then
		p_stream.write(p_indent, "    <Data name='Line'>", newline_char)
		p_stream.write(p_indent, "      <value>", line_type, "</value>", newline_char)
		p_stream.write(p_indent, "    </Data>", newline_char)
	_endif
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_cell(p_cell, p_stream, p_indent, p_folder_name)
	## Write cell (ftth!zone) polygon placemark with coordinates and styling
	##
	## Parameters:
	##   p_cell - Cell object (ftth!zone)
	##   p_stream - Output stream
	##   p_indent - Indentation string
	##   p_folder_name - Folder name for determining context

	# Get cell geometry (polygon)
	cell_geom << p_cell.location
	_if cell_geom _is _unset _then _return _endif
	_if .cs_transform _is _unset _then _return _endif

	# Convert polygon sectors to coordinate string
	_dynamic !print_float_precision! << 16
	coord_string << ""

	# Get polygon sectors and convert each coordinate
	polygon_sectors << cell_geom.sectors
	_for sector _over polygon_sectors.fast_elements()
	_loop
		_for coord _over sector.coords.fast_elements()
		_loop
			t_coord << .cs_transform.convert(coord)
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endloop
	_endloop

	# Close the polygon (first coord = last coord)
	_if polygon_sectors.size > 0
	_then
		first_sector << polygon_sectors.first
		_if first_sector.coords.size > 0
		_then
			first_coord << first_sector.coords.first
			t_coord << .cs_transform.convert(first_coord)
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endif
	_endif

	# Get cell attributes
	cell_id << p_cell.perform(:identification).default("Unknown")
	cell_type << p_cell.perform(:type).default("Micro Cell")
	note << p_cell.perform(:note).default("")
	splitter_id << p_cell.perform(:splitter_id).default("")

	# Parse note to extract ring_name (before pipe character)
	pipe_pos << note.index_of(%|)
	_if pipe_pos _isnt _unset
	_then
		ring_name << note.slice(1, pipe_pos - 1)
	_else
		ring_name << note
	_endif

	# Count demand points within cell area
	hp_count << 0
	_try
		# Use stored database to get demand points collection
		_if .database _isnt _unset
		_then
			dp_col << .database.collections[:ftth!demand_point]
			_if dp_col _isnt _unset
			_then
				# Query demand points within cell polygon
				demand_points_in_cell << dp_col.select(
					predicate.within(:location, cell_geom))
				hp_count << demand_points_in_cell.size
			_endif
		_endif
	_when error
		# If error counting, set to 0
		hp_count << 0
	_endtry

	# Determine style based on folder name and cell type
	_if p_folder_name.uppercase.index_of_seq("BOUNDARY FAT") _isnt _unset _orif
	    p_folder_name.uppercase.index_of_seq("FAT COVERAGE") _isnt _unset
	_then
		style_url << "#boundary_fat_map"
	_else
		# Default based on cell type
		_if cell_type.uppercase = "MACRO CELL"
		_then
			style_url << "#boundary_cluster_map"
		_else
			style_url << "#boundary_fat_map"
		_endif
	_endif

	# Build cell label
	placemark_name << cell_id

	# Build description with HP count
	description << write_string("Home Pass Count: ", hp_count)

	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", placemark_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <description>", description, "</description>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write ExtendedData with cell attributes
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='ID'>", newline_char)
	p_stream.write(p_indent, "      <value>", cell_id, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'>", newline_char)
	p_stream.write(p_indent, "      <value>", cell_type, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	_if ring_name <> ""
	_then
		p_stream.write(p_indent, "    <Data name='Ring'>", newline_char)
		p_stream.write(p_indent, "      <value>", ring_name, "</value>", newline_char)
		p_stream.write(p_indent, "    </Data>", newline_char)
	_endif
	_if splitter_id <> ""
	_then
		p_stream.write(p_indent, "    <Data name='Splitter'>", newline_char)
		p_stream.write(p_indent, "      <value>", splitter_id, "</value>", newline_char)
		p_stream.write(p_indent, "    </Data>", newline_char)
	_endif
	# Add HP count to extended data
	p_stream.write(p_indent, "    <Data name='HP_Count'>", newline_char)
	p_stream.write(p_indent, "      <value>", hp_count, "</value>", newline_char)
	p_stream.write(p_indent, "    </Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Write Polygon geometry
	p_stream.write(p_indent, "  <Polygon>", newline_char)
	p_stream.write(p_indent, "    <outerBoundaryIs>", newline_char)
	p_stream.write(p_indent, "      <LinearRing>", newline_char)
	p_stream.write(p_indent, "        <coordinates>", newline_char)
	p_stream.write(p_indent, "          ", coord_string, newline_char)
	p_stream.write(p_indent, "        </coordinates>", newline_char)
	p_stream.write(p_indent, "      </LinearRing>", newline_char)
	p_stream.write(p_indent, "    </outerBoundaryIs>", newline_char)
	p_stream.write(p_indent, "  </Polygon>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_boundary(p_boundary_name, p_boundary_geom, p_stream, p_indent, p_folder_name)
	## Write project boundary polygon placemark
	## Used for BOUNDARY CLUSTER - exports the project area with project name
	##
	## Parameters:
	##   p_boundary_name - Boundary name (project/scheme name)
	##   p_boundary_geom - Boundary geometry (polygon from project_area)
	##   p_stream - Output stream
	##   p_indent - Indentation string
	##   p_folder_name - Folder name for style determination

	# Check geometry
	_if p_boundary_geom _is _unset _then _return _endif
	_if .cs_transform _is _unset _then _return _endif

	# Convert polygon sectors to coordinate string
	_dynamic !print_float_precision! << 16
	coord_string << ""

	# Get polygon sectors and convert each coordinate
	polygon_sectors << p_boundary_geom.sectors
	_for sector _over polygon_sectors.fast_elements()
	_loop
		_for coord _over sector.coords.fast_elements()
		_loop
			t_coord << .cs_transform.convert(coord)
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endloop
	_endloop

	# Close the polygon (first coord = last coord)
	_if polygon_sectors.size > 0
	_then
		first_sector << polygon_sectors.first
		_if first_sector.coords.size > 0
		_then
			first_coord << first_sector.coords.first
			t_coord << .cs_transform.convert(first_coord)
			coord_string +<< write_string(t_coord.x, ",", t_coord.y, ",0 ")
		_endif
	_endif
	
	style_url << "#boundary_cluster_map"
	# Write KML Placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", p_boundary_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Write Polygon geometry
	p_stream.write(p_indent, "  <Polygon>", newline_char)
	p_stream.write(p_indent, "    <outerBoundaryIs>", newline_char)
	p_stream.write(p_indent, "      <LinearRing>", newline_char)
	p_stream.write(p_indent, "        <coordinates>", newline_char)
	p_stream.write(p_indent, "          ", coord_string, newline_char)
	p_stream.write(p_indent, "        </coordinates>", newline_char)
	p_stream.write(p_indent, "      </LinearRing>", newline_char)
	p_stream.write(p_indent, "    </outerBoundaryIs>", newline_char)
	p_stream.write(p_indent, "  </Polygon>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$

_pragma(classify_level=basic, topic={rwi_export})
_method rwi_aerial_kmz_object_writer.write_olt(p_olt, p_stream, p_indent, p_folder_name)
	## Write OLT (Optical Line Terminal) or mit_hub to KML
	##
	## Parameters:
	##   p_olt - OLT object
	##   p_stream - Output stream
	##   p_indent - Indentation string
	##   p_folder_name - Parent folder name

	# Get OLT attributes
	olt_name << p_olt.perform(:name).default("OLT")
	olt_code << p_olt.perform(:olt_code).default("")
	olt_type << p_olt.perform(:type).default("")
	olt_location << p_olt.location

	_if olt_location _is _unset _then _return _endif

	# Convert coordinate to WGS84
	coord_string << _self.convert_coord_to_wgs84_string(olt_location.coord)

	# Build description
	description << write_string(
		"Name: ", olt_name, %newline,
		"OLT Code: ", olt_code, %newline,
		"Type: ", olt_type)

	# Determine style based on folder name
	style_url << "#olt_map"

	# Write placemark
	p_stream.write(p_indent, "<Placemark>", newline_char)
	p_stream.write(p_indent, "  <name>", olt_name, "</name>", newline_char)
	p_stream.write(p_indent, "  <description>", description, "</description>", newline_char)
	p_stream.write(p_indent, "  <styleUrl>", style_url, "</styleUrl>", newline_char)

	# Extended data
	p_stream.write(p_indent, "  <ExtendedData>", newline_char)
	p_stream.write(p_indent, "    <Data name='OLT Code'><value>", olt_code, "</value></Data>", newline_char)
	p_stream.write(p_indent, "    <Data name='Type'><value>", olt_type, "</value></Data>", newline_char)
	p_stream.write(p_indent, "  </ExtendedData>", newline_char)

	# Point geometry
	p_stream.write(p_indent, "  <Point>", newline_char)
	p_stream.write(p_indent, "    <coordinates>", coord_string, "</coordinates>", newline_char)
	p_stream.write(p_indent, "  </Point>", newline_char)

	p_stream.write(p_indent, "</Placemark>", newline_char)
_endmethod
$
