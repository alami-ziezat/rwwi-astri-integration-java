#% text_encoding = iso8859_1

_package user

## ASTRI Work Order Dialog - Export Methods
## Handles KML/KMZ download and export operations

_method rwwi_astri_workorder_dialog.download_kmz()
	## Download KMZ file for selected work order using kmz_uuid

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	write("Downloading KMZ for UUID:", kmz_uuid)

	_try
		# Call ASTRI KMZ download API with kmz_uuid based on infrastructure type
		# astri_download_cluster_kmz(uuid, outputDir)
		# astri_download_subfeeder_kmz(uuid, outputDir)
		# astri_download_feeder_kmz(uuid, outputDir)

		# Get home directory and create astri_kml subdirectory
		_local home_dir << system.getenv("USERPROFILE")  # Windows
		_if home_dir _is _unset _orif home_dir = ""
		_then
			# Fallback to TEMP if USERPROFILE not available
			home_dir << system.getenv("TEMP").default("C:\temp")
		_endif

		_local output_dir << system.pathname_from_components("astri_kml", home_dir)

		# Create directory if it doesn't exist
		_if _not system.file_exists?(output_dir)
		_then
			_try
				system.mkdir(output_dir)
				write("Created ASTRI KML download directory: ", output_dir)
			_when error
				write("WARNING: Could not create astri_kml directory, using temp instead")
				output_dir << system.getenv("TEMP").default("C:\temp")
			_endtry
		_endif

		_local infra_type << .filters[:infrastructure_type].default("cluster")
		write("infra type: ",infra_type)
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.user_error("Failed to download KMZ file")
			_return
		_endif

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    file_path_elem _isnt _unset
		_then
			_local file_path << file_path_elem.xml_result

			# Log the successful download with file path
			_self.log_separator()
			_self.log_success("KMZ DOWNLOAD COMPLETE!")
			_self.log_info("File saved to:")
			_self.log_info("  " + file_path)
			_self.log_separator()

			_self.user_info(write_string("KMZ downloaded successfully:", %newline, file_path))

			# Auto-open KMZ file in default application (Google Earth, etc.)
			_try
				write("Opening KMZ file in default application...")
				_self.log_info("Opening KMZ file in default application...")
				# Use start command to open file with default application
				# The empty quotes after start are for the window title (required when path has spaces)
				_local command << write_string("cmd /c start ", %", %", " ", %", file_path, %")
				write("Opening KMZ with command: ", command)
				system.do_command(command)
				_self.log_info("KMZ file opened successfully")
			_when error
				write("WARNING: Could not auto-open KMZ file: ", condition.report_contents_string)
				_self.log_info("Note: Could not auto-open KMZ file automatically")
			_endtry
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.user_error(write_string("Failed to download KMZ:", %newline, error_msg))
		_endif

	_when error
		_self.user_error(write_string("Error downloading KMZ:", %newline,
			condition.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.export_smallworld_kml()
	## Export Smallworld objects to KML based on selected work order
	## Exports design area with infrastructure type filtering

	_if .selected_wo _is _unset
	_then
		_self.show_alert("No Work Order Selected",
			"Please select a work order to export")
		_return
	_endif

	# Get work order details
	wo_number << .selected_wo[:wo_number]
	infra_type << .selected_wo[:infrastructure_type].default("cluster")
	infra_code << .selected_wo[:infra_code].default("UNKNOWN")

	write("Exporting KML for WO:", wo_number, " Infrastructure:", infra_type, " Code:", infra_code)
	_self.log_info(write_string("Exporting KML for WO: ", wo_number, " Code: ", infra_code))

	# Get project and design
	_try _with errCond
		design << .engine.get_design_for_project(wo_number)
		_if design _is _unset
		_then
			_self.show_alert("Design Not Found",
				write_string("No design found for project '", wo_number, "'"))
			_return
		_endif

		# Activate the design before export
		_self.log_info(write_string("Activating design for project: ", wo_number))
		.engine.activate_design(wo_number)

		# Get design boundary
		design_area << .engine.get_design_boundary(design)
		_if design_area _is _unset
		_then
			_self.show_alert("Design Area Not Found",
				"Design has no boundary area defined")
			_return
		_endif

		# Show file chooser dialog
		# Sanitize WO number for filename (replace / with _)
		safe_filename << wo_number.substitute_string("/", "_") + ".kmz"
		output_file << _self.get_output_file_from_user(safe_filename)
		_if output_file _is _unset
		_then
			_return  # User cancelled
		_endif

		# Create exporter
		exporter << rwi_export_to_aerial_kmz.new()
		exporter.gc << gis_program_manager.cached_dataset(:gis).collections
		exporter.project_name << wo_number
		exporter.project_area << design_area
		exporter.scheme_name << design.perform(:name).default(wo_number)
		exporter.infrastructure_type << infra_type.as_symbol()
		exporter.infrastructure_code << infra_code  # Pass infrastructure code for folder naming

		# Show progress
		_self.log_info("Starting export...")

		# Export with dynamic network detection
		export_result << exporter.export_mixed_network(design_area, output_file)

		# Extract results
		output_path << export_result[:output_file]
		total_poles << export_result[:total_poles]
		pole_stats << export_result[:pole_statistics]
		total_fats << export_result[:total_fats]
		total_fdts << export_result[:total_fdts]
		total_closures << export_result[:total_closures]
		total_slack_hangers << export_result[:total_slack_hangers]
		total_sling_wires << export_result[:total_sling_wires]
		total_cable_length << export_result[:total_cable_length].default(0.0)

		# Display statistics in UI text window
		_self.log_info("")
		_self.log_info("="*60)
		_self.log_info("AERIAL KML EXPORT - STATISTICS REPORT")
		_self.log_info("="*60)
		_self.log_info(write_string("Project: ", wo_number))
		_self.log_info(write_string("Infrastructure Type: ", infra_type))
		_self.log_info("-"*60)
		_self.log_info("POLE EXPORT SUMMARY:")
		_self.log_info("-"*60)

		# Display poles per folder
		_if pole_stats.size > 0
		_then
			folder_names << pole_stats.keys.as_sorted_collection()
			_for folder_name _over folder_names.fast_elements()
			_loop
				count << pole_stats[folder_name]
				_self.log_info(write_string("  ", folder_name, ": ", count))
			_endloop
		_else
			_self.log_info("  No poles exported")
		_endif

		_self.log_info("-"*60)
		_self.log_info(write_string("TOTAL POLES EXPORTED: ", total_poles))
		_self.log_info("-"*60)
		_self.log_info("EQUIPMENT EXPORT SUMMARY:")
		_self.log_info("-"*60)
		_self.log_info(write_string("  FAT: ", total_fats))
		_self.log_info(write_string("  FDT: ", total_fdts))
		_self.log_info(write_string("  CLOSURE: ", total_closures))
		_self.log_info(write_string("  SLACK HANGER: ", total_slack_hangers))
		_self.log_info(write_string("  SLING WIRE: ", total_sling_wires))
		_self.log_info("-"*60)
		_self.log_info("CABLE EXPORT SUMMARY:")
		_self.log_info("-"*60)
		_self.log_info(write_string("  TOTAL CABLE LENGTH: ", total_cable_length.rounded, " meters"))
		_self.log_info("-"*60)
		_self.log_info("HOME PASS EXPORT SUMMARY:")
		_self.log_info("-"*60)
		_self.log_info(write_string("  HOME PASS: ", export_result[:total_home_pass].default(0)))
		_self.log_info("-"*60)
		_self.log_info("CELL EXPORT SUMMARY:")
		_self.log_info("-"*60)
		_self.log_info(write_string("  CELLS (BOUNDARY): ", export_result[:total_cells].default(0)))
		_self.log_info("="*60)
		_self.log_info("")

		# Success message
		_self.show_message("Export Complete",
			write_string("Created: ", output_path))
		_self.log_info(write_string("Export completed: ", output_path))

		# Auto-open KML file in default application (Google Earth, etc.)
		_try
			_self.log_info("Opening KML file in default application...")
			# Use start command to open file with default application
			# The empty quotes after start are for the window title (required when path has spaces)
			command << write_string("cmd /c start ", %", %", " ", %", output_path, %")
			write("Opening KML with command: ", command)
			system.do_command(command)
			_self.log_info("KML file opened successfully")
		_when error
			write("WARNING: Could not auto-open KML file: ", condition.report_contents_string)
			_self.log_info("Note: Could not auto-open KML file automatically")
		_endtry

	_when error
		_self.show_alert("Export Failed", errCond.report_contents_string)
		_self.log_info(write_string("Export failed: ", errCond.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.get_output_file_from_user(default_filename)
	## Returns KMZ output file path in home directory under sw_kml folder
	## Creates sw_kml directory if it doesn't exist

	# Get user home directory
	home_dir << system.getenv("USERPROFILE")  # Windows
	_if home_dir _is _unset _orif home_dir = ""
	_then
		# Fallback to TEMP if USERPROFILE not available
		home_dir << system.temp_directory_name
	_endif

	# Create sw_kml subdirectory path
	output_dir << system.pathname_from_components("sw_kml", home_dir)

	# Create directory if it doesn't exist
	_if _not system.file_exists?(output_dir)
	_then
		_try
			system.mkdir(output_dir)
			write("Created KML output directory: ", output_dir)
		_when error
			write("WARNING: Could not create sw_kml directory, using temp instead")
			output_dir << system.temp_directory_name
		_endtry
	_endif

	# Construct full file path
	output_file << system.pathname_from_components(default_filename, output_dir)

	>> output_file
_endmethod
$
