#% text_encoding = iso8859_1
_package user
$

remex(:rwwi_astri_boq_generator)
$

_pragma(classify_level=basic, topic={boq, generator})
##
## Class: rwwi_astri_boq_generator
##
## Purpose: Generate Bill of Quantities (BoQ) from Smallworld design data
##          in a structured, data-driven, object-oriented manner.
##
## Usage:
##   # For current active design
##   gen << rwwi_astri_boq_generator.new_for_current_design("json")
##   boq_items << gen.generate()
##
##   # For specific design
##   gen << rwwi_astri_boq_generator.new()
##   gen.set_scheme(my_scheme)
##   boq_items << gen.generate()
##
## Author: Claude Code Assistant
## Date: 2025-11-17
##
def_slotted_exemplar(:rwwi_astri_boq_generator,
	{
		{:scheme, _unset, :writable},           ## Current design scheme (mit_scheme)
		{:change_set, _unset, :writable},       ## MIT scheme record change set
		{:output_type, _unset, :writable}       ## Output type (json, xml, etc.)
	})
$

_pragma(classify_level=basic, topic={boq})
##
## MATERIAL_CATALOG - Central repository for all BoQ material definitions
##
## Structure: equality_hash_table mapping symbol keys to property_lists
##
## Each entry contains:
##   :code - Material/service code (e.g., "200001033")
##   :object - Category (e.g., "Sling Wire", "FAT", "Pole")
##   :name - Full description
##   :material_slot - Which slot gets the quantity (:material or :service)
##   :spec_id - (optional) Spec ID for matching design objects
##
rwwi_astri_boq_generator.define_shared_constant(
	:MATERIAL_CATALOG,
	equality_hash_table.new_with(
		# Sling Wire
		:sling_wire, property_list.new_with(
			:code, "200001033",
			:object, "Sling Wire",
			:name, "Instalasi strand wire/sling messenger 6 mm",
			:material_slot, :service
		),

		# FAT Types
		:fat_pole_16, property_list.new_with(
			:code, "200001047",
			:object, "FAT",
			:name, "Pole mounted outdoor type (16 ports type)",
			:material_slot, :material
		),
		:fat_pedestal_16, property_list.new_with(
			:code, "100000824",
			:object, "FAT",
			:name, "Pedestal mounted type (16 ports type)",
			:material_slot, :material
		),

		# FDT Types
		:fdt_48, property_list.new_with(
			:code, "200001039",
			:object, "FDT",
			:name, "48 cores capacity pole mounted FDT",
			:material_slot, :material
		),
		:fdt_72, property_list.new_with(
			:code, "200001040",
			:object, "FDT",
			:name, "72 cores capacity pole mounted FDT",
			:material_slot, :material
		),
		:fdt_96, property_list.new_with(
			:code, "200001041",
			:object, "FDT",
			:name, "96 cores capacity pole mounted FDT",
			:material_slot, :material
		),
		:fdt_144, property_list.new_with(
			:code, "200001042",
			:object, "FDT",
			:name, "144 cores capacity ground mounted FDT",
			:material_slot, :material
		),
		:fdt_288, property_list.new_with(
			:code, "200001043",
			:object, "FDT",
			:name, "288 cores capacity ground mounted FDT",
			:material_slot, :material
		),
		:fdt_576, property_list.new_with(
			:code, "200001044",
			:object, "FDT",
			:name, "576 cores capacity ground mounted FDT",
			:material_slot, :material
		),

		# Poles
		:pole_7m_3inch, property_list.new_with(
			:code, "200001055",
			:object, "Pole",
			:name, "Pengadaan Tiang 7 meter 3 inch",
			:material_slot, :material
		),
		:pole_7m_4inch, property_list.new_with(
			:code, "200001183",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang 7 meter 4", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		:pole_7m_5inch, property_list.new_with(
			:code, "200000187",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang 7 meter 5", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		:pole_9m_4inch, property_list.new_with(
			:code, "200001181",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang Tunggal 9 meter 4", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		:pole_9m_5inch, property_list.new_with(
			:code, "200000169",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang Tunggal 9 meter 5", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),

		# Cables
		:cable_24, property_list.new_with(
			:code, "200000100",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 24 cores",
			:material_slot, :material
		),
		:cable_36, property_list.new_with(
			:code, "200000975",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 36 cores",
			:material_slot, :material
		),
		:cable_48, property_list.new_with(
			:code, "200001038",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 48 cores",
			:material_slot, :material
		),
		:cable_96, property_list.new_with(
			:code, "200001630",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 96 cores",
			:material_slot, :material
		),
		:cable_144, property_list.new_with(
			:code, "200001030",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 144 cores",
			:material_slot, :material
		),
		:cable_288, property_list.new_with(
			:code, "200001015",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 288 cores",
			:material_slot, :material
		),

		# Closures - Inline
		:closure_inline_24, property_list.new_with(
			:code, "200000182",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 24 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 24 Core"
		),
		:closure_inline_36, property_list.new_with(
			:code, "200001048",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 36 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 36 Core"
		),
		:closure_inline_48, property_list.new_with(
			:code, "200000159",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 48 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 48 Core"
		),
		:closure_inline_96, property_list.new_with(
			:code, "200000179",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 96 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 96 Core"
		),
		:closure_inline_144, property_list.new_with(
			:code, "200000186",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 144 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 144 Core"
		),
		:closure_inline_288, property_list.new_with(
			:code, "200000155",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 288 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 288 Core"
		),

		# Closures - Dome
		:closure_dome_24, property_list.new_with(
			:code, "200000180",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 24 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 24 Core"
		),
		:closure_dome_36, property_list.new_with(
			:code, "200001049",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 36 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 36 Core"
		),
		:closure_dome_48, property_list.new_with(
			:code, "200000164",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 48 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 48 Core"
		),
		:closure_dome_96, property_list.new_with(
			:code, "200000176",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 96 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 96 Core"
		),
		:closure_dome_144, property_list.new_with(
			:code, "200000158",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 144 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 144 Core"
		),
		:closure_dome_288, property_list.new_with(
			:code, "200000156",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 288 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 288 Core"
		)
	),
	:public
)
$

# ============================================================================
# Constructor and Initialization Methods
# ============================================================================

_method rwwi_astri_boq_generator.new()
	## Create new BoQ generator instance
	## Returns: New uninitialized generator
	>> _clone.init()
_endmethod
$

_private _method rwwi_astri_boq_generator.init()
	## Initialize generator with default values
	## Returns: _self
	.scheme << _unset
	.change_set << _unset
	.output_type << "json"
	>> _self
_endmethod
$

_method rwwi_astri_boq_generator.new_for_current_design(_optional output_type)
	## Factory method - creates generator for current active design
	## Parameters:
	##   output_type (optional) - "json", "xml", etc. Defaults to "json"
	## Returns:
	##   New generator instance or _unset if no design active

	_try _with errCond
		_local scheme << swg_dsn_admin_engine.get_current_job()
		_if scheme _is _unset
		_then
			write("LOG: ERROR - No design currently active")
			_return _unset
		_endif

		_local generator << _self.new()
		generator.set_scheme(scheme)
		_if output_type _isnt _unset
		_then
			generator.output_type << output_type
		_endif

		_return generator
	_when error
		write("LOG: ERROR creating BoQ generator:", errCond.report_contents_string)
		_return _unset
	_endtry
_endmethod
$

# ============================================================================
# Configuration Methods
# ============================================================================

_method rwwi_astri_boq_generator.set_scheme(scheme)
	## Set the design scheme and create change set
	## Parameters:
	##   scheme - MIT scheme object

	_try _with errCond
		_if scheme _is _unset
		_then
			write("LOG: ERROR - Cannot set _unset scheme")
			condition.raise(:user_error, :string, "Scheme cannot be _unset")
		_endif

		.scheme << scheme
		.change_set << mit_scheme_record_change_set.new(scheme)

		write("LOG: BoQ generator configured for design:", scheme.name)
	_when error
		write("LOG: ERROR setting scheme:", errCond.report_contents_string)
		condition.raise(:user_error, :string, errCond)
	_endtry
_endmethod
$

# ============================================================================
# Main Generation Method
# ============================================================================

_method rwwi_astri_boq_generator.generate()
	## Generate complete BoQ for current design
	## Returns: rope of property_lists with BoQ items

	_try _with errCond
		_if .scheme _is _unset _orif .change_set _is _unset
		_then
			write("LOG: ERROR - Generator not initialized properly")
			condition.raise(:user_error, :string,
				"BoQ generator not initialized. Call set_scheme() first.")
		_endif

		_local result << rope.new()

		write("LOG: Generating BoQ for design:", .scheme.name)

		# Generate BoQ items by category
		_self.add_sling_wire_items(result)
		_self.add_fat_items(result)
		_self.add_fdt_items(result)
		_self.add_pole_items(result)
		_self.add_cable_items(result)
		_self.add_closure_items(result)

		write("LOG: BoQ generation complete. Total items:", result.size)

		_return result
	_when error
		write("LOG: ERROR generating BoQ:", errCond.report_contents_string)
		condition.raise(:user_error, :string, errCond)
	_endtry
_endmethod
$

# ============================================================================
# Category-Specific Generation Methods
# ============================================================================

_private _method rwwi_astri_boq_generator.add_sling_wire_items(result)
	## Add sling wire items to result
	## Parameters:
	##   result - rope to add items to

	_try _with errCond
		_local length << _self.count_sling_wire_length()
		_if length _isnt _unset _andif length > 0
		_then
			_local item << _self.create_boq_item(:sling_wire, _unset, length)
			result.add(item)
		_endif
	_when error
		write("LOG: ERROR adding sling wire items:", errCond.report_contents_string)
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.add_fat_items(result)
	## Add FAT items to result

	_try _with errCond
		_local (pole_count, pedestal_count) << _self.count_fat_types()

		_if pole_count _isnt _unset _andif pole_count > 0
		_then
			result.add(_self.create_boq_item(:fat_pole_16, pole_count, _unset))
		_endif

		_if pedestal_count _isnt _unset _andif pedestal_count > 0
		_then
			result.add(_self.create_boq_item(:fat_pedestal_16, pedestal_count, _unset))
		_endif
	_when error
		write("LOG: ERROR adding FAT items:", errCond.report_contents_string)
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.add_fdt_items(result)
	## Add FDT items to result

	_try _with errCond
		_local (f48, f72, f96, f144, f288, f576) << _self.count_fdt_types()

		_local fdt_types << {:fdt_48, :fdt_72, :fdt_96, :fdt_144, :fdt_288, :fdt_576}
		_local counts << {f48, f72, f96, f144, f288, f576}

		_for i _over 1.upto(fdt_types.size)
		_loop
			_if counts[i] _isnt _unset _andif counts[i] > 0
			_then
				result.add(_self.create_boq_item(fdt_types[i], counts[i], _unset))
			_endif
		_endloop
	_when error
		write("LOG: ERROR adding FDT items:", errCond.report_contents_string)
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.add_pole_items(result)
	## Add pole items to result

	_try _with errCond
		_local (p7_3, p7_4, p7_5, p9_4, p9_5) << _self.count_pole_types()

		_local pole_types << {:pole_7m_3inch, :pole_7m_4inch, :pole_7m_5inch,
		                      :pole_9m_4inch, :pole_9m_5inch}
		_local counts << {p7_3, p7_4, p7_5, p9_4, p9_5}

		_for i _over 1.upto(pole_types.size)
		_loop
			_if counts[i] _isnt _unset _andif counts[i] > 0
			_then
				result.add(_self.create_boq_item(pole_types[i], counts[i], _unset))
			_endif
		_endloop
	_when error
		write("LOG: ERROR adding pole items:", errCond.report_contents_string)
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.add_cable_items(result)
	## Add cable items to result

	_try _with errCond
		_local (c24, c36, c48, c96, c144, c288) << _self.count_cable_types()

		_local cable_types << {:cable_24, :cable_36, :cable_48,
		                       :cable_96, :cable_144, :cable_288}
		_local lengths << {c24, c36, c48, c96, c144, c288}

		_for i _over 1.upto(cable_types.size)
		_loop
			_if lengths[i] _isnt _unset _andif lengths[i] > 0
			_then
				result.add(_self.create_boq_item(cable_types[i], lengths[i], _unset))
			_endif
		_endloop
	_when error
		write("LOG: ERROR adding cable items:", errCond.report_contents_string)
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.add_closure_items(result)
	## Add closure items to result

	_try _with errCond
		_local closure_counts << _self.count_closure_types()

		# Check if closure_counts is valid
		_if closure_counts _is _unset _orif closure_counts.empty?
		_then
			write("LOG: No closures found in design")
			_return
		_endif

		# Iterate catalog to match spec_ids with counts
		_for catalog_key, catalog_entry _over _self.MATERIAL_CATALOG.fast_keys_and_elements()
		_loop
			_if catalog_entry[:object] = "Closure"
			_then
				_local spec_id << catalog_entry[:spec_id]
				_local count << closure_counts[spec_id]

				_if count _isnt _unset _andif count > 0
				_then
					result.add(_self.create_boq_item(catalog_key, count, _unset))
				_endif
			_endif
		_endloop
	_when error
		write("LOG: ERROR adding closure items:", errCond.report_contents_string)
	_endtry
_endmethod
$

# ============================================================================
# Item Creation Helper
# ============================================================================

_private _method rwwi_astri_boq_generator.create_boq_item(catalog_key, material_qty, service_qty)
	## Create a BoQ item property_list from catalog
	## Parameters:
	##   catalog_key - Symbol key in MATERIAL_CATALOG
	##   material_qty - Quantity for :material slot (or _unset)
	##   service_qty - Quantity for :service slot (or _unset)
	## Returns:
	##   property_list with BoQ item data

	_try _with errCond
		write("Starting BoQ item creation for catalog key:", catalog_key)
		_local catalog_entry << _self.MATERIAL_CATALOG[catalog_key]
		_if catalog_entry _is _unset
		_then
			write("LOG: ERROR - Unknown catalog key:", catalog_key)
			condition.raise(:user_error, :string,
				write_string("Unknown material catalog key: ", catalog_key))
		_endif

		# Determine which slot gets which quantity
		_local mat_value << _unset
		_local svc_value << _unset

		_local slot_type << catalog_entry[:material_slot]
		_if slot_type = :material
		_then
			mat_value << material_qty
			svc_value << service_qty
		_elif slot_type = :service
		_then
			mat_value << service_qty
			svc_value << material_qty
		_endif

		# Create property list
		_local item << property_list.new_with(
			:type, .output_type,
			:code, catalog_entry[:code],
			:object, catalog_entry[:object],
			:name, catalog_entry[:name],
			:material, mat_value,
			:service, svc_value
		)

		>> item
	_when error
		write("LOG: ERROR creating BoQ item:", errCond.report_contents_string)
		condition.raise(:user_error, :string, errCond)
	_endtry
_endmethod
$

# ============================================================================
# Object Counting Methods
# ============================================================================

_private _method rwwi_astri_boq_generator.count_sling_wire_length()
	## Count total sling wire length from design
	## Returns: float - total length in meters
	## Logic matches get_count_sling_wire() in rwwi_astri_boq.magik

	_try _with errCond
		write("LOG: Counting sling wire length...")
		_local l_total << 0

		# Collect all sling_wire records
		_for i _over .change_set.fast_elements()
		_loop
			_local name << i.current_record.source_collection.name
			_if name _is :sling_wire
			_then
				rec << i.current_record
				l_total << l_total + rec.route.line_length
			_endif
		_endloop

		# Convert to meters (line_length is in cm, divide by 100)
		_local t_pjg << l_total / 100

		write("LOG: Sling wire total length:", t_pjg, "m")
		>> t_pjg
	_when error
		write("LOG: ERROR counting sling wire:", errCond.report_contents_string)
		>> 0
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.count_fat_types()
	## Count FAT types from design
	## Returns: (pole_count, pedestal_count)
	## Logic matches get_count_fat() in rwwi_astri_boq.magik

	_try _with errCond
		write("LOG: Counting FAT types...")
		_local table_list << rope.new()

		# Collect all sheath_splice records (FAT is stored in this collection)
		_for i _over .change_set.fast_elements()
		_loop
			_local name << i.current_record.source_collection.name
			_if name _is :sheath_splice
			_then
				table_list.add(i.current_record)
			_endif
		_endloop

		_local p1 << 0
		_local p2 << 0

		# Count by spec_id
		_for p _over table_list.fast_elements()
		_loop
			_if p.spec_id = "Pole mounted outdoor(16 ports)"
			_then
				p1 << p1 + 1
			_elif p.spec_id = "Pedestal mounted(16 ports)"
			_then
				p2 << p2 + 1
			_endif
		_endloop

		write("LOG: FAT counts - Pole:", p1, "Pedestal:", p2)
		>> p1, p2
	_when error
		write("LOG: ERROR counting FAT types:", errCond.report_contents_string)
		>> 0, 0
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.count_fdt_types()
	## Count FDT types by capacity
	## Returns: (f48, f72, f96, f144, f288, f576)
	## Logic matches get_count_fdt() in rwwi_astri_boq.magik

	_try _with errCond
		write("LOG: Counting FDT types...")
		_local table_list << rope.new()

		# Collect all sheath_splice records (FDT is stored in this collection)
		_for i _over .change_set.fast_elements()
		_loop
			_local name << i.current_record.source_collection.name
			_if name _is :sheath_splice
			_then
				table_list.add(i.current_record)
			_endif
		_endloop

		_local p1 << 0
		_local p2 << 0
		_local p3 << 0
		_local p4 << 0
		_local p5 << 0
		_local p6 << 0

		# Count by spec_id
		_for p _over table_list.fast_elements()
		_loop
			_if p.spec_id = "48 Core pole mounted FDT"
			_then
				p1 << p1 + 1
			_elif p.spec_id = "72 Core pole mounted FDT"
			_then
				p2 << p2 + 1
			_elif p.spec_id = "96 Core pole mounted FDT"
			_then
				p3 << p3 + 1
			_elif p.spec_id = "144 Core Ground mounted FDT"
			_then
				p4 << p4 + 1
			_elif p.spec_id = "288 Core Ground mounted FDT"
			_then
				p5 << p5 + 1
			_elif p.spec_id = "576 Core Ground mounted FDT"
			_then
				p6 << p6 + 1
			_endif
		_endloop

		write("LOG: FDT counts - 48:", p1, "72:", p2, "96:", p3, "144:", p4, "288:", p5, "576:", p6)
		>> p1, p2, p3, p4, p5, p6
	_when error
		write("LOG: ERROR counting FDT types:", errCond.report_contents_string)
		>> 0, 0, 0, 0, 0, 0
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.count_pole_types()
	## Count pole types by height and diameter
	## Returns: (p7_3, p7_4, p7_5, p9_4, p9_5)
	## Logic matches get_count_pole() in rwwi_astri_boq.magik

	_try _with errCond
		write("LOG: Counting pole types...")
		_local table_list << rope.new()

		# Collect all pole records
		_for i _over .change_set.fast_elements()
		_loop
			_local name << i.current_record.source_collection.name
			_if name _is :pole
			_then
				table_list.add(i.current_record)
			_endif
		_endloop

		_local p1 << 0
		_local p2 << 0
		_local p3 << 0
		_local p4 << 0
		_local p5 << 0

		# Count by type (not spec_id)
		_for p _over table_list.fast_elements()
		_loop
			_if p.type = "Pole 7-3"
			_then
				p1 << p1 + 1
			_elif p.type = "Pole 7-4"
			_then
				p2 << p2 + 1
			_elif p.type = "Pole 7-5"
			_then
				p3 << p3 + 1
			_elif p.type = "Pole 9-4"
			_then
				p4 << p4 + 1
			_elif p.type = "Pole 9-5"
			_then
				p5 << p5 + 1
			_endif
		_endloop

		write("LOG: Pole counts - 7-3:", p1, "7-4:", p2, "7-5:", p3, "9-4:", p4, "9-5:", p5)
		>> p1, p2, p3, p4, p5
	_when error
		write("LOG: ERROR counting pole types:", errCond.report_contents_string)
		>> 0, 0, 0, 0, 0
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.count_cable_types()
	## Count cable types by core count and total length
	## Returns: (c24, c36, c48, c96, c144, c288)
	## Logic matches get_count_cable() in rwwi_astri_boq.magik

	_try _with errCond
		write("LOG: Counting cable types...")
		_local table_list << rope.new()

		# Collect all sheath_with_loc records (cables)
		_for i _over .change_set.fast_elements()
		_loop
			_local name << i.current_record.source_collection.name
			_if name _is :sheath_with_loc
			_then
				table_list.add(i.current_record)
			_endif
		_endloop

		_local p1 << 0
		_local p2 << 0
		_local p3 << 0
		_local p4 << 0
		_local p5 << 0
		_local p6 << 0
		_local p7 << 0

		# Sum up cable lengths by spec_id
		_for p _over table_list.fast_elements()
		_loop
			_if p.spec_id = "SM G652D-ADSS 24C"
			_then
				p1 << p1 + p.calculated_sheath_length.value_in(:m).as_number()
			_elif p.spec_id = "SM G652D-ADSS 36C"
			_then
				p2 << p2 + p.calculated_sheath_length.value_in(:m).as_number()
			_elif p.spec_id = "SM G652D-ADSS 48C"
			_then
				p3 << p3 + p.calculated_sheath_length.value_in(:m).as_number()
			_elif p.spec_id = "SM G652D-ADSS 72C"
			_then
				p4 << p4 + p.calculated_sheath_length.value_in(:m).as_number()
			_elif p.spec_id = "SM G652D-ADSS 96C"
			_then
				p5 << p5 + p.calculated_sheath_length.value_in(:m).as_number()
			_elif p.spec_id = "SM G652D-ADSS 144C"
			_then
				p6 << p6 + p.calculated_sheath_length.value_in(:m).as_number()
			_elif p.spec_id = "SM G652D-ADSS 288C"
			_then
				p7 << p7 + p.calculated_sheath_length.value_in(:m).as_number()
			_endif
		_endloop

		write("LOG: Cable lengths - 24C:", p1, "| 36C:", p2, "| 48C:", p3, "| 96C:", p5, "| 144C:", p6, "| 288C:", p7)
		_return p1, p2, p3, p5, p6, p7
	_when error
		write("LOG: ERROR counting cable types:", errCond.report_contents_string)
		_return 0, 0, 0, 0, 0, 0
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.count_closure_types()
	## Count closure types by spec_id
	## Returns: equality_hash_table mapping spec_id to count

	_try _with errCond
		_local counts << equality_hash_table.new()

		_for record _over .change_set.fast_elements()
		_loop
			_local col_name << record.current_record.source_collection.name
			_if col_name _is :sheath_splice
			_then
				_local spec << record.current_record.spec_id
				_local current << counts[spec]
				_if current _is _unset
				_then
					counts[spec] << 1
				_else
					counts[spec] << current + 1
				_endif
			_endif
		_endloop

		>> counts
	_when error
		write("LOG: ERROR counting closure types:", errCond.report_contents_string)
		>> equality_hash_table.new()
	_endtry
_endmethod
$
