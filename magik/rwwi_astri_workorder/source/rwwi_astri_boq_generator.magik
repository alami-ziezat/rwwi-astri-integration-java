#% text_encoding = iso8859_1
_package user
$

remex(:rwwi_astri_boq_generator)
$

_pragma(classify_level=basic, topic={boq, generator})
##
## Class: rwwi_astri_boq_generator
##
## Purpose: Generate Bill of Quantities (BoQ) from Smallworld design data
##          in a structured, data-driven, object-oriented manner.
##
## Usage:
##   # Generate BOQ for current active design
##   # Note: Use cluster_code, subfeeder_code, or feeder_code based on infra_type
##   params << property_list.new_with(
##       :infra_type, "cluster",           # "cluster", "subfeeder", or "feeder"
##       :cluster_code, "CLU001",          # Use matching field: cluster_code/subfeeder_code/feeder_code
##       :vendor_name, "Vendor ABC",
##       :subcont_vendor_name, "Subcon XYZ",
##       :description, "Project Management",
##       :remarks, "Service",
##       :phase, "project_opname",
##       :area, "Jakarta",
##       :area_plant_code, "JKT01"
##   )
##   gen << rwwi_astri_boq_generator.new(params)
##   boq_items << gen.generate()
##
## Author: Claude Code Assistant
## Date: 2025-11-17
##
def_slotted_exemplar(:rwwi_astri_boq_generator,
	{
		{:scheme, _unset, :writable},              ## Current design scheme (mit_scheme)
		{:change_set, _unset, :writable},          ## MIT scheme record change set
		{:infra_type, _unset, :writable},          ## Infrastructure type filter (cluster, subfeeder, feeder)
		{:boq_params, _unset, :writable},          ## BOQ parameters (cluster_code, vendor_name, etc.)
		{:dataset, _unset, :writable}              ## GIS dataset (cached from gis_program_manager)
	})
$

_pragma(classify_level=basic, topic={boq})
##
## MATERIAL_CATALOG - Central repository for all BoQ material definitions
##
## Structure: equality_hash_table mapping code strings to property_lists
##
## Keys: Material/service code strings (e.g., "200001033", "200001055")
##
## Each entry contains:
##   :code - Material/service code (same as the key)
##   :object - Category (e.g., "Sling Wire", "FAT", "Pole")
##   :name - Full description
##   :material_slot - Which slot gets the quantity (:material or :service)
##   :spec_id - (optional) Spec ID for matching design objects
##
rwwi_astri_boq_generator.define_shared_constant(
	:MATERIAL_CATALOG,
	equality_hash_table.new_with(
		# Sling Wire
		"200001033", property_list.new_with(
			:code, "200001033",
			:object, "Sling Wire",
			:name, "Instalasi strand wire/sling messenger 6 mm",
			:material_slot, :service
		),

		# Riser
		"200001034", property_list.new_with(
			:code, "200001034",
			:object, "Riser",
			:name, "Riser Cable Installation",
			:material_slot, :service
		),

		# FAT Types
		"200001047", property_list.new_with(
			:code, "200001047",
			:object, "FAT",
			:name, "Pole mounted outdoor type (16 ports type)",
			:material_slot, :material
		),
		"100000824", property_list.new_with(
			:code, "100000824",
			:object, "FAT",
			:name, "Pedestal mounted type (16 ports type)",
			:material_slot, :material
		),

		# FDT Types
		"200001039", property_list.new_with(
			:code, "200001039",
			:object, "FDT",
			:name, "48 cores capacity pole mounted FDT",
			:material_slot, :material
		),
		"200001040", property_list.new_with(
			:code, "200001040",
			:object, "FDT",
			:name, "72 cores capacity pole mounted FDT",
			:material_slot, :material
		),
		"200001041", property_list.new_with(
			:code, "200001041",
			:object, "FDT",
			:name, "96 cores capacity pole mounted FDT",
			:material_slot, :material
		),
		"200001042", property_list.new_with(
			:code, "200001042",
			:object, "FDT",
			:name, "144 cores capacity ground mounted FDT",
			:material_slot, :material
		),
		"200001043", property_list.new_with(
			:code, "200001043",
			:object, "FDT",
			:name, "288 cores capacity ground mounted FDT",
			:material_slot, :material
		),
		"200001044", property_list.new_with(
			:code, "200001044",
			:object, "FDT",
			:name, "576 cores capacity ground mounted FDT",
			:material_slot, :material
		),

		# Poles
		"200002675", property_list.new_with(
			:code, "200002675",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang 7 meter 2.5", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		"200001055", property_list.new_with(
			:code, "200001055",
			:object, "Pole",
			:name, "Pengadaan Tiang 7 meter 3 inch",
			:material_slot, :material
		),
		"200001183", property_list.new_with(
			:code, "200001183",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang 7 meter 4", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		"200000187", property_list.new_with(
			:code, "200000187",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang 7 meter 5", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		"200001181", property_list.new_with(
			:code, "200001181",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang Tunggal 9 meter 4", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),
		"200000169", property_list.new_with(
			:code, "200000169",
			:object, "Pole",
			:name, write_string("Pengadaan Tiang Tunggal 9 meter 5", %", %,, " STEL L-003 1996"),
			:material_slot, :material
		),

		# Cables (identified by spec_id, not stf_item_code)
		"200000100", property_list.new_with(
			:code, "200000100",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 24 cores",
			:material_slot, :material,
			:spec_id, "SM G652D-ADSS 24C"
		),
		"200000975", property_list.new_with(
			:code, "200000975",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 36 cores",
			:material_slot, :material,
			:spec_id, "SM G652D-ADSS 36C"
		),
		"200001038", property_list.new_with(
			:code, "200001038",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 48 cores",
			:material_slot, :material,
			:spec_id, "SM G652D-ADSS 48C"
		),
		"200001630", property_list.new_with(
			:code, "200001630",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 96 cores",
			:material_slot, :material,
			:spec_id, "SM G652D-ADSS 96C"
		),
		"200001030", property_list.new_with(
			:code, "200001030",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 144 cores",
			:material_slot, :material,
			:spec_id, "SM G652D-ADSS 144C"
		),
		"200001015", property_list.new_with(
			:code, "200001015",
			:object, "Cable",
			:name, "FO core type SM G.652.D-ADSS 288 cores",
			:material_slot, :material,
			:spec_id, "SM G652D-ADSS 288C"
		),

		# Closures - Inline
		"200000182", property_list.new_with(
			:code, "200000182",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 24 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 24 Core"
		),
		"200001048", property_list.new_with(
			:code, "200001048",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 36 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 36 Core"
		),
		"200000159", property_list.new_with(
			:code, "200000159",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 48 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 48 Core"
		),
		"200000179", property_list.new_with(
			:code, "200000179",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 96 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 96 Core"
		),
		"200000186", property_list.new_with(
			:code, "200000186",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 144 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 144 Core"
		),
		"200000155", property_list.new_with(
			:code, "200000155",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type In-line 288 Core",
			:material_slot, :material,
			:spec_id, "Join Closure In-line 288 Core"
		),

		# Closures - Dome
		"200000180", property_list.new_with(
			:code, "200000180",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 24 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 24 Core"
		),
		"200001049", property_list.new_with(
			:code, "200001049",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 36 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 36 Core"
		),
		"200000164", property_list.new_with(
			:code, "200000164",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 48 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 48 Core"
		),
		"200000176", property_list.new_with(
			:code, "200000176",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 96 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 96 Core"
		),
		"200000158", property_list.new_with(
			:code, "200000158",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 144 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 144 Core"
		),
		"200000156", property_list.new_with(
			:code, "200000156",
			:object, "Closure",
			:name, "Fiber Optic Joint Closure Type Dome 288 Core",
			:material_slot, :material,
			:spec_id, "Join Closure Dome 288 Core"
		)
	),
	:public
)
$

# ============================================================================
# Constructor and Initialization Methods
# ============================================================================

_method rwwi_astri_boq_generator.new(params)
	## Create new BoQ generator for current active design
	## Parameters:
	##   params - property_list with BOQ parameters:
	##            :infra_type - Infrastructure type: "cluster", "subfeeder", or "feeder"
	##            :cluster_code - Cluster code (optional)
	##            :vendor_name - Vendor name (optional)
	##            :subcont_vendor_name - Subcontractor vendor name (optional)
	##            :remarks - Remarks (optional, default: "Service")
	##            :phase - Phase (optional, default: "project_opname")
	##            :area - Area (optional)
	##            :area_plant_code - Area plant code (optional)
	##            :override_price_material - Override price for material (optional)
	##            :override_price_service - Override price for service (optional)
	## Returns: New generator instance or _unset if no design active

	_try _with errCond
		_local scheme << swg_dsn_admin_engine.get_current_job()
		_if scheme _is _unset
		_then
			write("LOG: ERROR - No design currently active")
			_return _unset
		_endif

		_return _clone.init(scheme, params)

	_when error
		write("LOG: ERROR creating BoQ generator:", errCond.report_contents_string)
		_return _unset
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.init(scheme, params)
	## Initialize generator with scheme and BOQ parameters
	## Parameters:
	##   scheme - MIT scheme object
	##   params - property_list with BOQ parameters
	## Returns: _self

	.scheme << scheme
	.change_set << mit_scheme_record_change_set.new(scheme)
	.dataset << gis_program_manager.cached_dataset(:gis)

	# Extract infra_type and store all params
	.infra_type << params[:infra_type].default("cluster").lowercase
	.boq_params << params

	# Set defaults for optional fields if not provided
	_if .boq_params[:remarks] _is _unset
	_then
		.boq_params[:remarks] << "Service"
	_endif

	_if .boq_params[:phase] _is _unset
	_then
		.boq_params[:phase] << "project_opname"
	_endif

	write("LOG: BoQ generator configured for design:", scheme.name, "| Type:", .infra_type)
	>> _self
_endmethod
$

# ============================================================================
# Main Generation Method
# ============================================================================

_method rwwi_astri_boq_generator.generate()
	## Generate complete BoQ for current design
	## Returns: property_list with code keys mapping to BoQ item property_lists

	_try _with errCond
		_if .scheme _is _unset _orif .change_set _is _unset
		_then
			write("LOG: ERROR - Generator not initialized properly")
			condition.raise(:user_error, :string,
				"BoQ generator not initialized. Call set_scheme() first.")
		_endif

		_local result << property_list.new()

		write("LOG: Generating BoQ for design:", .scheme.name)

		# Single-pass iteration through change_set
		_for record_change _over .change_set.fast_elements()
		_loop
			_local rec << record_change.current_record

			# Only process specific collection types
			_local col_name << rec.source_collection.name
			_if col_name _isnt :sheath_splice _andif
			    col_name _isnt :pole _andif
			    col_name _isnt :sheath_with_loc _andif
			    col_name _isnt :sling_wire _andif
			    col_name _isnt :riser
			_then
				_continue
			_endif

			# Only process Proposed objects
			_if rec.responds_to?(:construction_status) _andif
			    rec.construction_status <> "Proposed"
			_then
				_continue
			_endif

			# Filter by infrastructure type (fttx_network_type)
			#_if rec.responds_to?(:fttx_network_type)
			#_then
			#	_local rec_type << rec.fttx_network_type.default("").lowercase
			#	_local filter_type << _self.normalize_infra_type(.infra_type)

			#	_if rec_type <> filter_type
			#	_then
			#		_continue
			#	_endif
			#_endif

			# Get stf_item_code from object
			_local code << _unset
			_if rec.responds_to?(:stf_item_code)
			_then
				code << rec.stf_item_code
			_endif

			# Skip if no code or not in catalog
			_if code _is _unset _orif _self.MATERIAL_CATALOG[code] _is _unset
			_then
				_continue
			_endif

			# Get quantity/length based on object type
			_local quantity << _self.get_quantity_from_record(rec)
			_if quantity _is _unset _orif quantity = 0
			_then
				_continue
			_endif

			# Add or accumulate in result
			_self.add_to_boq_result(result, code, quantity)
		_endloop

		# Special handling for sling_wire (not in change_set)
		_self.add_sling_wire_to_result(result)

		write("LOG: BoQ generation complete. Total item types:", result.size)

		_return result
	_when error
		write("LOG: ERROR generating BoQ:", errCond.report_contents_string)
		condition.raise(:user_error, :string, errCond)
	_endtry
_endmethod
$

# ============================================================================
# Helper Methods for Single-Pass Generation
# ============================================================================

_private _method rwwi_astri_boq_generator.normalize_infra_type(infra_type)
	## Normalize infrastructure type to match fttx_network_type field values
	## Parameters:
	##   infra_type - Input type (cluster, subfeeder, feeder)
	## Returns: Normalized type string

	_local type << infra_type.default("cluster").lowercase

	_if type = "cluster"
	_then
		_return "Cluster"
	_elif type = "subfeeder"
	_then
		_return "Sub Feeder"
	_elif type = "feeder"
	_then
		_return "Feeder"
	_else
		_return "Cluster"
	_endif
_endmethod
$

_private _method rwwi_astri_boq_generator.get_quantity_from_record(rec)
	## Extract quantity or length from a design record
	## Parameters:
	##   rec - Design record
	## Returns:
	##   Numeric quantity/length or _unset

	_local col_name << rec.source_collection.name

	# For cables (sheath_with_loc) - return length in meters
	_if col_name _is :sheath_with_loc
	_then
		write("Getting length for sheath_with_loc ID:", rec.id)
		_if rec.responds_to?(:calculated_fiber_length)
		_then
			_return rec.calculated_fiber_length.value_in(:m).as_number()
		_endif
	_endif

	# For all other objects - return count of 1
	_return 1
_endmethod
$

_private _method rwwi_astri_boq_generator.get_infra_code_field_name()
	## Returns the field name for infrastructure code based on infra_type
	## Returns: symbol (:cluster_code, :subfeeder_code, or :feeder_code)

	_if .infra_type = "cluster"
	_then
		_return :cluster_code
	_elif .infra_type = "subfeeder" _orif .infra_type = "sub feeder"
	_then
		_return :subfeeder_code
	_elif .infra_type = "feeder"
	_then
		_return :feeder_code
	_else
		# Default to cluster_code
		_return :cluster_code
	_endif
_endmethod
$

_private _method rwwi_astri_boq_generator.create_boq_item(code, material_qty, service_qty)
	## Create a BoQ item property_list from catalog using code
	## Parameters:
	##   code - Material code string (stf_item_code, e.g., "200001033")
	##   material_qty - Quantity for :material slot (or _unset)
	##   service_qty - Quantity for :service slot (or _unset)
	## Returns:
	##   property_list with BoQ item data in ASTRI API format

	_try _with errCond
		write("Starting BoQ item creation for code:", code)
		_local catalog_entry << _self.MATERIAL_CATALOG[code]
		_if catalog_entry _is _unset
		_then
			write("LOG: ERROR - Unknown material code:", code)
			condition.raise(:user_error, :string,
				write_string("Unknown material code: ", code))
		_endif

		# Determine which slot gets which quantity
		_local mat_value << 0
		_local svc_value << 0

		_local slot_type << catalog_entry[:material_slot]
		_if slot_type = :material
		_then
			mat_value << material_qty
			svc_value << service_qty
		_elif slot_type = :service
		_then
			mat_value << service_qty
			svc_value << material_qty
		_endif

		# Create property list with ASTRI API format
		# Get values from boq_params (set during initialization)

		# Get the appropriate infrastructure code field name
		_local infra_code_field << _self.get_infra_code_field_name()

		_local item << property_list.new_with(
			:cluster_code, .boq_params[infra_code_field],  # Dynamic based on infra_type
			:vendor_name, .boq_params[:vendor_name],
			:subcont_vendor_name, .boq_params[:subcont_vendor_name],
			:equipment_code, code,                    # stf_item_code
			:equipment_name, catalog_entry[:name],    # Description from catalog
			:description, catalog_entry[:name],       # Default: "Project Management"
			:quantity_material, mat_value,
			:quantity_service, svc_value,
			:remarks, .boq_params[:remarks],          # Default: "Service"
			:phase, .boq_params[:phase],              # Default: "project_opname"
			:area, .boq_params[:area],
			:area_plant_code, .boq_params[:area_plant_code],
			:override_price_material, .boq_params[:override_price_material],
			:override_price_service, .boq_params[:override_price_service]
		)

		_return item
	_when error
		write("LOG: ERROR creating BoQ item:", errCond.report_contents_string)
		condition.raise(:user_error, :string, errCond)
	_endtry
_endmethod
$

_private _method rwwi_astri_boq_generator.add_to_boq_result(result, code, qty)
	## Add or accumulate BOQ item in result property_list
	## Parameters:
	##   result - property_list to update
	##   code - material code string
	##   qty - quantity to add (will be placed in correct slot based on catalog)

	_local existing << result[code.as_symbol()]
	_local catalog_entry << _self.MATERIAL_CATALOG[code]
	_local slot_type << catalog_entry[:material_slot]
	# Determine which parameter to pass based on slot type
	_local mat_val << _unset
	_local svc_val << _unset

	_if slot_type = :material
	_then
		mat_val << qty
	_elif slot_type = :service
	_then
		svc_val << qty
	_endif

	_if existing _is _unset
	_then
		# Create new BOQ item
		_local item << _self.create_boq_item(code.write_string, mat_val, svc_val)
		result[code.as_symbol()] << item
	_else
		# Accumulate to existing item
		_if slot_type = :material
		_then
			_local current << existing[:quantity_material]
			_if current _is _unset
			_then
				existing[:quantity_material] << qty
			_else
				existing[:quantity_material] << current + qty
			_endif
		_elif slot_type = :service
		_then
			_local current << existing[:quantity_service]
			_if current _is _unset
			_then
				existing[:quantity_service] << qty
			_else
				existing[:quantity_service] << current + qty
			_endif
		_endif
	_endif
_endmethod
$

_private _method rwwi_astri_boq_generator.add_sling_wire_to_result(result)
	## Query sling_wire objects from area/project and add to result
	## Sling wires are not in change_set, so need special query

	_try _with errCond
		write("LOG: Querying sling_wire objects...")

		_local total_length << 0
		_local sling_col << .dataset.collections[:sling_wire]

		_if sling_col _is _unset
		_then
			write("LOG: WARNING - sling_wire collection not found")
			_return
		_endif

		# Query sling_wire in design area
		_local area << .scheme.project.project_areas.an_element().area
		_if area _is _unset
		_then
			write("LOG: WARNING - No project area defined for scheme")
			_return
		_endif

		_local pred << predicate.interacts(:route, area)
		_local sling_wires << sling_col.select(pred)
	
		_local filter_type << _self.normalize_infra_type(.infra_type)

		_for sw _over sling_wires.fast_elements()
		_loop
			# Only count Proposed sling wires with matching infra type
			_if sw.responds_to?(:construction_status) _andif
			    sw.construction_status = "Proposed"
			_then
				# Check infrastructure type
				#_if sw.responds_to?(:fttx_network_type)
				#_then
				#	_local sw_type << sw.fttx_network_type.default("").lowercase
				#	_if sw_type <> filter_type
				#	_then
				#		_continue
				#	_endif
				#_endif

				_local length << sw.route.line_length / 100  # Convert cm to m
				total_length +<< length
			_endif
		_endloop

		_if total_length > 0
		_then
			# Sling wire code is "200001033", material_slot is :service
			_self.add_to_boq_result(result, "200001033", total_length)
			write("LOG: Sling wire total length:", total_length, "m")
		_endif

	_when error
		write("LOG: ERROR querying sling_wire:", errCond.report_contents_string)
	_endtry
_endmethod
$
