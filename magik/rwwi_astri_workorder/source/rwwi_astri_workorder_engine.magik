#% text_encoding = iso8859_1

_package user
$

## ASTRI Work Order Engine
## Data access layer for work order retrieval from API and database

remex(:rwwi_astri_workorder_engine)
$

def_slotted_exemplar(:rwwi_astri_workorder_engine,
{
	{:vda,         _unset, :writable},   # View/Design Admin (dataset)
	{:dialog,      _unset, :writable},   # Parent dialog reference
	{:current_source, :api, :writable},  # Current data source (:api or :db)
	{:cache,       _unset, :writable},   # Cached data
	{:db_connection, _unset, :writable}  # PostgreSQL database connection
}, :engine_model)
$

_pragma(classify_level=debug, topic={astri_integration})
## SQL queries for retrieving KMZ UUID and source from PostgreSQL database
## Returns both the UUID and the source (ABD or APD)
## Logic: If abd_kmz_uuid exists, use it and return 'ABD', otherwise use apd_kmz_uuid and return 'APD'
rwwi_astri_workorder_engine.define_shared_constant(:sql_for_kmz_uuid,
	property_list.new_with(
		:cluster, "SELECT COALESCE(abd_kmz_uuid, apd_kmz_uuid) AS kmz_uuid, CASE WHEN abd_kmz_uuid IS NOT NULL THEN 'ABD' ELSE 'APD' END AS kmz_source, cluster_code, subfeeder_code, feeder_code, olt_code FROM smallworld.dim_cluster_master_smallworld WHERE cluster_code = ? LIMIT 1",
		:subfeeder, "SELECT COALESCE(abd_kmz_uuid, apd_kmz_uuid) AS kmz_uuid, CASE WHEN abd_kmz_uuid IS NOT NULL THEN 'ABD' ELSE 'APD' END AS kmz_source, subfeeder_code, feeder_code, olt_code FROM smallworld.dim_subfeeder_master_smallworld WHERE subfeeder_code = ? LIMIT 1",
		:feeder, "SELECT COALESCE(abd_kmz_uuid, apd_kmz_uuid) AS kmz_uuid, CASE WHEN abd_kmz_uuid IS NOT NULL THEN 'ABD' ELSE 'APD' END AS kmz_source, feeder_code, olt_code FROM smallworld.dim_feeder_master_smallworld WHERE feeder_code = ? LIMIT 1"
	),
	_false
)
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.new()
	## Create new engine instance
	>> _clone.init()
_endmethod
$

_private _method rwwi_astri_workorder_engine.init()
	## Initialize engine

	.vda << gis_program_manager.cached_dataset(:design_admin)
	.cache << property_list.new()

	>> _super.init()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.get_workorders_from_api(
		infrastructure_type, limit, offset, _optional filters)
	## Get work orders from ASTRI API
	##
	## Parameters:
	##   infrastructure_type (string) - Infrastructure type: "cluster", "subfeeder", or "feeder"
	##   limit (integer) - Maximum records to retrieve
	##   offset (integer) - Starting offset
	##   filters (property_list) - Optional filters:
	##     Common filters:
	##       :category_name - Category filter (e.g., "cluster_boq", "subfeeder_boq", "feeder_boq")
	##       :latest_status_name - Status filter (e.g., "in_progress")
	##       :assigned_vendor_name - Vendor name filter
	##     Infrastructure-specific filters:
	##       For cluster: :target_cluster_topology, :target_cluster_code
	##       For subfeeder: :target_subfeeder_code
	##       For feeder: :target_osp_route_area
	##
	## Returns:
	##   rope of property_lists with work order data
	##
	## Note: Filters use API field names (not label fields)
	## Note: Demo mode - Prepends dummy data with KMZ UUID for testing
	write(@FILTER, infrastructure_type, limit, offset)
	print(filters)

	_try _with cond
		# Call Java @MagikProc global procedure - now returns XML as Magik string
		# Uses POST method internally
		xml_result << astri_get_work_orders(infrastructure_type, limit, offset, filters)

		_if xml_result _is _unset _orif xml_result = ""
		_then
			condition.raise(:astri_workorder!api_call_failed,
				:api_name, "astri_get_work_orders",
				:error_message, "Empty response from API")
			_return rope.new()
		_endif

		# Convert to string if needed (handles both Magik string and java_string)
		_if xml_result.is_kind_of?(char16_vector)
		_then
			# Already a Magik string
			write("XML result is Magik string (char16_vector)")
		_else
			# Convert java_string or other types
			write("XML result type:", xml_result.class_name, "- converting to string")
			xml_result << xml_result.write_string
		_endif

		# Parse XML response using simple_xml
		workorders << _self.parse_xml_response(xml_result, infrastructure_type)

		# DEMO MODE: Prepend dummy data with KMZ UUID (filtered by infrastructure type)
		#dummy_data << _self.create_dummy_workorder_data(infrastructure_type)
		#_if dummy_data _isnt _unset _andif dummy_data.size > 0
		#_then
		#	write("=== DEMO MODE: Adding ", dummy_data.size, " dummy work orders (", infrastructure_type, ") as first records ===")
			# Create new rope with dummy data first, then API results
		#	combined_rope << rope.new()
		#	combined_rope.add_all_last(dummy_data)
		#	combined_rope.add_all_last(workorders)
		#	workorders << combined_rope
		#_endif

		# Cache the result
		.cache[:last_api_result] << workorders
		.cache[:last_api_time] << date_time.now()

		_return workorders

	_when error
		write("ERROR in get_workorders_from_api():", cond.report_contents_string)
		write("  Infrastructure type:", infrastructure_type)
		write("  Limit:", limit, "| Offset:", offset)
		write("  Filters:", filters)
		condition.raise(:astri_workorder!api_call_failed,
			:api_name, "astri_get_work_orders",
			:error_message, cond.report_contents_string)
		_return rope.new()
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_engine.create_dummy_workorder_data(infrastructure_type)
	## Create dummy work order data for demo/testing purposes
	##
	## Parameters:
	##   infrastructure_type (string) - Infrastructure type: "cluster", "subfeeder", or "feeder"
	##
	## Returns:
	##   rope of property_lists - Dummy work orders filtered by infrastructure type
	##
	## Demo Data Specification:
	##   Feeder:    WO/PLB/2025/DEMO/10101, PLB10101, ffa84dd4-8128-47dc-aabc-6c7e216c1cd3
	##   Subfeeder: WO/PLB/2025/DEMO/10102, PLB10102, e8932c87-e0f6-42d3-81c2-4a05fbd673af
	##   Cluster:   WO/PLB/2025/DEMO/10103, PLB10103, 4ea5751b-ba8b-4771-86df-1d0225fddc0f
	##              WO/JKT/2025/DEMO/00001, JKT00001, 2989eecc-3fd0-402c-bd81-99e02caa7ef5

	_try
		_local result_rope << rope.new()

		# Return dummy data based on infrastructure type
		_if infrastructure_type = "feeder"
		_then
			# Feeder work order
			_local feeder << property_list.new_with(
				# Primary identifiers
				:uuid, "demo-wo-10101",
				:wo_number, "WO/PLB/2025/DEMO/10101",

				# KMZ UUID for download testing
				:kmz_uuid, "ffa84dd4-8128-47dc-aabc-6c7e216c1cd3",

				# Infrastructure information
				:infra_code, "PLB10101",
				:infra_name, "FEEDER PLB10101 - Demo Feeder Network",
				:topology, "",  # No topology for feeder

				# Work order metadata
				:category, "Feeder BOQ",
				:status, "in_progress",
				:vendor, "Demo Feeder Vendor Ltd",

				# Timestamps
				:created_at, date_time.now().write_string)

			result_rope.add(feeder)

		_elif infrastructure_type = "subfeeder"
		_then
			# Subfeeder work order
			_local subfeeder << property_list.new_with(
				# Primary identifiers
				:uuid, "demo-wo-10102",
				:wo_number, "WO/PLB/2025/DEMO/10102",

				# KMZ UUID for download testing
				:kmz_uuid, "e8932c87-e0f6-42d3-81c2-4a05fbd673af",

				# Infrastructure information
				:infra_code, "PLB10102",
				:infra_name, "SUBFEEDER PLB10102 - Demo Subfeeder Network",
				:topology, "",  # No topology for subfeeder

				# Work order metadata
				:category, "Subfeeder BOQ",
				:status, "in_progress",
				:vendor, "Demo Subfeeder Vendor Ltd",

				# Timestamps
				:created_at, date_time.now().write_string)

			result_rope.add(subfeeder)

		_elif infrastructure_type = "cluster"
		_then
			# Cluster work order
			_local cluster << property_list.new_with(
				# Primary identifiers
				:uuid, "demo-wo-10103",
				:wo_number, "WO/PLB/2025/DEMO/10103",

				# KMZ UUID for download testing
				:kmz_uuid, "4ea5751b-ba8b-4771-86df-1d0225fddc0f",

				# Infrastructure information
				:infra_code, "PLB10103",
				:infra_name, "CLUSTER PLB10103 - Demo Cluster Network",
				:topology, "AE",  # Cluster has topology

				# Work order metadata
				:category, "Cluster BOQ",
				:status, "in_progress",
				:vendor, "Demo Cluster Vendor Ltd",

				# Timestamps
				:created_at, date_time.now().write_string)

			result_rope.add(cluster)

			# Legacy cluster work order (for backward compatibility)
			_local legacy << property_list.new_with(
				# Primary identifiers
				:uuid, "demo-wo-00001",
				:wo_number, "WO/JKT/2025/DEMO/00001",

				# KMZ UUID for download testing
				:kmz_uuid, "2989eecc-3fd0-402c-bd81-99e02caa7ef5",

				# Infrastructure information
				:infra_code, "JKT00001",
				:infra_name, "PRE ABD_KEBON PALA RW 09_873 HP",
				:topology, "AE",  # Cluster has topology

				# Work order metadata
				:category, "Cluster BOQ",
				:status, "in_progress",
				:vendor, "Demo Feeder Vendor Ltd",

				# Timestamps
				:created_at, date_time.now().write_string)

			result_rope.add(legacy)
		_endif

		write("Created ", result_rope.size, " dummy work orders for infrastructure type: ", infrastructure_type)
		_for wo _over result_rope.fast_elements()
		_loop
			write("  ", wo[:wo_number], " (", wo[:infra_code], ") - KMZ: ", wo[:kmz_uuid])
		_endloop

		_return result_rope

	_when error
		write("ERROR in create_dummy_workorder_data():", condition.report_contents_string)
		write("  Infrastructure type:", infrastructure_type)
		_return rope.new()
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.parse_xml_response(xml_string, infrastructure_type)
	## Parse XML string response to rope of property_lists
	##
	## Parameters:
	##   xml_string (string) - XML response from API
	##   infrastructure_type (string) - Infrastructure type: "cluster", "subfeeder", or "feeder"
	##
	## Expected XML structure:
	## <response>
	##   <success>true</success>
	##   <count>50</count>
	##   <count_all>127</count_all>
	##   <data>
	##     <workorder>
	##       <uuid>d35ed679-0b5e-4c33-953c-2740b5cc7772</uuid>
	##       <number>WO/ALL/2025/DOCU/16/54556</number>
	##       <target_[infra]_code>MNA000033</target_[infra]_code>
	##       <target_[infra]_name>PADANG SIALANG RT 01, 02, 03...</target_[infra]_name>
	##       <category_label>Cluster BOQ</category_label>
	##       <latest_status_name>in_progress</latest_status_name>
	##       <target_[infra]_topology>AE</target_[infra]_topology>
	##       <assigned_vendor_label>Yangtze Optical Fible and Cable</assigned_vendor_label>
	##       <created_at>2025-10-28 14:28:08</created_at>
	##     </workorder>
	##   </data>
	## </response>

	_local result_rope << rope.new()
	_global xmls
	xmls << xml_string
	_try _with cond
		# Parse XML using simple_xml
		_local xml_root << simple_xml.read_element_string(xml_string)
		 xml_doc_g << xml_root

		# Check for error response
		_local error_elem << xml_root.element_matching_name(:error)
		_if error_elem _isnt _unset
		_then
			_local error_msg << error_elem.elements.an_element()
			write("API returned error:", error_msg)
			>> result_rope
		_endif

		# Get data element
		_local data_elem << xml_root.element_matching_name(:data)
		_if data_elem _is _unset
		_then
			write("WARNING: No 'data' element found in XML response")
			>> result_rope
		_endif

		# Build field names dynamically based on infrastructure type
		# cluster:   target_cluster_code, target_cluster_name, target_cluster_topology,
		#            target_cluster_area, target_cluster_area_plant_code
		# subfeeder: target_subfeeder_code, target_subfeeder_name (no topology),
		#            target_subfeeder_area, target_subfeeder_area_plant_code
		# feeder:    target_osp_route_code, target_osp_route_name (no topology),
		#            target_osp_route_area, target_osp_route_area_plant_code, target_osp_route_asset_number
		_local code_field << _if infrastructure_type = "feeder"
		                     _then >> :target_osp_route_code
		                     _else >> write_string("target_", infrastructure_type, "_code").as_symbol()
		                     _endif
		_local name_field << _if infrastructure_type = "feeder"
		                     _then >> :target_osp_route_name
		                     _else >> write_string("target_", infrastructure_type, "_name").as_symbol()
		                     _endif

		# Topology field only exists for cluster infrastructure type
		_local topology_field << _if infrastructure_type = "cluster"
		                         _then >> write_string("target_", infrastructure_type, "_topology").as_symbol()
		                         _else >> _unset
		                         _endif

		# Area and area_plant_code fields for all infrastructure types
		_local area_field << _if infrastructure_type = "cluster"
		                     _then >> :target_cluster_area
		                     _elif infrastructure_type = "subfeeder"
		                     _then >> :target_subfeeder_area
		                     _elif infrastructure_type = "feeder"
		                     _then >> :target_osp_route_area
		                     _else >> _unset
		                     _endif

		_local area_plant_code_field << _if infrastructure_type = "cluster"
		                                _then >> :target_cluster_area_plant_code
		                                _elif infrastructure_type = "subfeeder"
		                                _then >> :target_subfeeder_area_plant_code
		                                _elif infrastructure_type = "feeder"
		                                _then >> :target_osp_route_area_plant_code
		                                _else >> _unset
		                                _endif

		# Asset number field only for feeder infrastructure type
		_local asset_number_field << _if infrastructure_type = "feeder"
		                             _then >> :target_osp_route_asset_number
		                             _else >> _unset
		                             _endif

		# OLT name and label fields for all infrastructure types
		_local olt_name_field << _if infrastructure_type = "cluster"
		                         _then >> :target_cluster_olt_name
		                         _elif infrastructure_type = "subfeeder"
		                         _then >> :target_subfeeder_olt_name
		                         _elif infrastructure_type = "feeder"
		                         _then >> :target_osp_route_olt_name
		                         _else >> _unset
		                         _endif

		_local olt_label_field << _if infrastructure_type = "cluster"
		                          _then >> :target_cluster_olt_label
		                          _elif infrastructure_type = "subfeeder"
		                          _then >> :target_subfeeder_olt_label
		                          _elif infrastructure_type = "feeder"
		                          _then >> :target_osp_route_olt_label
		                          _else >> _unset
		                          _endif

		# Iterate through workorder elements
		_for wo_elem _over data_elem.elements_matching_name(:workorder)
		_loop
			_local pl << property_list.new()
			# Extract all work order fields
			pl[:uuid] << _self.get_xml_element_value(wo_elem, :uuid)
			pl[:wo_number] << _self.get_xml_element_value(wo_elem, :number)

			# Extract infrastructure-specific fields using dynamic field names
			# Note: Using :infra_code as the key for all infrastructure types (cluster, subfeeder, feeder)
			_local infra_code << _self.get_xml_element_value(wo_elem, code_field)
			_local infra_name << _self.get_xml_element_value(wo_elem, name_field)

			pl[:infra_code] << infra_code
			pl[:infra_name] << infra_name

			# Extract topology only for cluster infrastructure type
			pl[:topology] << _if topology_field _isnt _unset
			                 _then >> _self.get_xml_element_value(wo_elem, topology_field)
			                 _else >> ""
			                 _endif

			pl[:category] << _self.get_xml_element_value(wo_elem, :category_label)
			pl[:status] << _self.get_xml_element_value(wo_elem, :latest_status_name)
			pl[:vendor] << _self.get_xml_element_value(wo_elem, :assigned_vendor_label)
			pl[:vendor_name] << _self.get_xml_element_value(wo_elem, :assigned_vendor_name)
			pl[:subcont_vendor] << _self.get_xml_element_value(wo_elem, :assigned_subcont_vendor_name)
			pl[:created_at] << _self.get_xml_element_value(wo_elem, :created_at)

			# Extract area and area_plant_code fields
			pl[:area] << _if area_field _isnt _unset
			             _then >> _self.get_xml_element_value(wo_elem, area_field)
			             _else >> ""
			             _endif

			pl[:area_plant_code] << _if area_plant_code_field _isnt _unset
			                        _then >> _self.get_xml_element_value(wo_elem, area_plant_code_field)
			                        _else >> ""
			                        _endif

			# Extract asset_number for feeder infrastructure type only
			pl[:asset_number] << _if asset_number_field _isnt _unset
			                     _then >> _self.get_xml_element_value(wo_elem, asset_number_field)
			                     _else >> ""
			                     _endif

			# Extract OLT name and label fields
			pl[:olt_name] << _if olt_name_field _isnt _unset
			                 _then >> _self.get_xml_element_value(wo_elem, olt_name_field)
			                 _else >> ""
			                 _endif

			pl[:olt_label] << _if olt_label_field _isnt _unset
			                  _then >> _self.get_xml_element_value(wo_elem, olt_label_field)
			                  _else >> ""
			                  _endif

			# Retrieve KMZ UUID, source, and infrastructure codes from PostgreSQL database
			_local db_result << _self.get_kmz_uuid_from_db(infrastructure_type, infra_code)

			# Add all database fields to property list (all fields always present with defaults)
			pl[:kmz_uuid] << db_result[:kmz_uuid].default("")
			pl[:kmz_source] << db_result[:kmz_source].default("")
			pl[:cluster_code_db] << db_result[:cluster_code].default("")
			pl[:subfeeder_code_db] << db_result[:subfeeder_code].default("")
			pl[:feeder_code_db] << db_result[:feeder_code].default("")
			pl[:olt_code] << db_result[:olt_code].default("")
						  
			result_rope.add(pl)
		_endloop

		_if .db_connection _isnt _unset 
		_then
			write("close connection")
			extdb_java_acp.close_all()
			.db_connection << _unset 
		_endif


		_return result_rope

	_when error
		_if .db_connection _isnt _unset 
		_then
			write("close connection")
			extdb_java_acp.close_all()
			.db_connection << _unset 
		_endif

		write("ERROR in parse_xml_response():", cond.report_contents_string)
		write("  Infrastructure type:", infrastructure_type)
		_local max_len << 100.min(xml_string.size)
		_local xml_preview << xml_string.subseq(1, max_len)
		write("  XML preview (first 100 chars):", xml_preview)
		condition.raise(:astri_workorder!xml_parse_error,
			:xml_string, xml_preview)
		_return rope.new()
	_endtry
_endmethod
$

_private _method rwwi_astri_workorder_engine.get_xml_element_value(parent_elem, element_name)
	## Extract text value from XML element
	## Unescapes backslash-escaped forward slashes (e.g., \/ becomes /)
	##
	## Parameters:
	##   parent_elem (simple_xml_thing) - Parent XML element
	##   element_name (string) - Name of child element to extract
	##
	## Returns:
	##   string - Element text value or empty string

	_try
		_local elem << parent_elem.element_matching_name(element_name)
		_if elem _is _unset
		_then
			_return ""
		_endif

		_local value << elem.xml_result
		
		# Remove backslash escaping from forward slashes
		# Replace "\/" with "/"
		_if value _isnt _unset _andif value <> ""
		_then
			value << value.substitute_string("\/", "/")
		_endif

		_if value = "null"
		_then
			value << _unset 
		_endif

		_return value

	_when error
		_return ""
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.get_workorders_from_db(_optional filters)
	## Get work orders from database where construction_status = true
	##
	## Parameters:
	##   filters (property_list) - Optional filters
	##
	## Returns:
	##   rope of property_lists with work order data

	_local result_rope << rope.new()

	_try _with cond
		# Access work order collection in database
		# This assumes a work_order table exists with construction_status field

		_if .vda _is _unset
		_then
			write("WARNING: vda (design_admin) not initialized")
			_return result_rope
		_endif

		_local wo_col << .vda.collections[:work_order]

		_if wo_col _is _unset
		_then
			write("WARNING: work_order collection not found in database")
			_return result_rope
		_endif

		# Predicate for construction status
		_local pred << predicate.eq(:construction_status, _true)

		# Apply additional filters if provided
		_if filters _isnt _unset
		_then
			_if filters[:category_name] _isnt _unset
			_then
				pred << pred _and predicate.eq(:category_name, filters[:category_name])
			_endif

			_if filters[:latest_status_name] _isnt _unset
			_then
				pred << pred _and predicate.eq(:latest_status_name, filters[:latest_status_name])
			_endif
		_endif

		# Query database
		_for wo_rec _over wo_col.select(pred).fast_elements()
		_loop
			wo << property_list.new_with(
				:uuid, wo_rec.uuid,
				:wo_number, wo_rec.number,
				:infra_code, wo_rec.target_cluster_code,
				:infra_name, wo_rec.target_cluster_name,
				:category, wo_rec.category_label,
				:status, wo_rec.latest_status_name,
				:topology, wo_rec.target_cluster_topology,
				:vendor, wo_rec.assigned_vendor_label,
				:created_at, wo_rec.created_at,
				:construction_status, wo_rec.construction_status)

			result_rope.add(wo)
		_endloop

		>> result_rope

	_when error
		write("ERROR in get_workorders_from_db():", cond.report_contents_string)
		write("  Filters:", filters)
		condition.raise(:astri_workorder!db_query_failed,
			:query, "work_order collection query",
			:error_message, cond.report_contents_string)
		>> rope.new()
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.mark_as_construction(wo_uuid)
	## Mark work order as under construction in database
	##
	## Parameters:
	##   wo_uuid (string) - Work order UUID
	##
	## Returns:
	##   boolean - success flag

	_try _with cond
		_local wo_col << .vda.collections[:work_order]

		_if wo_col _is _unset
		_then
			write("WARNING: work_order collection not found")
			_return _false
		_endif

		# Find work order by UUID
		_local pred << predicate.eq(:uuid, wo_uuid)
		_local wo_rec << wo_col.select(pred).an_element()

		_if wo_rec _is _unset
		_then
			write("WARNING: Work order not found:", wo_uuid)
			_return _false
		_endif

		# Update construction status
		wo_rec.construction_status << _true
		wo_rec.updated_at << date_time.now()

		write("Work order marked as construction:", wo_uuid)
		>> _true

	_when error
		write("ERROR in mark_as_construction():", cond.report_contents_string)
		write("  Work order UUID:", wo_uuid)
		>> _false
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.get_kmz_uuid_from_db(infrastructure_type, code)
	## Retrieve KMZ UUID, source, and infrastructure codes from PostgreSQL database
	##
	## Parameters:
	##   infrastructure_type (string) - "cluster", "subfeeder", or "feeder"
	##   code (string) - Infrastructure code to search
	##
	## Returns:
	##   property_list with keys:
	##     :kmz_uuid, :kmz_source (always returned)
	##     For cluster: :cluster_code, :subfeeder_code, :feeder_code, :olt_code
	##     For subfeeder: :subfeeder_code, :feeder_code, :olt_code
	##     For feeder: :feeder_code, :olt_code
	##   Returns property_list with empty values if not found
	##
	## Database Tables:
	##   cluster:   dim_cluster_master_smallworld.cluster_code
	##   subfeeder: dim_subfeeder_master_smallworld.subfeeder_code
	##   feeder:    dim_feeder_master_smallworld.feeder_code
	##
	## Priority Logic:
	##   If abd_kmz_uuid exists, returns (abd_kmz_uuid, "ABD")
	##   Otherwise returns (apd_kmz_uuid, "APD")

	_try _with cond
		# Validate inputs
		_if code _is _unset _orif code = ""
		_then
			_return property_list.new_with(
				:kmz_uuid, "",
				:kmz_source, "",
				:cluster_code, "",
				:subfeeder_code, "",
				:feeder_code, "",
				:olt_code, "")
		_endif

		# Establish database connection if not already connected
		_if .db_connection _is _unset
		_then
		_global connect?, db_connection

			_local is_connect?
			(is_connect?, .db_connection) << user:rwwi_external_ds_manager.open_connection_for("[POSTGRESQL_ASTRI_DB]")
			(connect?, db_connection)	<< (is_connect?, .db_connection)
			_if _not is_connect?
			_then
				write("WARNING: Failed to connect to POSTGRESQL_ASTRI_DB")
				_return property_list.new_with(
					:kmz_uuid, "",
					:kmz_source, "",
					:cluster_code, "",
					:subfeeder_code, "",
					:feeder_code, "",
					:olt_code, "")
			_endif
			write("Connected to POSTGRESQL_ASTRI_DB for KMZ UUID retrieval")
		_endif

		# Get SQL query for infrastructure type
		_local sql_query << _self.sql_for_kmz_uuid[infrastructure_type.as_symbol()]

		_if sql_query _is _unset
		_then
			write("WARNING: No SQL query defined for infrastructure type:", infrastructure_type)
			_return property_list.new_with(
				:kmz_uuid, "",
				:kmz_source, "",
				:cluster_code, "",
				:subfeeder_code, "",
				:feeder_code, "",
				:olt_code, "")
		_endif

		# Execute query (following rwi_pni_to_tenoss pattern)
		_local recs << .db_connection.sql_select(sql_query, code)
		_local rec << recs.get()

		# Initialize result with all possible fields set to empty strings
		_local result << property_list.new_with(
			:kmz_uuid, "",
			:kmz_source, "",
			:cluster_code, "",
			:subfeeder_code, "",
			:feeder_code, "",
			:olt_code, "")

		_if rec _isnt _unset
		_then
			# Extract common fields (always returned)
			result[:kmz_uuid] << rec.kmz_uuid.default("")
			result[:kmz_source] << rec.kmz_source.default("")

			# Extract infrastructure-specific fields based on type
			_if infrastructure_type = "cluster"
			_then
				result[:cluster_code] << rec.cluster_code.default("")
				result[:subfeeder_code] << rec.subfeeder_code.default("")
				result[:feeder_code] << rec.feeder_code.default("")
				result[:olt_code] << rec.olt_code.default("")
			_elif infrastructure_type = "subfeeder"
			_then
				result[:subfeeder_code] << rec.subfeeder_code.default("")
				result[:feeder_code] << rec.feeder_code.default("")
				result[:olt_code] << rec.olt_code.default("")
			_elif infrastructure_type = "feeder"
			_then
				result[:feeder_code] << rec.feeder_code.default("")
				result[:olt_code] << rec.olt_code.default("")
			_endif
		_else
			# No record found - all fields already initialized to empty strings
			write("No KMZ UUID found for ", infrastructure_type, " code ", code)
		_endif

		recs.close()

		# Commit or rollback to clean transaction state
		_try
			.db_connection.commit()
		_when error
			.db_connection.rollback()
		_endtry

		_return result

	_when error
		write("ERROR in get_kmz_uuid_from_db():", cond.report_contents_string)
		write("  Infrastructure type:", infrastructure_type)
		write("  Code:", code)

		# Rollback transaction to clear error state
		_if .db_connection _isnt _unset
		_then
			_try
				.db_connection.rollback()
				write("Transaction rolled back due to error")
			_when error
				# Ignore rollback errors
			_endtry
		_endif

		_return property_list.new_with(
			:kmz_uuid, "",
			:kmz_source, "",
			:cluster_code, "",
			:subfeeder_code, "",
			:feeder_code, "",
			:olt_code, "")
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.close_db_connection()
	## Close PostgreSQL database connection
	##
	## Should be called when:
	##   - Dialog is closed
	##   - Session is ending
	##   - Database connection is no longer needed

	_try
		_if .db_connection _isnt _unset
		_then
			.db_connection.rollback()
			.db_connection.close()
			.db_connection << _unset
			write("Database connection closed")
		_endif
	_when error
		# Ignore cleanup errors
		write("WARNING: Error closing database connection (ignored):", condition.report_contents_string)
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.get_project_by_name(project_name)
	## Get project by name from design admin
	##
	## Parameters:
	##   project_name (string) - Project name to search for
	##
	## Returns:
	##   swg_dsn_project - Project record, or _unset if not found

	_try _with errCond
		_if project_name _is _unset _orif project_name = ""
		_then
			_return _unset
		_endif

		_if .vda _is _unset
		_then
			write("LOG: ERROR - design_admin dataset not available")
			_return _unset
		_endif

		_local project_col << .vda.collections[:swg_dsn_project]
		_local project << project_col.select(predicate.eq(:name, project_name)).an_element()

		_return project

	_when error
		write("LOG: ERROR getting project by name:", errCond.report_contents_string)
		_return _unset
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.check_project_and_design_exist(wo_number)
	## Check if project and design exist in Smallworld for work order number
	##
	## Parameters:
	##   wo_number (string) - Work order number (project name)
	##
	## Returns:
	##   (boolean, boolean) - (has_project?, has_design?)

	_try _with errCond
		_if wo_number _is _unset _orif wo_number = ""
		_then
			_return _false, _false
		_endif

		# Get project by name
		_local project << _self.get_project_by_name(wo_number)
		_if project _is _unset
		_then
			_return _false, _false
		_endif

		# Check if project has any schemes (designs)
		_local schemes << project.top_schemes
		_if schemes _is _unset _orif schemes.empty?
		_then
			_return _true, _false
		_endif

		# Project and design exist
		_return _true, _true

	_when error
		write("LOG: ERROR checking project/design:", errCond.report_contents_string)
		_return _false, _false
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.get_design_for_project(project_name)
	## Get first design (scheme) for project
	##
	## Parameters:
	##   project_name (string) - Project name
	##
	## Returns:
	##   swg_dsn_scheme - Design scheme, or _unset if not found

	_try _with errCond
		_local project << _self.get_project_by_name(project_name)
		_if project _is _unset
		_then
			write("LOG: ERROR - Project not found:", project_name)
			_return _unset
		_endif

		_local scheme << project.top_schemes.an_element()
		_if scheme _is _unset
		_then
			write("LOG: ERROR - No design found in project:", project_name)
			_return _unset
		_endif

		_return scheme

	_when error
		write("LOG: ERROR getting design for project:", errCond.report_contents_string)
		_return _unset
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.activate_design(project_name)
	## Activate design for given project name
	##
	## Parameters:
	##   project_name (string) - Project name (typically wo_number)
	##
	## Returns:
	##   swg_dsn_scheme - Activated scheme, or _unset if failed

	_try _with errCond
		_local scheme << _self.get_design_for_project(project_name)
		_if scheme _is _unset
		_then
			_return _unset
		_endif

		# Activate the design using swg_dsn_admin_engine
		write("Activating design:", scheme.name, "(ID:", scheme.id, ")")
		swg_dsn_admin_engine.activate_design(scheme)

		_return scheme

	_when error
		write("LOG: ERROR activating design:", errCond.report_contents_string)
		_return _unset
	_endtry
_endmethod
$
_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_engine.get_design_boundary(design)
	## Extract boundary polygon from design
	##
	## Parameters:
	##   design - Smallworld design object
	##
	## Returns:
	##   pseudo_polygon - Design boundary area for spatial filtering

	_try _with errCond
		# Get from project boundary
		l_project << design.project
		_for a _over l_project.project_areas.fast_elements() 
		_loop
			_if a.area _isnt _unset 
			_then
				_return a.area
			_endif
		_endloop

		write("WARNING: No boundary found for design:", design.name)
		_return _unset

	_when error
		write("Error getting design boundary:", errCond.report_contents_string)
		_return _unset
	_endtry
_endmethod
$
