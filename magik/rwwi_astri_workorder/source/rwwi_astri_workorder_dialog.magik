#% text_encoding = iso8859_1

_package user
$

## ASTRI Work Order Dialog
## UI layer for work order management using SW_SWIFT components

remex(:rwwi_astri_workorder_dialog)
$

def_slotted_exemplar(:rwwi_astri_workorder_dialog,
{
	{:engine,     _unset, :writable},       # Engine instance
	{:items,      _unset, :writable},       # UI components cache
	{:plugin,     _unset, :writable},       # Parent plugin
	{:filters,    _unset, :writable},       # Current filter values
	{:selected_wo, _unset, :writable},      # Currently selected work order
	{:wo_cache,   _unset, :writable}        # Cache to store work orders by row number
}, :model)
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.new(plugin)
	## Create new dialog
	>> _clone.init(plugin)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.init(plugin)
	## Initialize dialog

	.plugin << plugin
	.engine << rwwi_astri_workorder_engine.new()
	.engine.dialog << _self
	.items << property_list.new()
	.filters << property_list.new()
	.wo_cache << equality_hash_table.new()

	# Initialize default filters
	.filters[:source] << :api
	.filters[:infrastructure_type] << "cluster"
	.filters[:limit] << 50
	.filters[:offset] << 0

	>> _super.init()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.activate_in(frame)
	## Build and activate UI in frame using SW_SWIFT components

	frame.title << "ASTRI Work Order Manager"

	# Create top-level sw_canvas_container (required for SWIFT)
	.items[:top] << top_c << sw_canvas_container.new(
		frame, 3, 1,
		:width, 900,
		:height, 600,
		:outer_spacing, 5,
		:row_spacing, 5,
		:identifier, :top_container,
		:model, _self)

	# Create outer container with flexible row sizing
	# 4 rows: Toolbar (fixed), Table (flexible), Text Window (flexible), Detail Panel (fixed)
	.items[:outer] << outer << sw_container.new(top_c, 4, 1,
		:row_resize_values, {0, 1, 1, 0})  # Toolbar fixed, Table flexible, Text Window flexible, Detail fixed

	# Build toolbar with filters
	_self.build_toolbar(outer)

	# Build work order table
	_self.build_table(outer)

	# Build text window for process logs and statistics
	_self.build_text_window(outer)

	# Build detail panel (buttons only)
	_self.build_detail_panel(outer)

	# Initial data load
	_self.changed(:workorder_list, :refresh)

	# Return the top-level container (required)
	_return top_c
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_toolbar(parent)
	## Build toolbar with source selector and filters using SW_SWIFT components

	# Create sw_toolbar_container with separator styling
	toolbar_con << sw_toolbar_container.new(parent, _false,
		:background_type, :container,
		:show_separators?, _true,
		:enable_action_menu?, _false)

	# Get the actual toolbar to add items to
	a_toolbar << toolbar_con.create_toolbar()

	# Row 1: Refresh button, Source selector, Record count
	sw_button_item.new(a_toolbar,
		:image, {:refresh, :ui_resources},
		:model, _self,
		:selector, :refresh_data|()|,
		:tooltip, "Refresh work order data")

	sw_label_item.new(a_toolbar, "  Source:  ")

	.items[:source] << sw_text_item.new(a_toolbar,
		:model, _self,
		:display_length, 25,
		:editable?, _false,
		:change_selector, {:|source_selection()|})
	.items[:source].text_items << {"ASTRI API", "Database (Construction)"}
	.items[:source].value << "ASTRI API"

	.items[:record_count] << sw_label_item.new(a_toolbar, "  Total Records: 0  ")

	# Create second toolbar for filters
	filter_toolbar << toolbar_con.create_toolbar()

	sw_label_item.new(filter_toolbar, "  Filters:  ")

	sw_label_item.new(filter_toolbar, "Infrastructure:  ")
	.items[:filter_infrastructure] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 12,
		:editable?, _false,
		:change_selector, {:|infrastructure_type_changed()|})
	.items[:filter_infrastructure].text_items << {"cluster", "subfeeder", "feeder"}
	.items[:filter_infrastructure].value << "cluster"

	sw_label_item.new(filter_toolbar, "  Category:  ")
	.items[:filter_category] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 15,
		:editable?, _false)
	.items[:filter_category].text_items << {"All", "Cluster BOQ", "Installation", "Maintenance"}
	.items[:filter_category].value << "All"

	sw_label_item.new(filter_toolbar, "  Status:  ")
	.items[:filter_status] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 15,
		:editable?, _false)
	.items[:filter_status].text_items << {"All", "new", "in_progress", "closed", "cancelled", "successful"}
	.items[:filter_status].value << "All"

	.items[:label_topology] << sw_label_item.new(filter_toolbar, "  Topology:  ")
	.items[:filter_topology] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 10,
		:editable?, _false)
	.items[:filter_topology].text_items << {"All", "AE", "UG", "OH"}
	.items[:filter_topology].value << "All"

	# Create third toolbar for cluster filter and pagination
	pagination_toolbar << toolbar_con.create_toolbar()

	.items[:label_code] << sw_label_item.new(pagination_toolbar, "  Cluster Code:  ")
	.items[:filter_cluster] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 20,
		:editable?, _true)

	sw_label_item.new(pagination_toolbar, "  Limit:  ")
	.items[:filter_limit] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 5,
		:editable?, _false)
	.items[:filter_limit].text_items << {"10", "25", "50", "100", "200"}
	.items[:filter_limit].value << "50"

	sw_label_item.new(pagination_toolbar, "  Offset:  ")
	.items[:filter_offset] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 8,
		:editable?, _true)
	.items[:filter_offset].value << "0"

	sw_button_item.new(pagination_toolbar,
		:label, "Apply Filters",
		:model, _self,
		:selector, :apply_filters|()|,
		:tooltip, "Apply current filters")
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_table(parent)
	## Build work order table using sw_table

	# Create sw_table with proper configuration
	.items[:table] << sw_table.new(parent,
		:row_height, 22,
		:selection_type, :row,
		:selection_mode, :one,
		:model, _self,
		:aspect, :workorder_list,
		:row_lines?, _true,
		:column_lines?, _true,
		:row_stripes?, _true,
		:data_selector, :|workorder_list_data()|,
		:selection_notifier, :workorder_selection|()|,
		:enable_manage_columns?, _true,
		:min_height, 300)

	# Set column labels
	.items[:table].set_column_labels({
		"No", "WO Number", "Infra Code", "Name",
		"Category", "Status", "Topology", "Vendor", "Area", "Area Plant Code", "Created", "KMZ UUID", "KML Source"})

	# Set column resize values (relative widths)
	.items[:table].col_resize_values << {0, 2, 1.5, 3, 1.5, 1.5, 1, 2.5, 1.5, 1.5, 1.5, 2, 0.8}

	# Enable column filtering
	.items[:table].enable_column_filter(2, _true)  # WO Number
	.items[:table].enable_column_filter(3, _true)  # Infra Code
	.items[:table].enable_column_filter(4, _true)  # Name
	.items[:table].enable_column_filter(6, _true)  # Status

	# Enable sorting after columns are configured
	.items[:table].enable_sort? << _true

	# Set selection notifier - receives (table, selection_rope) as arguments
	#.items[:table].selection_notifier << {:|workorder_selection()|, _self, _unset, _unset}
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_text_window(parent)
	## Build text window for displaying process logs and statistics
	## Shows migration progress, BOQ generation status, and work order details

	# Create sw_text_window component
	.items[:text_window] << sw_text_window.new(parent)
	.items[:text_window].show_border? << _true
	.items[:text_window].enable_horizontal_scrollbar? << _false
	.items[:text_window].enable_vertical_scrollbar? << _true
	.items[:text_window].min_height << 150
	.items[:text_window].editable? << _false  # Read-only

	# Set initial welcome message
	_self.log_info("ASTRI Work Order Manager - Ready")
	_self.log_info("=" * 80)
	_self.log_info("Select a work order from the table above to view details and perform actions.")
	_self.log_info("")
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_detail_panel(parent)
	## Build detail panel with action buttons only
	## Work order details are now shown in the text window above

	# Action buttons container - single row with horizontal layout
	button_con << sw_container.new(parent, 1, _unset,
		:outer_spacing, 5,
		:col_spacing, 10)

	# Removed "View Details" button - details now show automatically on row selection

	.items[:kmz_btn] << sw_button_item.new(button_con,
		:label, "Download KMZ",
		:model, _self,
		:selector, :download_kmz|()|)
	.items[:kmz_btn].enabled? << _false

	.items[:migrate_design_btn] << sw_button_item.new(button_con,
		:label, "Migrate to Design",
		:model, _self,
		:selector, :migrate_to_design|()|)
	.items[:migrate_design_btn].enabled? << _false

	.items[:migrate_existing_btn] << sw_button_item.new(button_con,
		:label, "Migrate Existing (ABD)",
		:model, _self,
		:selector, :migrate_existing|()|)
	.items[:migrate_existing_btn].enabled? << _false

	.items[:boq_excel_btn] << sw_button_item.new(button_con,
		:label, "Generate BoQ as Excel",
		:model, _self,
		:selector, :generate_boq_excel|()|)
	.items[:boq_excel_btn].enabled? << _false

	.items[:boq_json_btn] << sw_button_item.new(button_con,
		:label, "Generate BoQ as JSON",
		:model, _self,
		:selector, :generate_boq_json|()|)
	.items[:boq_json_btn].enabled? << _false

	# NEW: Export KML button
	.items[:export_kml_btn] << sw_button_item.new(button_con,
		:label, "Export Smallworld KML",
		:model, _self,
		:selector, :export_smallworld_kml|()|)
	.items[:export_kml_btn].enabled? << _false
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_info(message)
	## Write informational message to text window
	##
	## Parameters:
	##   message (string) - Message to display
	##
	## Example:
	##   _self.log_info("Starting migration process...")

	_if .items[:text_window] _isnt _unset
	_then
		_local current_text << .items[:text_window].text.default("")
		_local new_text << current_text + message + %newline
		.items[:text_window].text << new_text

		# Auto-scroll to bottom
		.items[:text_window].goto_line_end()
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_success(message)
	## Write success message to text window with formatting
	##
	## Parameters:
	##   message (string) - Success message to display

	_self.log_info("[SUCCESS] " + message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_error(message)
	## Write error message to text window with formatting
	##
	## Parameters:
	##   message (string) - Error message to display

	_self.log_info("[ERROR] " + message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_warning(message)
	## Write warning message to text window with formatting
	##
	## Parameters:
	##   message (string) - Warning message to display

	_self.log_info("[WARNING] " + message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_separator()
	## Write separator line to text window for visual grouping

	_self.log_info("=" * 80)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.clear_log()
	## Clear all text from the text window

	_if .items[:text_window] _isnt _unset
	_then
		.items[:text_window].text << ""
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.workorder_list_data()
	## Populate table with work order data using sw_table methods

	_try
		# Clear cache before populating new data
		.wo_cache.empty()

		# Get data from engine based on current source
		_local workorders << _if .filters[:source] _is :api
		_then
			>> .engine.get_workorders_from_api(
				.filters[:infrastructure_type].default("cluster"),
				.filters[:limit],
				.filters[:offset],
				_self.build_filter_params())
		_else
			>> .engine.get_workorders_from_db(_self.build_filter_params())
		_endif

		# Populate table using sw_table methods
		_local row << 0
		_for wo _over workorders.fast_elements()
		_loop
			row +<< 1
			# Add cells to table
			.items[:table].add_label(row, 1, row.write_string)
			.items[:table].add_label(row, 2, wo[:wo_number].default(""))
			.items[:table].add_label(row, 3, wo[:infra_code].default(""))
			.items[:table].add_label(row, 4, wo[:infra_name].default(""))
			.items[:table].add_label(row, 5, wo[:category].default(""))
			.items[:table].add_label(row, 6, wo[:status].default(""))
			.items[:table].add_label(row, 7, wo[:topology].default(""))
			.items[:table].add_label(row, 8, wo[:vendor].default(""))
			.items[:table].add_label(row, 9, wo[:area].default(""))
			.items[:table].add_label(row, 10, wo[:area_plant_code].default(""))
			.items[:table].add_label(row, 11, wo[:created_at].default(""))
			.items[:table].add_label(row, 12, wo[:kmz_uuid].default(""))
			.items[:table].add_label(row, 13, wo[:kmz_source].default(""))

			# Store work order data in cache by row number
			.wo_cache[row] << wo
		_endloop

		# Update record count
		.items[:record_count].value << write_string("  Total Records: ", row, "  ")

	_when error
		write("ERROR in workorder_list_data:", condition.report_contents_string)
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.refresh_data()
	## Refresh table data from current source

	write("Refreshing work order data...")
	_self.changed(:workorder_list, :renew)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.source_selection()
	## Handle source dropdown change

	_local source_text << .items[:source].value

	.filters[:source] << _if source_text = "ASTRI API"
	_then
		>> :api
	_else
		>> :db
	_endif

	write("Source changed to:", .filters[:source])
	_self.refresh_data()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.infrastructure_type_changed()
	## Handle infrastructure type selection change
	## Update UI elements based on selected infrastructure type

	_local infra_type << .items[:filter_infrastructure].value.default("cluster")

	write("Infrastructure type changed to:", infra_type)

	# Update label text and topology visibility based on infrastructure type
	_if infra_type = "cluster"
	_then
		# Cluster: show topology, label = "Cluster Code"
		.items[:label_code].label << "  Cluster Code:  "
		.items[:label_topology].managed? << _true
		.items[:filter_topology].managed? << _true
		.items[:filter_topology].enabled? << _true

	_elif infra_type = "subfeeder"
	_then
		# Subfeeder: hide topology, label = "Subfeeder Code"
		.items[:label_code].label << "  Subfeeder Code:  "
		.items[:label_topology].managed? << _false
		.items[:filter_topology].managed? << _false
		.items[:filter_topology].enabled? << _false

	_elif infra_type = "feeder"
	_then
		# Feeder: hide topology, label = "OSP Route Area"
		.items[:label_code].label << "  OSP Route Area:  "
		.items[:label_topology].managed? << _false
		.items[:filter_topology].managed? << _false
		.items[:filter_topology].enabled? << _false
	_endif

	# Update the stored infrastructure type in filters
	.filters[:infrastructure_type] << infra_type
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.apply_filters()
	## Apply current filter selections

	write("Applying filters...")

	# Update filters from UI
	.filters[:infrastructure_type] << .items[:filter_infrastructure].value.default("cluster")

	_local limit_str << .items[:filter_limit].value
	.filters[:limit] << limit_str.as_number().default(10)

	_local offset_str << .items[:filter_offset].value
	.filters[:offset] << offset_str.as_number().default(0)

	# Refresh data with new filters
	_self.refresh_data()
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_filter_params()
	## Build filter property list from UI controls

	_local filters << property_list.new()

	# Get current infrastructure type
	_local infra_type << .items[:filter_infrastructure].value.default("cluster")

	# Category filter
	_local category << .items[:filter_category].value
	_if category _isnt _unset _and category <> "All"
	_then
		# Map display label to API field name
		_local category_map << equality_hash_table.new_with(
			"Cluster BOQ", "cluster_boq",
			"Installation", "installation",
			"Maintenance", "maintenance")

		_local category_name << category_map[category]
		_if category_name _isnt _unset
		_then
			filters[:category_name] << category_name
		_endif
	_endif

	# Status filter
	_local status << .items[:filter_status].value
	_if status _isnt _unset _and status <> "All"
	_then
		filters[:latest_status_name] << status
	_endif

	# Topology filter (only for cluster infrastructure type)
	_if infra_type = "cluster"
	_then
		_local topology << .items[:filter_topology].value
		_if topology _isnt _unset _and topology <> "All"
		_then
			# Dynamic field name: target_cluster_topology
			_local topology_field << write_string("target_", infra_type, "_topology").as_symbol()
			filters[topology_field] << topology
		_endif
	_endif

	# Infrastructure code filter (dynamic based on infrastructure type)
	_local code_value << .items[:filter_cluster].value
	_if code_value _isnt _unset _and code_value.size > 0
	_then
		# Dynamic field name based on infrastructure type:
		# - cluster:   target_cluster_code
		# - subfeeder: target_subfeeder_code
		# - feeder:    target_osp_route_area (NOT target_feeder_code)
		_local code_field << _if infra_type = "feeder"
		                     _then >> :target_osp_route_area
		                     _else >> write_string("target_", infra_type, "_code").as_symbol()
		                     _endif
		filters[code_field] << code_value
	_endif

	_return filters
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.workorder_selection(table, selection)
	## Handle work order selection in table
	##
	## Parameters:
	##   table (sw_table) - The table widget
	##   selection (rope) - Rope of selected row numbers

	_if selection _is _unset _orif selection.size = 0
	_then
		.selected_wo << _unset
		_self.update_detail_panel(_unset)
		_return
	_endif
	_local selected_row << selection.an_element()
	_local wo << .wo_cache[selected_row]

	.selected_wo << wo
	_self.update_detail_panel(wo)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.update_detail_panel(wo)
	## Update text window and button states with selected work order information
	## Displays comprehensive work order details automatically when row is selected

	_if wo _is _unset
	_then
		# Disable all buttons but don't clear log (preserve process results)
		.items[:kmz_btn].enabled? << _false
		.items[:migrate_design_btn].enabled? << _false
		.items[:migrate_existing_btn].enabled? << _false
		.items[:boq_excel_btn].enabled? << _false
		.items[:boq_json_btn].enabled? << _false
		.items[:export_kml_btn].enabled? << _false
	_else
		# Display comprehensive work order details in text window WITHOUT clearing previous logs
		# This preserves process execution results while showing current selection

		# Get KMZ information for button state and display
		_local kmz_uuid << wo[:kmz_uuid]
		_local kmz_source << wo[:kmz_source].default("")
		_local has_kmz << kmz_uuid _isnt _unset _andif kmz_uuid <> ""
		_local is_abd << kmz_source = "ABD"

		# Build comprehensive details message with proper alignment
		_local msg << write_string(
			%newline,
			"=" * 80, %newline,
			"SELECTED WORK ORDER DETAILS", %newline,
			"=" * 80, %newline, %newline,

			"BASIC INFORMATION:", %newline,
			"  WO Number	: ", wo[:wo_number].default("N/A"), %newline,
			"  UUID		    :", wo[:uuid].default("N/A"), %newline,
			"  Category		: ", wo[:category].default("N/A"), %newline,
			"  Status		: ", wo[:status].default("N/A"), %newline)

		# Add timestamps if available
		_if wo[:created_at] _isnt _unset _andif wo[:created_at] <> ""
		_then
			msg << msg + write_string("  Created At       : ", wo[:created_at], %newline)
		_endif

		_if wo[:updated_at] _isnt _unset _andif wo[:updated_at] <> ""
		_then
			msg << msg + write_string("  Updated At       : ", wo[:updated_at], %newline)
		_endif

		# Infrastructure information
		msg << msg + write_string(
			%newline,
			"INFRASTRUCTURE INFORMATION:", %newline,
			"  Code             : ", wo[:infra_code].default("N/A"), %newline,
			"  Name             : ", wo[:infra_name].default("N/A"), %newline,
			"  Type             : ", .filters[:infrastructure_type].default("N/A"), %newline)

		# Add optional infrastructure fields
		_if wo[:topology] _isnt _unset _andif wo[:topology] <> ""
		_then
			msg << msg + write_string("  Topology         : ", wo[:topology], %newline)
		_endif

		_if wo[:olt_name] _isnt _unset _andif wo[:olt_name] <> ""
		_then
			msg << msg + write_string("  OLT Name         : ", wo[:olt_name], %newline)
		_endif

		_if wo[:olt_label] _isnt _unset _andif wo[:olt_label] <> ""
		_then
			msg << msg + write_string("  OLT Label        : ", wo[:olt_label], %newline)
		_endif

		msg << msg + write_string(
			"  Area             : ", wo[:area].default("N/A"), %newline,
			"  Area Plant Code  : ", wo[:area_plant_code].default("N/A"), %newline)

		# Vendor information
		msg << msg + write_string(
			%newline,
			"VENDOR INFORMATION:", %newline,
			"  Vendor Name      : ", wo[:vendor_name].default("N/A"), %newline,
			"  Vendor Label     : ", wo[:vendor].default("N/A"), %newline)

		_if wo[:subcont_vendor] _isnt _unset _andif wo[:subcont_vendor] <> ""
		_then
			msg << msg + write_string("  Subcontractor    : ", wo[:subcont_vendor], %newline)
		_endif

		# KMZ information
		msg << msg + write_string(
			%newline,
			"KMZ INFORMATION:", %newline)

		_if has_kmz
		_then
			msg << msg + write_string(
				"  KMZ UUID         : ", kmz_uuid, %newline,
				"  KML Source       : ", kmz_source, %newline,
				"  Migration Status : Available", %newline)
		_else
			msg << msg + write_string(
				"  KMZ UUID         : Not Available", %newline,
				"  Migration Status : Not Available", %newline)
		_endif

		msg << msg + write_string(
			%newline,
			"=" * 80, %newline,
			"Use the buttons below to perform actions on this work order.", %newline)

		# Display message in single log call
		_self.log_info(msg)

		# Enable buttons based on work order state
		.items[:kmz_btn].enabled? << has_kmz
		.items[:migrate_design_btn].enabled? << has_kmz

		# Enable migrate_existing only for ABD KML sources
		.items[:migrate_existing_btn].enabled? << has_kmz _and is_abd

		# Enable BoQ and KML export buttons only if project and design exist
		_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
		.items[:boq_excel_btn].enabled? << has_project _and has_design
		.items[:boq_json_btn].enabled? << has_project _and has_design
		.items[:export_kml_btn].enabled? << has_project _and has_design
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.refresh_button_states()
	## Refresh button enable states for currently selected work order
	## Useful after migration completes to enable BoQ buttons

	_if .selected_wo _isnt _unset
	_then
		write("Refreshing button states for WO:", .selected_wo[:wo_number])
		_self.update_detail_panel(.selected_wo)
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.user_info(message)
	## Display informational message to user

	write("INFO:", message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.user_error(message)
	## Display error message to user

	write("ERROR:", message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
