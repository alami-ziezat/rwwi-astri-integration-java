#% text_encoding = iso8859_1

_package user
$

## ASTRI Work Order Dialog
## UI layer for work order management using SW_SWIFT components

remex(:rwwi_astri_workorder_dialog)
$

def_slotted_exemplar(:rwwi_astri_workorder_dialog,
{
	{:engine,     _unset, :writable},       # Engine instance
	{:items,      _unset, :writable},       # UI components cache
	{:plugin,     _unset, :writable},       # Parent plugin
	{:filters,    _unset, :writable},       # Current filter values
	{:selected_wo, _unset, :writable},      # Currently selected work order
	{:wo_cache,   _unset, :writable}        # Cache to store work orders by row number
}, :model)
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.new(plugin)
	## Create new dialog
	>> _clone.init(plugin)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.init(plugin)
	## Initialize dialog

	.plugin << plugin
	.engine << rwwi_astri_workorder_engine.new()
	.engine.dialog << _self
	.items << property_list.new()
	.filters << property_list.new()
	.wo_cache << equality_hash_table.new()

	# Initialize default filters
	.filters[:source] << :api
	.filters[:infrastructure_type] << "cluster"
	.filters[:limit] << 50
	.filters[:offset] << 0

	>> _super.init()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.activate_in(frame)
	## Build and activate UI in frame using SW_SWIFT components

	frame.title << "ASTRI Work Order Manager"

	# Create top-level sw_canvas_container (required for SWIFT)
	.items[:top] << top_c << sw_canvas_container.new(
		frame, 3, 1,
		:width, 900,
		:height, 600,
		:outer_spacing, 5,
		:row_spacing, 5,
		:identifier, :top_container,
		:model, _self)

	# Create outer container with flexible row sizing
	.items[:outer] << outer << sw_container.new(top_c, 3, 1,
		:row_resize_values, {0, 1, 0})  # Toolbar fixed, Table flexible, Detail fixed

	# Build toolbar with filters
	_self.build_toolbar(outer)

	# Build work order table
	_self.build_table(outer)

	# Build detail panel
	_self.build_detail_panel(outer)

	# Initial data load
	_self.changed(:workorder_list, :refresh)

	# Return the top-level container (required)
	_return top_c
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_toolbar(parent)
	## Build toolbar with source selector and filters using SW_SWIFT components

	# Create sw_toolbar_container with separator styling
	toolbar_con << sw_toolbar_container.new(parent, _false,
		:background_type, :container,
		:show_separators?, _true,
		:enable_action_menu?, _false)

	# Get the actual toolbar to add items to
	a_toolbar << toolbar_con.create_toolbar()

	# Row 1: Refresh button, Source selector, Record count
	sw_button_item.new(a_toolbar,
		:image, {:refresh, :ui_resources},
		:model, _self,
		:selector, :refresh_data|()|,
		:tooltip, "Refresh work order data")

	sw_label_item.new(a_toolbar, "  Source:  ")

	.items[:source] << sw_text_item.new(a_toolbar,
		:model, _self,
		:display_length, 25,
		:editable?, _false,
		:change_selector, {:|source_selection()|})
	.items[:source].text_items << {"ASTRI API", "Database (Construction)"}
	.items[:source].value << "ASTRI API"

	.items[:record_count] << sw_label_item.new(a_toolbar, "  Total Records: 0  ")

	# Create second toolbar for filters
	filter_toolbar << toolbar_con.create_toolbar()

	sw_label_item.new(filter_toolbar, "  Filters:  ")

	sw_label_item.new(filter_toolbar, "Infrastructure:  ")
	.items[:filter_infrastructure] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 12,
		:editable?, _false,
		:change_selector, {:|infrastructure_type_changed()|})
	.items[:filter_infrastructure].text_items << {"cluster", "subfeeder", "feeder"}
	.items[:filter_infrastructure].value << "cluster"

	sw_label_item.new(filter_toolbar, "  Category:  ")
	.items[:filter_category] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 15,
		:editable?, _false)
	.items[:filter_category].text_items << {"All", "Cluster BOQ", "Installation", "Maintenance"}
	.items[:filter_category].value << "All"

	sw_label_item.new(filter_toolbar, "  Status:  ")
	.items[:filter_status] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 15,
		:editable?, _false)
	.items[:filter_status].text_items << {"All", "new", "in_progress", "closed", "cancelled", "successful"}
	.items[:filter_status].value << "All"

	.items[:label_topology] << sw_label_item.new(filter_toolbar, "  Topology:  ")
	.items[:filter_topology] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 10,
		:editable?, _false)
	.items[:filter_topology].text_items << {"All", "AE", "UG", "OH"}
	.items[:filter_topology].value << "All"

	# Create third toolbar for cluster filter and pagination
	pagination_toolbar << toolbar_con.create_toolbar()

	.items[:label_code] << sw_label_item.new(pagination_toolbar, "  Cluster Code:  ")
	.items[:filter_cluster] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 20,
		:editable?, _true)

	sw_label_item.new(pagination_toolbar, "  Limit:  ")
	.items[:filter_limit] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 5,
		:editable?, _false)
	.items[:filter_limit].text_items << {"10", "25", "50", "100", "200"}
	.items[:filter_limit].value << "50"

	sw_label_item.new(pagination_toolbar, "  Offset:  ")
	.items[:filter_offset] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 8,
		:editable?, _true)
	.items[:filter_offset].value << "0"

	sw_button_item.new(pagination_toolbar,
		:label, "Apply Filters",
		:model, _self,
		:selector, :apply_filters|()|,
		:tooltip, "Apply current filters")
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_table(parent)
	## Build work order table using sw_table

	# Create sw_table with proper configuration
	.items[:table] << sw_table.new(parent,
		:row_height, 22,
		:selection_type, :row,
		:selection_mode, :one,
		:model, _self,
		:aspect, :workorder_list,
		:row_lines?, _true,
		:column_lines?, _true,
		:row_stripes?, _true,
		:data_selector, :|workorder_list_data()|,
		:selection_notifier, :workorder_selection|()|,
		:enable_manage_columns?, _true,
		:min_height, 300)

	# Set column labels
	.items[:table].set_column_labels({
		"No", "WO Number", "Infra Code", "Name",
		"Category", "Status", "Topology", "Vendor", "Area", "Area Plant Code", "Created", "KMZ UUID", "KML Source"})

	# Set column resize values (relative widths)
	.items[:table].col_resize_values << {0, 2, 1.5, 3, 1.5, 1.5, 1, 2.5, 1.5, 1.5, 1.5, 2, 0.8}

	# Enable column filtering
	.items[:table].enable_column_filter(2, _true)  # WO Number
	.items[:table].enable_column_filter(3, _true)  # Infra Code
	.items[:table].enable_column_filter(4, _true)  # Name
	.items[:table].enable_column_filter(6, _true)  # Status

	# Enable sorting after columns are configured
	.items[:table].enable_sort? << _true

	# Set selection notifier - receives (table, selection_rope) as arguments
	#.items[:table].selection_notifier << {:|workorder_selection()|, _self, _unset, _unset}
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_detail_panel(parent)
	## Build detail panel for selected work order

	write("build_detail_panel")
	detail_con << sw_container.new(parent, _unset, 1,
		:outer_spacing, 5,
		:row_spacing, 3)

	sw_label_item.new(detail_con, "Selected Work Order Details:")

	.items[:detail_uuid] << sw_label_item.new(detail_con, "UUID: ")
	.items[:detail_cluster] << sw_label_item.new(detail_con, "Cluster: ")
	.items[:detail_vendor] << sw_label_item.new(detail_con, "Vendor: ")
	.items[:detail_info] << sw_label_item.new(detail_con, "Info: ")

	# Action buttons container
	button_con << sw_container.new(detail_con, 1, _unset,
		:col_spacing, 10)

	.items[:detail_btn] << sw_button_item.new(button_con,
		:label, "View Details",
		:model, _self,
		:selector, :view_details|()|)
	.items[:detail_btn].enabled? << _false

	.items[:kmz_btn] << sw_button_item.new(button_con,
		:label, "Download KMZ",
		:model, _self,
		:selector, :download_kmz|()|)
	.items[:kmz_btn].enabled? << _false

	.items[:migrate_design_btn] << sw_button_item.new(button_con,
		:label, "Migrate to Design",
		:model, _self,
		:selector, :migrate_to_design|()|)
	.items[:migrate_design_btn].enabled? << _false

	.items[:migrate_existing_btn] << sw_button_item.new(button_con,
		:label, "Migrate Existing (ABD)",
		:model, _self,
		:selector, :migrate_existing|()|)
	.items[:migrate_existing_btn].enabled? << _false

	.items[:boq_excel_btn] << sw_button_item.new(button_con,
		:label, "Generate BoQ as Excel",
		:model, _self,
		:selector, :generate_boq_excel|()|)
	.items[:boq_excel_btn].enabled? << _false

	.items[:boq_json_btn] << sw_button_item.new(button_con,
		:label, "Generate BoQ as JSON",
		:model, _self,
		:selector, :generate_boq_json|()|)
	.items[:boq_json_btn].enabled? << _false
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.workorder_list_data()
	## Populate table with work order data using sw_table methods

	_try
		# Clear cache before populating new data
		.wo_cache.empty()

		# Get data from engine based on current source
		_local workorders << _if .filters[:source] _is :api
		_then
			>> .engine.get_workorders_from_api(
				.filters[:infrastructure_type].default("cluster"),
				.filters[:limit],
				.filters[:offset],
				_self.build_filter_params())
		_else
			>> .engine.get_workorders_from_db(_self.build_filter_params())
		_endif

		# Populate table using sw_table methods
		_local row << 0
		_for wo _over workorders.fast_elements()
		_loop
			row +<< 1

			# Add cells to table
			.items[:table].add_label(row, 1, row.write_string)
			.items[:table].add_label(row, 2, wo[:wo_number].default(""))
			.items[:table].add_label(row, 3, wo[:infra_code].default(""))
			.items[:table].add_label(row, 4, wo[:infra_name].default(""))
			.items[:table].add_label(row, 5, wo[:category].default(""))
			.items[:table].add_label(row, 6, wo[:status].default(""))
			.items[:table].add_label(row, 7, wo[:topology].default(""))
			.items[:table].add_label(row, 8, wo[:vendor].default(""))
			.items[:table].add_label(row, 9, wo[:area].default(""))
			.items[:table].add_label(row, 10, wo[:area_plant_code].default(""))
			.items[:table].add_label(row, 11, wo[:created_at].default(""))
			.items[:table].add_label(row, 12, wo[:kmz_uuid].default(""))
			.items[:table].add_label(row, 13, wo[:kmz_source].default(""))

			# Store work order data in cache by row number
			.wo_cache[row] << wo
		_endloop

		# Update record count
		.items[:record_count].value << write_string("  Total Records: ", row, "  ")

	_when error
		write("ERROR in workorder_list_data:", condition.report_contents_string)
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.refresh_data()
	## Refresh table data from current source

	write("Refreshing work order data...")
	_self.changed(:workorder_list, :renew)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.source_selection()
	## Handle source dropdown change

	_local source_text << .items[:source].value

	.filters[:source] << _if source_text = "ASTRI API"
	_then
		>> :api
	_else
		>> :db
	_endif

	write("Source changed to:", .filters[:source])
	_self.refresh_data()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.infrastructure_type_changed()
	## Handle infrastructure type selection change
	## Update UI elements based on selected infrastructure type

	_local infra_type << .items[:filter_infrastructure].value.default("cluster")

	write("Infrastructure type changed to:", infra_type)

	# Update label text and topology visibility based on infrastructure type
	_if infra_type = "cluster"
	_then
		# Cluster: show topology, label = "Cluster Code"
		.items[:label_code].label << "  Cluster Code:  "
		.items[:label_topology].managed? << _true
		.items[:filter_topology].managed? << _true
		.items[:filter_topology].enabled? << _true

	_elif infra_type = "subfeeder"
	_then
		# Subfeeder: hide topology, label = "Subfeeder Code"
		.items[:label_code].label << "  Subfeeder Code:  "
		.items[:label_topology].managed? << _false
		.items[:filter_topology].managed? << _false
		.items[:filter_topology].enabled? << _false

	_elif infra_type = "feeder"
	_then
		# Feeder: hide topology, label = "OSP Route Area"
		.items[:label_code].label << "  OSP Route Area:  "
		.items[:label_topology].managed? << _false
		.items[:filter_topology].managed? << _false
		.items[:filter_topology].enabled? << _false
	_endif

	# Update the stored infrastructure type in filters
	.filters[:infrastructure_type] << infra_type
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.apply_filters()
	## Apply current filter selections

	write("Applying filters...")

	# Update filters from UI
	.filters[:infrastructure_type] << .items[:filter_infrastructure].value.default("cluster")

	_local limit_str << .items[:filter_limit].value
	.filters[:limit] << limit_str.as_number().default(10)

	_local offset_str << .items[:filter_offset].value
	.filters[:offset] << offset_str.as_number().default(0)

	# Refresh data with new filters
	_self.refresh_data()
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_filter_params()
	## Build filter property list from UI controls

	_local filters << property_list.new()

	# Get current infrastructure type
	_local infra_type << .items[:filter_infrastructure].value.default("cluster")

	# Category filter
	_local category << .items[:filter_category].value
	_if category _isnt _unset _and category <> "All"
	_then
		# Map display label to API field name
		_local category_map << equality_hash_table.new_with(
			"Cluster BOQ", "cluster_boq",
			"Installation", "installation",
			"Maintenance", "maintenance")

		_local category_name << category_map[category]
		_if category_name _isnt _unset
		_then
			filters[:category_name] << category_name
		_endif
	_endif

	# Status filter
	_local status << .items[:filter_status].value
	_if status _isnt _unset _and status <> "All"
	_then
		filters[:latest_status_name] << status
	_endif

	# Topology filter (only for cluster infrastructure type)
	_if infra_type = "cluster"
	_then
		_local topology << .items[:filter_topology].value
		_if topology _isnt _unset _and topology <> "All"
		_then
			# Dynamic field name: target_cluster_topology
			_local topology_field << write_string("target_", infra_type, "_topology").as_symbol()
			filters[topology_field] << topology
		_endif
	_endif

	# Infrastructure code filter (dynamic based on infrastructure type)
	_local code_value << .items[:filter_cluster].value
	_if code_value _isnt _unset _and code_value.size > 0
	_then
		# Dynamic field name based on infrastructure type:
		# - cluster:   target_cluster_code
		# - subfeeder: target_subfeeder_code
		# - feeder:    target_osp_route_area (NOT target_feeder_code)
		_local code_field << _if infra_type = "feeder"
		                     _then >> :target_osp_route_area
		                     _else >> write_string("target_", infra_type, "_code").as_symbol()
		                     _endif
		filters[code_field] << code_value
	_endif

	_return filters
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.workorder_selection(table, selection)
	## Handle work order selection in table
	##
	## Parameters:
	##   table (sw_table) - The table widget
	##   selection (rope) - Rope of selected row numbers

	_if selection _is _unset _orif selection.size = 0
	_then
		.selected_wo << _unset
		_self.update_detail_panel(_unset)
		_return
	_endif
	_local selected_row << selection.an_element()
	_local wo << .wo_cache[selected_row]

	.selected_wo << wo
	_self.update_detail_panel(wo)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.update_detail_panel(wo)
	## Update detail panel with selected work order

	_if wo _is _unset
	_then
		.items[:detail_uuid].value << "UUID: "
		.items[:detail_cluster].value << "Cluster: "
		.items[:detail_vendor].value << "Vendor: "
		.items[:detail_info].value << "Info: "

		.items[:detail_btn].enabled? << _false
		.items[:kmz_btn].enabled? << _false
		.items[:migrate_design_btn].enabled? << _false
		.items[:migrate_existing_btn].enabled? << _false
		.items[:boq_excel_btn].enabled? << _false
		.items[:boq_json_btn].enabled? << _false
	_else
		.items[:detail_uuid].value << write_string("UUID: ", wo[:uuid].default(""))
		.items[:detail_cluster].value << write_string("Cluster: ",
			wo[:infra_code].default(""), " - ", wo[:infra_name].default(""))
		.items[:detail_vendor].value << write_string("Vendor: ", wo[:vendor].default(""))
		.items[:detail_info].value << write_string("Topology: ", wo[:topology].default(""),
			"  |  Category: ", wo[:category].default(""),
			"  |  Status: ", wo[:status].default(""))

		# Always enable detail button
		.items[:detail_btn].enabled? << _true

		# Enable KMZ-related buttons only if kmz_uuid is present
		_local kmz_uuid << wo[:kmz_uuid]
		_local kmz_source << wo[:kmz_source].default("")
		_local has_kmz << kmz_uuid _isnt _unset _andif kmz_uuid <> ""
		_local is_abd << kmz_source = "ABD"

		.items[:kmz_btn].enabled? << has_kmz
		.items[:migrate_design_btn].enabled? << has_kmz

		# Enable migrate_existing only for ABD KML sources
		.items[:migrate_existing_btn].enabled? << has_kmz _and is_abd

		# Enable BoQ buttons only if project and design exist
		_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
		.items[:boq_excel_btn].enabled? << has_project _and has_design
		.items[:boq_json_btn].enabled? << has_project _and has_design
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.refresh_button_states()
	## Refresh button enable states for currently selected work order
	## Useful after migration completes to enable BoQ buttons

	_if .selected_wo _isnt _unset
	_then
		write("Refreshing button states for WO:", .selected_wo[:wo_number])
		_self.update_detail_panel(.selected_wo)
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.view_details()
	## View detailed information for selected work order
	## Displays all available fields from the API response

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local infra_type << .filters[:infrastructure_type].default("cluster")

	# Build comprehensive detail message
	_local msg << write_string(
		"=" * 70, %newline,
		"WORK ORDER DETAILS", %newline,
		"=" * 70, %newline, %newline,

		"Basic Information", %newline,
		"-" * 70, %newline,
		"WO Number:           ", wo[:wo_number].default("N/A"), %newline,
		"UUID:                ", wo[:uuid].default("N/A"), %newline,
		"Category:            ", wo[:category].default("N/A"), %newline,
		"Status:              ", wo[:status].default("N/A"), %newline,
		"Created:             ", wo[:created_at].default("N/A"), %newline,
		%newline,

		"Infrastructure Information (", infra_type.uppercase, ")", %newline,
		"-" * 70, %newline,
		"Code:                ", wo[:infra_code].default("N/A"), %newline,
		"Name:                ", wo[:infra_name].default("N/A"), %newline)

	# Add topology only if available (cluster infrastructure type)
	_if wo[:topology] _isnt _unset _andif wo[:topology] <> ""
	_then
		msg << msg + write_string(
			"Topology:            ", wo[:topology].default("N/A"), %newline)
	_endif

	# Add area information
	msg << msg + write_string(
		"Area:                ", wo[:area].default("N/A"), %newline,
		"Area Plant Code:     ", wo[:area_plant_code].default("N/A"), %newline)

	# Add asset number for feeder infrastructure type
	_if infra_type = "feeder" _andif wo[:asset_number] _isnt _unset _andif wo[:asset_number] <> ""
	_then
		msg << msg + write_string(
			"Asset Number:        ", wo[:asset_number].default("N/A"), %newline)
	_endif

	# Add OLT information
	msg << msg + write_string(
		"OLT Name:            ", wo[:olt_name].default("N/A"), %newline,
		"OLT Label:           ", wo[:olt_label].default("N/A"), %newline,
		%newline,

		"Vendor Information", %newline,
		"-" * 70, %newline,
		"Primary Vendor:      ", wo[:vendor].default("N/A"), %newline,
		"Subcontractor:       ", wo[:subcont_vendor].default("N/A"), %newline,
		%newline,

		"KMZ Information", %newline,
		"-" * 70, %newline,
		"KMZ UUID:            ", wo[:kmz_uuid].default("N/A"), %newline,
		"KML Source:          ", wo[:kmz_source].default("N/A"), %newline,
		%newline,
		"=" * 70)

	_self.user_info(msg)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.download_kmz()
	## Download KMZ file for selected work order using kmz_uuid

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	write("Downloading KMZ for UUID:", kmz_uuid)

	_try
		# Call ASTRI KMZ download API with kmz_uuid based on infrastructure type
		# astri_download_cluster_kmz(uuid, outputDir)
		# astri_download_subfeeder_kmz(uuid, outputDir)
		# astri_download_feeder_kmz(uuid, outputDir)
		_local output_dir << system.getenv("TEMP").default("C:\temp")
		_local infra_type << .filters[:infrastructure_type].default("cluster")
		write("infra type: ",infra_type)
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.user_error("Failed to download KMZ file")
			_return
		_endif

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    file_path_elem _isnt _unset
		_then
			_local file_path << file_path_elem.xml_result
			_self.user_info(write_string("KMZ downloaded successfully:", %newline, file_path))
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.user_error(write_string("Failed to download KMZ:", %newline, error_msg))
		_endif

	_when error
		_self.user_error(write_string("Error downloading KMZ:", %newline,
			condition.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.migrate_to_design()
	## Migrate KML data to real Smallworld design objects
	##
	## Uses file download approach (Scenario 2) to avoid large XML string issues

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	write("Migrating KML to Design objects for UUID:", kmz_uuid)

	_try _with errCon
		# Use Scenario 2: Download files to disk, then read KML file
		_local output_dir << system.getenv("TEMP").default("C:\temp")
		_local infra_type << .filters[:infrastructure_type].default("cluster")
		write("Infra type: ",infra_type)
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.user_error("Failed to download KML file")
			_return
		_endif

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local kml_file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    kml_file_path_elem _isnt _unset
		_then
			_local kml_file_path << kml_file_path_elem.xml_result
			write("KML file downloaded to:", kml_file_path)

			# Parse KML file using astri_kml_parser
			write("Parsing KML file...")
			_local parser << astri_kml_parser.new(kml_file_path)
			_local placemarks << parser.parse()

			write("KML parsing complete. Found", placemarks.size, "placemarks")

			# Prepare project and design names
			_local wo_number << wo[:wo_number].default("WO_" + kmz_uuid.subseq(1, 8))
			_local infra_code << wo[:infra_code].default("INFRA_" + kmz_uuid.subseq(1, 8))
			_local infra_name << wo[:infra_name].default("Infra_" + kmz_uuid.subseq(1, 8))
			_local infra_name_size << infra_name.size

			_if infra_name_size > 64
			_then
				infra_name << infra_name.subseq(infra_name_size-64, 64)
			_endif

			# Add infrastructure_type to work order property_list
			wo[:infrastructure_type] << .filters[:infrastructure_type].default("cluster")

			# Create design migrator - pass entire work order property_list
			write("Creating design migrator...")
			write("  Work Order: ", wo[:wo_number])
			write("  Infrastructure Type: ", wo[:infrastructure_type])
			write("  POP Name: ", wo[:olt_label].default(wo[:olt_name].default("Unknown")))
			write("  Region: ", wo[:area].default("Unknown"))
			write("  Infrastructure Name: ", wo[:infra_name].default("Unknown"))

			_local database << gis_program_manager.databases[:gis]

			_if database _is _unset
			_then
				_self.user_error("GIS database not available")
				_return
			_endif

			_local migrator << astri_design_migrator.new(database, wo)

			# Create project and design
			write("Initiate: Creating project and design...: ",infra_code," : ",infra_name)
			_local (project, scheme) << migrator.create_project_and_design(
				placemarks,     # Boundary extracted from placemarks
				wo_number,      # Project name
				infra_code,     # Project title
				infra_name      # Design name
			)

			# Migrate placemarks to design
			write("Migrating objects to design...")
			_local stats << migrator.migrate_placemarks(placemarks)

			# Display results
			_local total_objs << stats[:aerial_routes] + stats[:poles] + stats[:sheaths] +
			                      stats[:sling_wires] + stats[:demand_points] +
			                      stats[:micro_cells] + stats[:areas_created]

			_local msg << write_string(
				" >>> Design Migration Complete! <<<", %newline,
				"File: ", kml_file_path, %newline,
				"Project: ", wo_number, " (", infra_code, ") - ID: ", project.id, %newline,
				"Design: ", infra_name, " - ID: ", scheme.id, %newline,
				"All objects have been created in the design alternative.", %newline,
				"The design is now active. You can review and modify objects before posting.", %newline,
				"=" * 100)

			_self.user_info(msg)

			# Refresh button states to enable BoQ buttons now that design exists
			write("Migration successful - refreshing button states...")
			_self.refresh_button_states()
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.user_error(write_string("Failed to download KML file:", %newline, error_msg))
		_endif

	_when error
		_self.user_error(write_string("Error migrating to design:", %newline,
					      errCon))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.migrate_existing()
	## Migrate ABD KML data to existing |Engineering Design|ABD alternative
	## This function is ONLY enabled when KML source is ABD
	## Sets construction_status to "In Service" for all migrated objects
	##
	## Uses file download approach (Scenario 2) to avoid large XML string issues

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]
	_local kmz_source << wo[:kmz_source]

	# Validate KML source is ABD
	_if kmz_source <> "ABD"
	_then
		_self.user_error("This function is only available for ABD KML sources")
		_return
	_endif

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	write("Migrating ABD KML to existing alternative for UUID:", kmz_uuid)

	_try _with errCon
		# Use Scenario 2: Download files to disk, then read KML file
		_local output_dir << system.getenv("TEMP").default("C:\temp")
		_local infra_type << .filters[:infrastructure_type].default("cluster")
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.user_error("Failed to download KML file")
			_return
		_endif

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local kml_file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    kml_file_path_elem _isnt _unset
		_then
			_local kml_file_path << kml_file_path_elem.xml_result
			write("KML file downloaded to:", kml_file_path)

			# Parse KML file using astri_kml_parser
			write("Parsing KML file...")
			_local parser << astri_kml_parser.new(kml_file_path)
			_local placemarks << parser.parse()

			write("KML parsing complete. Found", placemarks.size, "placemarks")

			# Add infrastructure_type to work order property_list
			wo[:infrastructure_type] << .filters[:infrastructure_type].default("cluster")

			# Navigate to |Engineering Design|ABD alternative
			write("Navigating to |Engineering Design|ABD alternative...")
			_local database << gis_program_manager.databases[:gis]

			_if database _is _unset
			_then
				_self.user_error("GIS database not available")
				_return
			_endif

			_local gv << gis_program_manager.cached_dataset(:gis)
			_if gv _is _unset
			_then
				_self.user_error("GIS view not available")
				_return
			_endif

			# Switch to |Engineering Design|ABD alternative
			_local alt_name << "|Engineering Design|ABD"
			_try _with errCon
				gv.go_to_alternative(alt_name)
				write("Switched to alternative:", alt_name)

				write("Switching alternative mode...")
				gv.switch(:write)
			_when error
				_self.user_error(write_string("Failed to switch to alternative ", alt_name, ":", %newline,
					errCon.report_contents_string))
				_return
			_endtry
			write("Alternative is writable. Proceeding with migration...")

			# Create design migrator with "In Service" construction status - pass entire work order
			write("Creating design migrator...")
			_local migrator << astri_design_migrator.new(database, wo, "In Service")

			# Migrate placemarks without creating project/design
			write("Migrating placemarks to existing alternative...")
			_local stats << migrator.migrate_placemarks(placemarks)

			# Display results
			_local msg << write_string(
				"=" * 70, %newline,
				"ABD MIGRATION TO EXISTING ALTERNATIVE COMPLETE", %newline,
				"=" * 70, %newline,
				"Alternative:         ", alt_name, %newline,
				"Construction Status: In Service", %newline,
				"KML File:            ", kml_file_path, %newline,
				"=" * 70, %newline,
				"Aerial Routes:       ", stats[:aerial_routes], %newline,
				"Poles:               ", stats[:poles], %newline,
				"Sheaths:             ", stats[:sheaths], %newline,
				"Sheath Splices:      ", stats[:sheath_splices], %newline,
				"Optical Splitters:   ", stats[:optical_splitters], %newline,
				"Figure Eights:       ", stats[:figure_eights], %newline,
				"Sling Wires:         ", stats[:sling_wires], %newline,
				"Demand Points:       ", stats[:demand_points], %newline,
				"Customer Premises:   ", stats[:customer_premises], %newline,
				"Buildings:           ", stats[:buildings], %newline,
				"Micro Cells:         ", stats[:micro_cells], %newline,
				"OLTs:                ", stats[:olts], %newline,
				"Risers:              ", stats[:risers], %newline,
				"Access Points:       ", stats[:access_points], %newline,
				"Errors:              ", stats[:errors], %newline,
				"Skipped:             ", stats[:skipped], %newline,
				"=" * 70)

			_self.user_info(msg)
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.user_error(write_string("Failed to download KML file:", %newline, error_msg))
		_endif

	_when error
		_self.user_error(write_string("Error migrating to existing alternative:", %newline,
			errCon.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.read_kml_file(file_path)
	## Read KML file content from disk
	##
	## Parameters:
	##   file_path (string) - Full path to KML file
	##
	## Returns:
	##   string - KML file content, or _unset if failed

	_try
		_local input_stream << external_text_input_stream.new(file_path)
		_local kml_content << ""

		_protect
			_loop
				_local line << input_stream.get_line()
				_if line _is _unset
				_then
					_leave
				_endif
				kml_content << kml_content + line + %newline
			_endloop
		_protection
			input_stream.close()
		_endprotect

		write("Successfully read KML file:", file_path)
		write("Content size:", kml_content.size, "characters")

		_return kml_content

	_when error
		write("ERROR reading KML file:", condition.report_contents_string)
		_return _unset
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.format_placemark_display(index, pm)
	## Format placemark data for display
	##
	## Parameters:
	##   index (integer) - Display index number
	##   pm (property_list) - Placemark data
	##
	## Returns:
	##   string - Formatted display string

	_local msg << write_string(
		"[", index, "] ", pm[:name].default("unnamed"), %newline,
		"    Type: ", pm[:type].default("unknown"),
		"  |  Parent: ", pm[:parent].default(""), %newline,
		"    Coords: ", pm[:coord].default("").subseq(1, 50.min(pm[:coord].size)),
		_if pm[:coord].size > 50 _then >> "..." _else >> "" _endif, %newline)

	# Show extended data if present
	_if pm[:extended].size > 0
	_then
		msg << msg + write_string("    Extended: ")
		_local ext_count << 0
		_for key, val _over pm[:extended].fast_keys_and_elements()
		_loop
			ext_count +<< 1
			_if ext_count > 3 _then _leave _endif
			msg << msg + write_string(key, "=", val.default(""), " ")
		_endloop
		msg << msg + %newline
	_endif

	>> msg
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.check_project_and_design_exist(wo)
	## Check if project and design exist in Smallworld for this work order
	## Delegates to engine for data access
	##
	## Parameters:
	##   wo (property_list) - Work order data
	##
	## Returns:
	##   (boolean, boolean) - (has_project?, has_design?)

	_local wo_number << wo[:wo_number]
	_if wo_number _is _unset _orif wo_number = ""
	_then
		_return _false, _false
	_endif

	# Delegate to engine
	>> .engine.check_project_and_design_exist(wo_number)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.activate_design_for_wo(wo)
	## Find and activate the design for the given work order
	## Delegates to engine for data access and activation
	##
	## Parameters:
	##   wo (property_list) - Work order data
	##
	## Returns:
	##   scheme - The activated scheme, or _unset if failed

	_local wo_number << wo[:wo_number]
	_if wo_number _is _unset _orif wo_number = ""
	_then
		write("LOG: ERROR - No work order number")
		_return _unset
	_endif

	# Delegate to engine
	>> .engine.activate_design(wo_number)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.generate_boq_excel()
	## Generate Bill of Quantities as Excel file
	## Calls the global create_boq procedure from rwwi_astri_boq.magik

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo

	# Check if project and design exist
	_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
	_if _not (has_project _and has_design)
	_then
		_self.user_error("Project and design must exist before generating BoQ")
		_return
	_endif

	write("Generating BoQ as Excel for WO:", wo[:wo_number])

	_try _with errCond
		# Activate the design first
		_local scheme << _self.activate_design_for_wo(wo)
		_if scheme _is _unset
		_then
			_self.user_error("Failed to activate design. Cannot generate BoQ.")
			_return
		_endif

		# Call the global create_boq procedure
		write("Calling create_boq procedure...")
		create_boq()

		_self.user_info(write_string("BoQ Excel generation completed successfully for design: ",
			scheme.name))

	_when error
		write("LOG: Error generating BoQ as Excel:", errCond.report_contents_string)
		_self.user_error(write_string("Error generating BoQ as Excel:", %newline,
			errCond.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.generate_boq_json()
	## Generate Bill of Quantities as JSON property list
	## Calls the global create_pl_boq procedure from rwwi_astri_boq.magik

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo

	# Check if project and design exist
	_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
	_if _not (has_project _and has_design)
	_then
		_self.user_error("Project and design must exist before generating BoQ")
		_return
	_endif

	write("Generating BoQ as JSON for WO:", wo[:wo_number])

	_try _with errCond
		# Activate the design first
		_local scheme << _self.activate_design_for_wo(wo)
		_if scheme _is _unset
		_then
			_self.user_error("Failed to activate design. Cannot generate BoQ.")
			_return
		_endif

		# Call the global create_pl_boq procedure with "json" type
		write("Calling create_pl_boq procedure...")
		_local boq_result << create_pl_boq("json")

		# Display result summary
		_if boq_result _isnt _unset _andif boq_result.size > 0
		_then
			_local msg << write_string(
				"BoQ JSON generation completed successfully", %newline,
				"Design: ", scheme.name, %newline,
				"Total items: ", boq_result.size, %newline,
				%newline,
				"Sample items:", %newline)

			# Show first 5 items as preview
			_local count << 0
			_for item _over boq_result.fast_elements()
			_loop
				count +<< 1
				_if count > 5 _then _leave _endif

				msg << msg + write_string(
					"  - ", item[:object].default(""), ": ",
					item[:name].default(""), %newline,
					"    Code: ", item[:code].default(""),
					", Material: ", item[:material].default("N/A"),
					", Service: ", item[:service].default("N/A"), %newline)
			_endloop

			_self.user_info(msg)
		_else
			_self.user_info("BoQ JSON generation completed but no items found")
		_endif

	_when error
		write("LOG: Error generating BoQ as JSON:", errCond.report_contents_string)
		_self.user_error(write_string("Error generating BoQ as JSON:", %newline,
			errCond.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.mark_construction()
	## Mark selected work order as under construction

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local uuid << wo[:uuid]

	_if uuid _is _unset _orif uuid = ""
	_then
		_self.user_error("No UUID available for this work order")
		_return
	_endif

	write("Marking work order as construction:", uuid)

	_try
		_local success << .engine.mark_as_construction(uuid)

		_if success
		_then
			_self.user_info("Work order marked as under construction successfully")
			_self.refresh_data()
		_else
			_self.user_error("Failed to mark work order as under construction")
		_endif

	_when error
		_self.user_error(write_string("Error marking work order:", %newline,
			condition.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.user_info(message)
	## Display informational message to user

	write("INFO:", message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.user_error(message)
	## Display error message to user

	write("ERROR:", message)
_endmethod
$
