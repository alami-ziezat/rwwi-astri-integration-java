#% text_encoding = iso8859_1

_package user
$

## ASTRI Work Order Dialog
## UI layer for work order management using SW_SWIFT components

remex(:rwwi_astri_workorder_dialog)
$

def_slotted_exemplar(:rwwi_astri_workorder_dialog,
{
	{:engine,     _unset, :writable},       # Engine instance
	{:items,      _unset, :writable},       # UI components cache
	{:plugin,     _unset, :writable},       # Parent plugin
	{:filters,    _unset, :writable},       # Current filter values
	{:selected_wo, _unset, :writable},      # Currently selected work order
	{:wo_cache,   _unset, :writable}        # Cache to store work orders by row number
}, :model)
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.new(plugin)
	## Create new dialog
	>> _clone.init(plugin)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.init(plugin)
	## Initialize dialog

	.plugin << plugin
	.engine << rwwi_astri_workorder_engine.new()
	.engine.dialog << _self
	.items << property_list.new()
	.filters << property_list.new()
	.wo_cache << equality_hash_table.new()

	# Initialize default filters
	.filters[:source] << :api
	.filters[:infrastructure_type] << "cluster"
	.filters[:limit] << 50
	.filters[:offset] << 0

	>> _super.init()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.activate_in(frame)
	## Build and activate UI in frame using SW_SWIFT components

	frame.title << "ASTRI Work Order Manager"

	# Create top-level sw_canvas_container (required for SWIFT)
	.items[:top] << top_c << sw_canvas_container.new(
		frame, 3, 1,
		:width, 900,
		:height, 600,
		:outer_spacing, 5,
		:row_spacing, 5,
		:identifier, :top_container,
		:model, _self)

	# Create outer container with flexible row sizing
	# 4 rows: Toolbar (fixed), Table (flexible), Text Window (flexible), Detail Panel (fixed)
	.items[:outer] << outer << sw_container.new(top_c, 4, 1,
		:row_resize_values, {0, 1, 1, 0})  # Toolbar fixed, Table flexible, Text Window flexible, Detail fixed

	# Build toolbar with filters
	_self.build_toolbar(outer)

	# Build work order table
	_self.build_table(outer)

	# Build text window for process logs and statistics
	_self.build_text_window(outer)

	# Build detail panel (buttons only)
	_self.build_detail_panel(outer)

	# Initial data load
	_self.changed(:workorder_list, :refresh)

	# Return the top-level container (required)
	_return top_c
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_toolbar(parent)
	## Build toolbar with source selector and filters using SW_SWIFT components

	# Create sw_toolbar_container with separator styling
	toolbar_con << sw_toolbar_container.new(parent, _false,
		:background_type, :container,
		:show_separators?, _true,
		:enable_action_menu?, _false)

	# Get the actual toolbar to add items to
	a_toolbar << toolbar_con.create_toolbar()

	# Row 1: Refresh button, Source selector, Record count
	sw_button_item.new(a_toolbar,
		:image, {:refresh, :ui_resources},
		:model, _self,
		:selector, :refresh_data|()|,
		:tooltip, "Refresh work order data")

	sw_label_item.new(a_toolbar, "  Source:  ")

	.items[:source] << sw_text_item.new(a_toolbar,
		:model, _self,
		:display_length, 25,
		:editable?, _false,
		:change_selector, {:|source_selection()|})
	.items[:source].text_items << {"ASTRI API", "Database (Construction)"}
	.items[:source].value << "ASTRI API"

	.items[:record_count] << sw_label_item.new(a_toolbar, "  Total Records: 0  ")

	# Create second toolbar for filters
	filter_toolbar << toolbar_con.create_toolbar()

	sw_label_item.new(filter_toolbar, "  Filters:  ")

	sw_label_item.new(filter_toolbar, "Infrastructure:  ")
	.items[:filter_infrastructure] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 12,
		:editable?, _false,
		:change_selector, {:|infrastructure_type_changed()|})
	.items[:filter_infrastructure].text_items << {"cluster", "subfeeder", "feeder"}
	.items[:filter_infrastructure].value << "cluster"

	sw_label_item.new(filter_toolbar, "  Category:  ")
	.items[:filter_category] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 15,
		:editable?, _false)
	.items[:filter_category].text_items << {"All", "Cluster BOQ", "Installation", "Maintenance"}
	.items[:filter_category].value << "All"

	sw_label_item.new(filter_toolbar, "  Status:  ")
	.items[:filter_status] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 15,
		:editable?, _false)
	.items[:filter_status].text_items << {"All", "new", "in_progress", "closed", "cancelled", "successful"}
	.items[:filter_status].value << "All"

	.items[:label_topology] << sw_label_item.new(filter_toolbar, "  Topology:  ")
	.items[:filter_topology] << sw_text_item.new(filter_toolbar,
		:model, _self,
		:display_length, 10,
		:editable?, _false)
	.items[:filter_topology].text_items << {"All", "AE", "UG", "OH"}
	.items[:filter_topology].value << "All"

	# Create third toolbar for cluster filter and pagination
	pagination_toolbar << toolbar_con.create_toolbar()

	.items[:label_code] << sw_label_item.new(pagination_toolbar, "  Cluster Code:  ")
	.items[:filter_cluster] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 20,
		:editable?, _true)

	sw_label_item.new(pagination_toolbar, "  Limit:  ")
	.items[:filter_limit] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 5,
		:editable?, _false)
	.items[:filter_limit].text_items << {"10", "25", "50", "100", "200"}
	.items[:filter_limit].value << "50"

	sw_label_item.new(pagination_toolbar, "  Offset:  ")
	.items[:filter_offset] << sw_text_item.new(pagination_toolbar,
		:model, _self,
		:display_length, 8,
		:editable?, _true)
	.items[:filter_offset].value << "0"

	sw_button_item.new(pagination_toolbar,
		:label, "Apply Filters",
		:model, _self,
		:selector, :apply_filters|()|,
		:tooltip, "Apply current filters")
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_table(parent)
	## Build work order table using sw_table

	# Create sw_table with proper configuration
	.items[:table] << sw_table.new(parent,
		:row_height, 22,
		:selection_type, :row,
		:selection_mode, :one,
		:model, _self,
		:aspect, :workorder_list,
		:row_lines?, _true,
		:column_lines?, _true,
		:row_stripes?, _true,
		:data_selector, :|workorder_list_data()|,
		:selection_notifier, :workorder_selection|()|,
		:enable_manage_columns?, _true,
		:min_height, 300)

	# Set column labels
	.items[:table].set_column_labels({
		"No", "WO Number", "Infra Code", "Name",
		"Category", "Status", "Topology", "Vendor", "Area", "Area Plant Code", "Created", "KMZ UUID", "KML Source"})

	# Set column resize values (relative widths)
	.items[:table].col_resize_values << {0, 2, 1.5, 3, 1.5, 1.5, 1, 2.5, 1.5, 1.5, 1.5, 2, 0.8}

	# Enable column filtering
	.items[:table].enable_column_filter(2, _true)  # WO Number
	.items[:table].enable_column_filter(3, _true)  # Infra Code
	.items[:table].enable_column_filter(4, _true)  # Name
	.items[:table].enable_column_filter(6, _true)  # Status

	# Enable sorting after columns are configured
	.items[:table].enable_sort? << _true

	# Set selection notifier - receives (table, selection_rope) as arguments
	#.items[:table].selection_notifier << {:|workorder_selection()|, _self, _unset, _unset}
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_text_window(parent)
	## Build text window for displaying process logs and statistics
	## Shows migration progress, BOQ generation status, and work order details

	# Create sw_text_window component
	.items[:text_window] << sw_text_window.new(parent)
	.items[:text_window].show_border? << _true
	.items[:text_window].enable_horizontal_scrollbar? << _false
	.items[:text_window].enable_vertical_scrollbar? << _true
	.items[:text_window].min_height << 150
	.items[:text_window].editable? << _false  # Read-only

	# Set initial welcome message
	_self.log_info("ASTRI Work Order Manager - Ready")
	_self.log_info("=" * 80)
	_self.log_info("Select a work order from the table above to view details and perform actions.")
	_self.log_info("")
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_detail_panel(parent)
	## Build detail panel with action buttons only
	## Work order details are now shown in the text window above

	# Action buttons container - single row with horizontal layout
	button_con << sw_container.new(parent, 1, _unset,
		:outer_spacing, 5,
		:col_spacing, 10)

	# Removed "View Details" button - details now show automatically on row selection

	.items[:kmz_btn] << sw_button_item.new(button_con,
		:label, "Download KMZ",
		:model, _self,
		:selector, :download_kmz|()|)
	.items[:kmz_btn].enabled? << _false

	.items[:migrate_design_btn] << sw_button_item.new(button_con,
		:label, "Migrate to Design",
		:model, _self,
		:selector, :migrate_to_design|()|)
	.items[:migrate_design_btn].enabled? << _false

	.items[:migrate_existing_btn] << sw_button_item.new(button_con,
		:label, "Migrate Existing (ABD)",
		:model, _self,
		:selector, :migrate_existing|()|)
	.items[:migrate_existing_btn].enabled? << _false

	.items[:boq_excel_btn] << sw_button_item.new(button_con,
		:label, "Generate BoQ as Excel",
		:model, _self,
		:selector, :generate_boq_excel|()|)
	.items[:boq_excel_btn].enabled? << _false

	.items[:boq_json_btn] << sw_button_item.new(button_con,
		:label, "Generate BoQ as JSON",
		:model, _self,
		:selector, :generate_boq_json|()|)
	.items[:boq_json_btn].enabled? << _false

	# NEW: Export KML button
	.items[:export_kml_btn] << sw_button_item.new(button_con,
		:label, "Export Smallworld KML",
		:model, _self,
		:selector, :export_smallworld_kml|()|)
	.items[:export_kml_btn].enabled? << _false
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_info(message)
	## Write informational message to text window
	##
	## Parameters:
	##   message (string) - Message to display
	##
	## Example:
	##   _self.log_info("Starting migration process...")

	_if .items[:text_window] _isnt _unset
	_then
		_local current_text << .items[:text_window].text.default("")
		_local new_text << current_text + message + %newline
		.items[:text_window].text << new_text

		# Auto-scroll to bottom
		.items[:text_window].goto_line_end()
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_success(message)
	## Write success message to text window with formatting
	##
	## Parameters:
	##   message (string) - Success message to display

	_self.log_info("[SUCCESS] " + message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_error(message)
	## Write error message to text window with formatting
	##
	## Parameters:
	##   message (string) - Error message to display

	_self.log_info("[ERROR] " + message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_warning(message)
	## Write warning message to text window with formatting
	##
	## Parameters:
	##   message (string) - Warning message to display

	_self.log_info("[WARNING] " + message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.log_separator()
	## Write separator line to text window for visual grouping

	_self.log_info("=" * 80)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.clear_log()
	## Clear all text from the text window

	_if .items[:text_window] _isnt _unset
	_then
		.items[:text_window].text << ""
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.workorder_list_data()
	## Populate table with work order data using sw_table methods

	_try
		# Clear cache before populating new data
		.wo_cache.empty()

		# Get data from engine based on current source
		_local workorders << _if .filters[:source] _is :api
		_then
			>> .engine.get_workorders_from_api(
				.filters[:infrastructure_type].default("cluster"),
				.filters[:limit],
				.filters[:offset],
				_self.build_filter_params())
		_else
			>> .engine.get_workorders_from_db(_self.build_filter_params())
		_endif

		# Populate table using sw_table methods
		_local row << 0
		_for wo _over workorders.fast_elements()
		_loop
			row +<< 1
			# Add cells to table
			.items[:table].add_label(row, 1, row.write_string)
			.items[:table].add_label(row, 2, wo[:wo_number].default(""))
			.items[:table].add_label(row, 3, wo[:infra_code].default(""))
			.items[:table].add_label(row, 4, wo[:infra_name].default(""))
			.items[:table].add_label(row, 5, wo[:category].default(""))
			.items[:table].add_label(row, 6, wo[:status].default(""))
			.items[:table].add_label(row, 7, wo[:topology].default(""))
			.items[:table].add_label(row, 8, wo[:vendor].default(""))
			.items[:table].add_label(row, 9, wo[:area].default(""))
			.items[:table].add_label(row, 10, wo[:area_plant_code].default(""))
			.items[:table].add_label(row, 11, wo[:created_at].default(""))
			.items[:table].add_label(row, 12, wo[:kmz_uuid].default(""))
			.items[:table].add_label(row, 13, wo[:kmz_source].default(""))

			# Store work order data in cache by row number
			.wo_cache[row] << wo
		_endloop

		# Update record count
		.items[:record_count].value << write_string("  Total Records: ", row, "  ")

	_when error
		write("ERROR in workorder_list_data:", condition.report_contents_string)
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.refresh_data()
	## Refresh table data from current source

	write("Refreshing work order data...")
	_self.changed(:workorder_list, :renew)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.source_selection()
	## Handle source dropdown change

	_local source_text << .items[:source].value

	.filters[:source] << _if source_text = "ASTRI API"
	_then
		>> :api
	_else
		>> :db
	_endif

	write("Source changed to:", .filters[:source])
	_self.refresh_data()
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.infrastructure_type_changed()
	## Handle infrastructure type selection change
	## Update UI elements based on selected infrastructure type

	_local infra_type << .items[:filter_infrastructure].value.default("cluster")

	write("Infrastructure type changed to:", infra_type)

	# Update label text and topology visibility based on infrastructure type
	_if infra_type = "cluster"
	_then
		# Cluster: show topology, label = "Cluster Code"
		.items[:label_code].label << "  Cluster Code:  "
		.items[:label_topology].managed? << _true
		.items[:filter_topology].managed? << _true
		.items[:filter_topology].enabled? << _true

	_elif infra_type = "subfeeder"
	_then
		# Subfeeder: hide topology, label = "Subfeeder Code"
		.items[:label_code].label << "  Subfeeder Code:  "
		.items[:label_topology].managed? << _false
		.items[:filter_topology].managed? << _false
		.items[:filter_topology].enabled? << _false

	_elif infra_type = "feeder"
	_then
		# Feeder: hide topology, label = "OSP Route Area"
		.items[:label_code].label << "  OSP Route Area:  "
		.items[:label_topology].managed? << _false
		.items[:filter_topology].managed? << _false
		.items[:filter_topology].enabled? << _false
	_endif

	# Update the stored infrastructure type in filters
	.filters[:infrastructure_type] << infra_type
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.apply_filters()
	## Apply current filter selections

	write("Applying filters...")

	# Update filters from UI
	.filters[:infrastructure_type] << .items[:filter_infrastructure].value.default("cluster")

	_local limit_str << .items[:filter_limit].value
	.filters[:limit] << limit_str.as_number().default(10)

	_local offset_str << .items[:filter_offset].value
	.filters[:offset] << offset_str.as_number().default(0)

	# Refresh data with new filters
	_self.refresh_data()
_endmethod
$

_private _method rwwi_astri_workorder_dialog.build_filter_params()
	## Build filter property list from UI controls

	_local filters << property_list.new()

	# Get current infrastructure type
	_local infra_type << .items[:filter_infrastructure].value.default("cluster")

	# Category filter
	_local category << .items[:filter_category].value
	_if category _isnt _unset _and category <> "All"
	_then
		# Map display label to API field name
		_local category_map << equality_hash_table.new_with(
			"Cluster BOQ", "cluster_boq",
			"Installation", "installation",
			"Maintenance", "maintenance")

		_local category_name << category_map[category]
		_if category_name _isnt _unset
		_then
			filters[:category_name] << category_name
		_endif
	_endif

	# Status filter
	_local status << .items[:filter_status].value
	_if status _isnt _unset _and status <> "All"
	_then
		filters[:latest_status_name] << status
	_endif

	# Topology filter (only for cluster infrastructure type)
	_if infra_type = "cluster"
	_then
		_local topology << .items[:filter_topology].value
		_if topology _isnt _unset _and topology <> "All"
		_then
			# Dynamic field name: target_cluster_topology
			_local topology_field << write_string("target_", infra_type, "_topology").as_symbol()
			filters[topology_field] << topology
		_endif
	_endif

	# Infrastructure code filter (dynamic based on infrastructure type)
	_local code_value << .items[:filter_cluster].value
	_if code_value _isnt _unset _and code_value.size > 0
	_then
		# Dynamic field name based on infrastructure type:
		# - cluster:   target_cluster_code
		# - subfeeder: target_subfeeder_code
		# - feeder:    target_osp_route_area (NOT target_feeder_code)
		_local code_field << _if infra_type = "feeder"
		                     _then >> :target_osp_route_area
		                     _else >> write_string("target_", infra_type, "_code").as_symbol()
		                     _endif
		filters[code_field] << code_value
	_endif

	_return filters
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.workorder_selection(table, selection)
	## Handle work order selection in table
	##
	## Parameters:
	##   table (sw_table) - The table widget
	##   selection (rope) - Rope of selected row numbers

	_if selection _is _unset _orif selection.size = 0
	_then
		.selected_wo << _unset
		_self.update_detail_panel(_unset)
		_return
	_endif
	_local selected_row << selection.an_element()
	_local wo << .wo_cache[selected_row]

	.selected_wo << wo
	_self.update_detail_panel(wo)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.update_detail_panel(wo)
	## Update text window and button states with selected work order information
	## Displays comprehensive work order details automatically when row is selected

	_if wo _is _unset
	_then
		# Disable all buttons but don't clear log (preserve process results)
		.items[:kmz_btn].enabled? << _false
		.items[:migrate_design_btn].enabled? << _false
		.items[:migrate_existing_btn].enabled? << _false
		.items[:boq_excel_btn].enabled? << _false
		.items[:boq_json_btn].enabled? << _false
		.items[:export_kml_btn].enabled? << _false
	_else
		# Display comprehensive work order details in text window WITHOUT clearing previous logs
		# This preserves process execution results while showing current selection

		# Get KMZ information for button state and display
		_local kmz_uuid << wo[:kmz_uuid]
		_local kmz_source << wo[:kmz_source].default("")
		_local has_kmz << kmz_uuid _isnt _unset _andif kmz_uuid <> ""
		_local is_abd << kmz_source = "ABD"

		# Build comprehensive details message with proper alignment
		_local msg << write_string(
			%newline,
			"=" * 80, %newline,
			"SELECTED WORK ORDER DETAILS", %newline,
			"=" * 80, %newline, %newline,

			"BASIC INFORMATION:", %newline,
			"  WO Number	: ", wo[:wo_number].default("N/A"), %newline,
			"  UUID		    :", wo[:uuid].default("N/A"), %newline,
			"  Category		: ", wo[:category].default("N/A"), %newline,
			"  Status		: ", wo[:status].default("N/A"), %newline)

		# Add timestamps if available
		_if wo[:created_at] _isnt _unset _andif wo[:created_at] <> ""
		_then
			msg << msg + write_string("  Created At       : ", wo[:created_at], %newline)
		_endif

		_if wo[:updated_at] _isnt _unset _andif wo[:updated_at] <> ""
		_then
			msg << msg + write_string("  Updated At       : ", wo[:updated_at], %newline)
		_endif

		# Infrastructure information
		msg << msg + write_string(
			%newline,
			"INFRASTRUCTURE INFORMATION:", %newline,
			"  Code             : ", wo[:infra_code].default("N/A"), %newline,
			"  Name             : ", wo[:infra_name].default("N/A"), %newline,
			"  Type             : ", .filters[:infrastructure_type].default("N/A"), %newline)

		# Add optional infrastructure fields
		_if wo[:topology] _isnt _unset _andif wo[:topology] <> ""
		_then
			msg << msg + write_string("  Topology         : ", wo[:topology], %newline)
		_endif

		_if wo[:olt_name] _isnt _unset _andif wo[:olt_name] <> ""
		_then
			msg << msg + write_string("  OLT Name         : ", wo[:olt_name], %newline)
		_endif

		_if wo[:olt_label] _isnt _unset _andif wo[:olt_label] <> ""
		_then
			msg << msg + write_string("  OLT Label        : ", wo[:olt_label], %newline)
		_endif

		msg << msg + write_string(
			"  Area             : ", wo[:area].default("N/A"), %newline,
			"  Area Plant Code  : ", wo[:area_plant_code].default("N/A"), %newline)

		# Vendor information
		msg << msg + write_string(
			%newline,
			"VENDOR INFORMATION:", %newline,
			"  Vendor Name      : ", wo[:vendor_name].default("N/A"), %newline,
			"  Vendor Label     : ", wo[:vendor].default("N/A"), %newline)

		_if wo[:subcont_vendor] _isnt _unset _andif wo[:subcont_vendor] <> ""
		_then
			msg << msg + write_string("  Subcontractor    : ", wo[:subcont_vendor], %newline)
		_endif

		# KMZ information
		msg << msg + write_string(
			%newline,
			"KMZ INFORMATION:", %newline)

		_if has_kmz
		_then
			msg << msg + write_string(
				"  KMZ UUID         : ", kmz_uuid, %newline,
				"  KML Source       : ", kmz_source, %newline,
				"  Migration Status : Available", %newline)
		_else
			msg << msg + write_string(
				"  KMZ UUID         : Not Available", %newline,
				"  Migration Status : Not Available", %newline)
		_endif

		msg << msg + write_string(
			%newline,
			"=" * 80, %newline,
			"Use the buttons below to perform actions on this work order.", %newline)

		# Display message in single log call
		_self.log_info(msg)

		# Enable buttons based on work order state
		.items[:kmz_btn].enabled? << has_kmz
		.items[:migrate_design_btn].enabled? << has_kmz

		# Enable migrate_existing only for ABD KML sources
		.items[:migrate_existing_btn].enabled? << has_kmz _and is_abd

		# Enable BoQ and KML export buttons only if project and design exist
		_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
		.items[:boq_excel_btn].enabled? << has_project _and has_design
		.items[:boq_json_btn].enabled? << has_project _and has_design
		.items[:export_kml_btn].enabled? << has_project _and has_design
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.refresh_button_states()
	## Refresh button enable states for currently selected work order
	## Useful after migration completes to enable BoQ buttons

	_if .selected_wo _isnt _unset
	_then
		write("Refreshing button states for WO:", .selected_wo[:wo_number])
		_self.update_detail_panel(.selected_wo)
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.download_kmz()
	## Download KMZ file for selected work order using kmz_uuid

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	write("Downloading KMZ for UUID:", kmz_uuid)

	_try
		# Call ASTRI KMZ download API with kmz_uuid based on infrastructure type
		# astri_download_cluster_kmz(uuid, outputDir)
		# astri_download_subfeeder_kmz(uuid, outputDir)
		# astri_download_feeder_kmz(uuid, outputDir)
		_local output_dir << system.getenv("TEMP").default("C:\temp")
		_local infra_type << .filters[:infrastructure_type].default("cluster")
		write("infra type: ",infra_type)
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.user_error("Failed to download KMZ file")
			_return
		_endif

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    file_path_elem _isnt _unset
		_then
			_local file_path << file_path_elem.xml_result
			_self.user_info(write_string("KMZ downloaded successfully:", %newline, file_path))
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.user_error(write_string("Failed to download KMZ:", %newline, error_msg))
		_endif

	_when error
		_self.user_error(write_string("Error downloading KMZ:", %newline,
			condition.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.migrate_to_design()
	## Migrate KML data to real Smallworld design objects
	##
	## Uses file download approach (Scenario 2) to avoid large XML string issues

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	_self.clear_log()
	_self.log_separator()
	_self.log_info("STARTING DESIGN MIGRATION")
	_self.log_separator()
	_self.log_info("Work Order:      " + wo[:wo_number].default("N/A"))
	_self.log_info("Infrastructure:  " + wo[:infra_code].default("N/A"))
	_self.log_info("KMZ UUID:        " + kmz_uuid)
	_self.log_info("")

	write("Migrating KML to Design objects for UUID:", kmz_uuid)

	_try _with errCon
		# Use Scenario 2: Download files to disk, then read KML file
		_local output_dir << system.getenv("TEMP").default("C:\temp")
		_local infra_type << .filters[:infrastructure_type].default("cluster")
		_self.log_info("Step 1: Downloading KMZ file...")
		_self.log_info("  Output directory: " + output_dir)
		_self.log_info("  Infrastructure type: " + infra_type)
		write("Infra type: ",infra_type)
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.log_error("Failed to download KML file")
			_self.user_error("Failed to download KML file")
			_return
		_endif

		_self.log_success("KMZ file downloaded successfully")
		_self.log_info("")
		_self.log_info("Step 2: Parsing download response...")

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local kml_file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    kml_file_path_elem _isnt _unset
		_then
			_local kml_file_path << kml_file_path_elem.xml_result
			_self.log_success("KML file path extracted")
			_self.log_info("  File: " + kml_file_path)
			_self.log_info("")
			write("KML file downloaded to:", kml_file_path)

			# Parse KML file using astri_kml_parser
			_self.log_info("Step 3: Parsing KML file...")
			write("Parsing KML file...")
			_local parser << astri_kml_parser.new(kml_file_path)
			_local placemarks << parser.parse()

			_self.log_success("KML parsing complete")
			_self.log_info("  Found " + placemarks.size.write_string + " placemarks")
			_self.log_info("")
			write("KML parsing complete. Found", placemarks.size, "placemarks")

			# Prepare project and design names
			_local wo_number << wo[:wo_number].default("WO_" + kmz_uuid.subseq(1, 8))
			_local infra_code << wo[:infra_code].default("INFRA_" + kmz_uuid.subseq(1, 8))
			_local infra_name << wo[:infra_name].default("Infra_" + kmz_uuid.subseq(1, 8))
			_local infra_name_size << infra_name.size

			_for pmark _over placemarks.fast_elements()
			_loop
				write("Placemark:", pmark[:name].default("Unnamed")," <<==>> ", pmark[:type].default("Unknown")," <<==>> ", pmark[:ring_name].default("None")," <<==>> ", pmark[:parent].default("None"))
			_endloop
			_return 	
			_if infra_name_size > 64
			_then
				infra_name << infra_name.subseq(infra_name_size-64, 64)
			_endif

			# Add infrastructure_type to work order property_list
			wo[:infrastructure_type] << .filters[:infrastructure_type].default("cluster")

			_self.log_info("Step 4: Initializing design migrator...")
			_self.log_info("  Project name:   " + wo_number)
			_self.log_info("  Project title:  " + infra_code)
			_self.log_info("  Design name:    " + infra_name)
			_self.log_info("  Infra type:     " + wo[:infrastructure_type].default("cluster"))
			_self.log_info("  POP name:       " + wo[:olt_label].default(wo[:olt_name].default("Unknown")))
			_self.log_info("  Region:         " + wo[:area].default("Unknown"))
			_self.log_info("")

			# Create design migrator - pass entire work order property_list
			write("Creating design migrator...")
			write("  Work Order: ", wo[:wo_number])
			write("  Infrastructure Type: ", wo[:infrastructure_type])
			write("  POP Name: ", wo[:olt_label].default(wo[:olt_name].default("Unknown")))
			write("  Region: ", wo[:area].default("Unknown"))
			write("  Infrastructure Name: ", wo[:infra_name].default("Unknown"))

			_local database << gis_program_manager.databases[:gis]

			_if database _is _unset
			_then
				_self.log_error("GIS database not available")
				_self.user_error("GIS database not available")
				_return
			_endif

			_local migrator << astri_design_migrator.new(database, wo)
			_self.log_success("Design migrator initialized")
			_self.log_info("")

			# Create project and design
			_self.log_info("Step 5: Creating Design Manager project and design...")
			write("Initiate: Creating project and design...: ",infra_code," : ",infra_name)
			_local (project, scheme) << migrator.create_project_and_design(
				placemarks,     # Boundary extracted from placemarks
				wo_number,      # Project name
				infra_code,     # Project title
				infra_name      # Design name
			)
			_self.log_success("Project and design created")
			_self.log_info("")

			# Migrate placemarks to design
			_self.log_info("Step 6: Migrating placemarks to design objects...")
			write("Migrating objects to design...")
			_local stats << migrator.migrate_placemarks(placemarks)
			_self.log_success("Migration complete!")
			_self.log_info("")

			# Display results
			_local total_objs << stats[:aerial_routes] + stats[:poles] + stats[:sheaths] +
			                      stats[:sling_wires] + stats[:demand_points] +
			                      stats[:micro_cells] + stats[:areas_created]

			_self.log_separator()
			_self.log_success("DESIGN MIGRATION COMPLETE!")
			_self.log_separator()
			_self.log_info("Project:         " + wo_number + " (" + infra_code + ") - ID: " + project.id.write_string)
			_self.log_info("Design:          " + infra_name + " - ID: " + scheme.id.write_string)
			_self.log_info("")
			_self.log_info("MIGRATION STATISTICS:")
			_self.log_info("  Aerial Routes:      " + stats[:aerial_routes].write_string)
			_self.log_info("  Poles:              " + stats[:poles].write_string)
			_self.log_info("  Sheaths:            " + stats[:sheaths].write_string)
			_self.log_info("  Sheath Splices:     " + stats[:sheath_splices].write_string)
			_self.log_info("  Optical Splitters:  " + stats[:optical_splitters].write_string)
			_self.log_info("  Figure Eights:      " + stats[:figure_eights].write_string)
			_self.log_info("  Sling Wires:        " + stats[:sling_wires].write_string)
			_self.log_info("  Demand Points:      " + stats[:demand_points].write_string)
			_self.log_info("  Customer Premises:  " + stats[:customer_premises].write_string)
			_self.log_info("  Buildings:          " + stats[:buildings].write_string)
			_self.log_info("  Micro Cells:        " + stats[:micro_cells].write_string)
			_self.log_info("  OLTs:               " + stats[:olts].write_string)
			_self.log_info("  Risers:             " + stats[:risers].write_string)
			_self.log_info("  Access Points:      " + stats[:access_points].write_string)
			_self.log_info("  Errors:             " + stats[:errors].write_string)
			_self.log_info("  Skipped:            " + stats[:skipped].write_string)
			_self.log_info("")
			_self.log_info("Total objects:      " + total_objs.write_string)
			_self.log_separator()

			_local msg << write_string(
				" >>> Design Migration Complete! <<<", %newline,
				"File: ", kml_file_path, %newline,
				"Project: ", wo_number, " (", infra_code, ") - ID: ", project.id, %newline,
				"Design: ", infra_name, " - ID: ", scheme.id, %newline,
				"All objects have been created in the design alternative.", %newline,
				"The design is now active. You can review and modify objects before posting.", %newline,
				"=" * 100)

			_self.user_info(msg)

			# Refresh button states to enable BoQ buttons now that design exists
			write("Migration successful - refreshing button states...")
			_self.refresh_button_states()
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.log_separator()
			_self.log_error("MIGRATION FAILED")
			_self.log_separator()
			_self.log_error("Failed to download KML file")
			_self.log_error("Error: " + error_msg)
			_self.log_separator()
			_self.user_error(write_string("Failed to download KML file:", %newline, error_msg))
		_endif

	_when error
		_self.log_separator()
		_self.log_error("MIGRATION FAILED")
		_self.log_separator()
		_self.log_error("Error during migration:")
		_self.log_error(errCon.report_contents_string)
		_self.log_separator()
		_self.user_error(write_string("Error migrating to design:", %newline,
					      errCon))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.migrate_existing()
	## Migrate ABD KML data to existing |Engineering Design|ABD alternative
	## This function is ONLY enabled when KML source is ABD
	## Sets construction_status to "In Service" for all migrated objects
	##
	## Uses file download approach (Scenario 2) to avoid large XML string issues

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local kmz_uuid << wo[:kmz_uuid]
	_local kmz_source << wo[:kmz_source]

	# Validate KML source is ABD
	_if kmz_source <> "ABD"
	_then
		_self.user_error("This function is only available for ABD KML sources")
		_return
	_endif

	_if kmz_uuid _is _unset _orif kmz_uuid = ""
	_then
		_self.user_info("No KMZ UUID available for this work order")
		_return
	_endif

	_self.clear_log()
	_self.log_separator()
	_self.log_info("STARTING ABD MIGRATION TO EXISTING ALTERNATIVE")
	_self.log_separator()
	_self.log_info("Work Order:      " + wo[:wo_number].default("N/A"))
	_self.log_info("Infrastructure:  " + wo[:infra_code].default("N/A"))
	_self.log_info("KMZ UUID:        " + kmz_uuid)
	_self.log_info("KMZ Source:      " + kmz_source)
	_self.log_info("Target Alt:      |Engineering Design|ABD")
	_self.log_info("")

	write("Migrating ABD KML to existing alternative for UUID:", kmz_uuid)

	_try _with errCon
		# Use Scenario 2: Download files to disk, then read KML file
		_local output_dir << system.getenv("TEMP").default("C:\temp")
		_local infra_type << .filters[:infrastructure_type].default("cluster")
		_self.log_info("Step 1: Downloading KMZ file...")
		_self.log_info("  Output directory: " + output_dir)
		_self.log_info("  Infrastructure type: " + infra_type)
		_local xml_result << _if infra_type = "cluster"
		                     _then >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "subfeeder"
		                     _then >> astri_download_subfeeder_kmz(kmz_uuid, output_dir)
		                     _elif infra_type = "feeder"
		                     _then >> astri_download_feeder_kmz(kmz_uuid, output_dir)
		                     _else >> astri_download_cluster_kmz(kmz_uuid, output_dir)
		                     _endif

		_if xml_result _is _unset _orif xml_result = ""
		_then
			_self.log_error("Failed to download KML file")
			_self.user_error("Failed to download KML file")
			_return
		_endif

		_self.log_success("KMZ file downloaded successfully")
		_self.log_info("")
		_self.log_info("Step 2: Parsing download response...")

		# Parse XML response to get file path
		_local xml_doc << simple_xml.read_element_string(xml_result)
		_local success_elem << xml_doc.element_matching_name(:success)
		_local kml_file_path_elem << xml_doc.element_matching_name(:kml_file_path)

		_if success_elem _isnt _unset _andif
		    success_elem.xml_result = "true" _andif
		    kml_file_path_elem _isnt _unset
		_then
			_local kml_file_path << kml_file_path_elem.xml_result
			_self.log_success("KML file path extracted")
			_self.log_info("  File: " + kml_file_path)
			_self.log_info("")
			write("KML file downloaded to:", kml_file_path)

			# Parse KML file using astri_kml_parser
			_self.log_info("Step 3: Parsing KML file...")
			write("Parsing KML file...")
			_local parser << astri_kml_parser.new(kml_file_path)
			_local placemarks << parser.parse()

			_self.log_success("KML parsing complete")
			_self.log_info("  Found " + placemarks.size.write_string + " placemarks")
			_self.log_info("")
			write("KML parsing complete. Found", placemarks.size, "placemarks")

			# Add infrastructure_type to work order property_list
			wo[:infrastructure_type] << .filters[:infrastructure_type].default("cluster")

			# Navigate to |Engineering Design|ABD alternative
			_self.log_info("Step 4: Navigating to existing alternative...")
			write("Navigating to |Engineering Design|ABD alternative...")
			_local database << gis_program_manager.databases[:gis]

			_if database _is _unset
			_then
				_self.log_error("GIS database not available")
				_self.user_error("GIS database not available")
				_return
			_endif

			_local gv << gis_program_manager.cached_dataset(:gis)
			_if gv _is _unset
			_then
				_self.log_error("GIS view not available")
				_self.user_error("GIS view not available")
				_return
			_endif

			# Switch to |Engineering Design|ABD alternative
			_local alt_name << "|Engineering Design|ABD"
			_try _with errCon
				gv.go_to_alternative(alt_name)
				_self.log_success("Switched to alternative: " + alt_name)
				write("Switched to alternative:", alt_name)

				_self.log_info("  Switching to write mode...")
				write("Switching alternative mode...")
				gv.switch(:write)
				_self.log_success("Alternative is now writable")
			_when error
				_self.log_error("Failed to switch to alternative: " + alt_name)
				_self.log_error(errCon.report_contents_string)
				_self.user_error(write_string("Failed to switch to alternative ", alt_name, ":", %newline,
					errCon.report_contents_string))
				_return
			_endtry
			_self.log_info("")
			write("Alternative is writable. Proceeding with migration...")

			# Create design migrator with "In Service" construction status - pass entire work order
			_self.log_info("Step 5: Creating design migrator...")
			_self.log_info("  Construction status: In Service")
			write("Creating design migrator...")
			_local migrator << astri_design_migrator.new(database, wo, "In Service")
			_self.log_success("Design migrator initialized")
			_self.log_info("")

			# Migrate placemarks without creating project/design
			_self.log_info("Step 6: Migrating placemarks to existing alternative...")
			write("Migrating placemarks to existing alternative...")
			_local stats << migrator.migrate_placemarks(placemarks)
			_self.log_success("Migration complete!")
			_self.log_info("")

			# Display results
			_self.log_separator()
			_self.log_success("ABD MIGRATION TO EXISTING ALTERNATIVE COMPLETE!")
			_self.log_separator()
			_self.log_info("Alternative:         " + alt_name)
			_self.log_info("Construction Status: In Service")
			_self.log_info("KML File:            " + kml_file_path)
			_self.log_info("")
			_self.log_info("MIGRATION STATISTICS:")
			_self.log_info("  Aerial Routes:      " + stats[:aerial_routes].write_string)
			_self.log_info("  Poles:              " + stats[:poles].write_string)
			_self.log_info("  Sheaths:            " + stats[:sheaths].write_string)
			_self.log_info("  Sheath Splices:     " + stats[:sheath_splices].write_string)
			_self.log_info("  Optical Splitters:  " + stats[:optical_splitters].write_string)
			_self.log_info("  Figure Eights:      " + stats[:figure_eights].write_string)
			_self.log_info("  Sling Wires:        " + stats[:sling_wires].write_string)
			_self.log_info("  Demand Points:      " + stats[:demand_points].write_string)
			_self.log_info("  Customer Premises:  " + stats[:customer_premises].write_string)
			_self.log_info("  Buildings:          " + stats[:buildings].write_string)
			_self.log_info("  Micro Cells:        " + stats[:micro_cells].write_string)
			_self.log_info("  OLTs:               " + stats[:olts].write_string)
			_self.log_info("  Risers:             " + stats[:risers].write_string)
			_self.log_info("  Access Points:      " + stats[:access_points].write_string)
			_self.log_info("  Errors:             " + stats[:errors].write_string)
			_self.log_info("  Skipped:            " + stats[:skipped].write_string)
			_self.log_separator()

			_local msg << write_string(
				"=" * 70, %newline,
				"ABD MIGRATION TO EXISTING ALTERNATIVE COMPLETE", %newline,
				"=" * 70, %newline,
				"Alternative:         ", alt_name, %newline,
				"Construction Status: In Service", %newline,
				"KML File:            ", kml_file_path, %newline,
				"=" * 70, %newline,
				"Aerial Routes:       ", stats[:aerial_routes], %newline,
				"Poles:               ", stats[:poles], %newline,
				"Sheaths:             ", stats[:sheaths], %newline,
				"Sheath Splices:      ", stats[:sheath_splices], %newline,
				"Optical Splitters:   ", stats[:optical_splitters], %newline,
				"Figure Eights:       ", stats[:figure_eights], %newline,
				"Sling Wires:         ", stats[:sling_wires], %newline,
				"Demand Points:       ", stats[:demand_points], %newline,
				"Customer Premises:   ", stats[:customer_premises], %newline,
				"Buildings:           ", stats[:buildings], %newline,
				"Micro Cells:         ", stats[:micro_cells], %newline,
				"OLTs:                ", stats[:olts], %newline,
				"Risers:              ", stats[:risers], %newline,
				"Access Points:       ", stats[:access_points], %newline,
				"Errors:              ", stats[:errors], %newline,
				"Skipped:             ", stats[:skipped], %newline,
				"=" * 70)

			_self.user_info(msg)
		_else
			_local error_elem << xml_doc.element_matching_name(:error)
			_local error_msg << _if error_elem _isnt _unset
					    _then >> error_elem.xml_result
					    _else >> "Unknown error"
					    _endif
			_self.log_separator()
			_self.log_error("MIGRATION FAILED")
			_self.log_separator()
			_self.log_error("Failed to download KML file")
			_self.log_error("Error: " + error_msg)
			_self.log_separator()
			_self.user_error(write_string("Failed to download KML file:", %newline, error_msg))
		_endif

	_when error
		_self.log_separator()
		_self.log_error("MIGRATION FAILED")
		_self.log_separator()
		_self.log_error("Error migrating to existing alternative:")
		_self.log_error(errCon.report_contents_string)
		_self.log_separator()
		_self.user_error(write_string("Error migrating to existing alternative:", %newline,
			errCon.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.read_kml_file(file_path)
	## Read KML file content from disk
	##
	## Parameters:
	##   file_path (string) - Full path to KML file
	##
	## Returns:
	##   string - KML file content, or _unset if failed

	_try
		_local input_stream << external_text_input_stream.new(file_path)
		_local kml_content << ""

		_protect
			_loop
				_local line << input_stream.get_line()
				_if line _is _unset
				_then
					_leave
				_endif
				kml_content << kml_content + line + %newline
			_endloop
		_protection
			input_stream.close()
		_endprotect

		write("Successfully read KML file:", file_path)
		write("Content size:", kml_content.size, "characters")

		_return kml_content

	_when error
		write("ERROR reading KML file:", condition.report_contents_string)
		_return _unset
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.format_placemark_display(index, pm)
	## Format placemark data for display
	##
	## Parameters:
	##   index (integer) - Display index number
	##   pm (property_list) - Placemark data
	##
	## Returns:
	##   string - Formatted display string

	_local msg << write_string(
		"[", index, "] ", pm[:name].default("unnamed"), %newline,
		"    Type: ", pm[:type].default("unknown"),
		"  |  Parent: ", pm[:parent].default(""), %newline,
		"    Coords: ", pm[:coord].default("").subseq(1, 50.min(pm[:coord].size)),
		_if pm[:coord].size > 50 _then >> "..." _else >> "" _endif, %newline)

	# Show extended data if present
	_if pm[:extended].size > 0
	_then
		msg << msg + write_string("    Extended: ")
		_local ext_count << 0
		_for key, val _over pm[:extended].fast_keys_and_elements()
		_loop
			ext_count +<< 1
			_if ext_count > 3 _then _leave _endif
			msg << msg + write_string(key, "=", val.default(""), " ")
		_endloop
		msg << msg + %newline
	_endif

	>> msg
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.check_project_and_design_exist(wo)
	## Check if project and design exist in Smallworld for this work order
	## Delegates to engine for data access
	##
	## Parameters:
	##   wo (property_list) - Work order data
	##
	## Returns:
	##   (boolean, boolean) - (has_project?, has_design?)

	_local wo_number << wo[:wo_number]
	_if wo_number _is _unset _orif wo_number = ""
	_then
		_return _false, _false
	_endif

	# Delegate to engine
	>> .engine.check_project_and_design_exist(wo_number)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_private _method rwwi_astri_workorder_dialog.activate_design_for_wo(wo)
	## Find and activate the design for the given work order
	## Delegates to engine for data access and activation
	##
	## Parameters:
	##   wo (property_list) - Work order data
	##
	## Returns:
	##   scheme - The activated scheme, or _unset if failed

	_local wo_number << wo[:wo_number]
	_if wo_number _is _unset _orif wo_number = ""
	_then
		write("LOG: ERROR - No work order number")
		_return _unset
	_endif

	# Delegate to engine
	>> .engine.activate_design(wo_number)
_endmethod
$

_private _method rwwi_astri_workorder_dialog.get_infra_type_from_wo(wo)
	## Determine infrastructure type from work order category
	##
	## Parameters:
	##   wo (property_list) - Work order data
	##
	## Returns:
	##   string - Infrastructure type: "cluster", "subfeeder", or "feeder"

	_local category << wo[:category].default("").lowercase

	_if category.index_of_seq("cluster") _isnt _unset
	_then
		_return "cluster"
	_elif category.index_of_seq("subfeeder") _isnt _unset _orif
	      category.index_of_seq("sub feeder") _isnt _unset
	_then
		_return "subfeeder"
	_elif category.index_of_seq("feeder") _isnt _unset
	_then
		_return "feeder"
	_else
		# Default to cluster if category is unclear
		write("LOG: WARNING - Unknown category '", category, "', defaulting to 'cluster'")
		_return "cluster"
	_endif
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.generate_boq_excel()
	## Generate Bill of Quantities as Excel file
	## Calls the global create_boq procedure from rwwi_astri_boq.magik

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo

	# Check if project and design exist
	_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
	_if _not (has_project _and has_design)
	_then
		_self.user_error("Project and design must exist before generating BoQ")
		_return
	_endif

	write("Generating BoQ as Excel for WO:", wo[:wo_number])

	_try _with errCond
		# Activate the design first
		_local scheme << _self.activate_design_for_wo(wo)
		_if scheme _is _unset
		_then
			_self.user_error("Failed to activate design. Cannot generate BoQ.")
			_return
		_endif

		# Call the global create_boq procedure
		write("Calling create_boq procedure...")
		create_boq()

		_self.user_info(write_string("BoQ Excel generation completed successfully for design: ",
			scheme.name))

	_when error
		write("LOG: Error generating BoQ as Excel:", errCond.report_contents_string)
		_self.user_error(write_string("Error generating BoQ as Excel:", %newline,
			errCond.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.generate_boq_json()
	## Generate Bill of Quantities as JSON property list using new BOQ generator
	## Uses rwwi_astri_boq_generator class with work order parameters

	_dynamic !print_float_precision! << 6

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo

	# Check if project and design exist
	_local (has_project, has_design) << _self.check_project_and_design_exist(wo)
	_if _not (has_project _and has_design)
	_then
		_self.user_error("Project and design must exist before generating BoQ")
		_return
	_endif

	_self.clear_log()
	_self.log_separator()
	_self.log_info("STARTING BOQ GENERATION")
	_self.log_separator()
	_self.log_info("Work Order:      " + wo[:wo_number].default("N/A"))
	_self.log_info("Infrastructure:  " + wo[:infra_code].default("N/A"))
	_self.log_info("")

	write("Generating BoQ as JSON for WO:", wo[:wo_number])

	_try _with errCond
		# Activate the design first
		_self.log_info("Step 1: Activating design...")
		_local scheme << _self.activate_design_for_wo(wo)
		_if scheme _is _unset
		_then
			_self.log_error("Failed to activate design")
			_self.user_error("Failed to activate design. Cannot generate BoQ.")
			_return
		_endif
		_self.log_success("Design activated: " + scheme.name.default("(unnamed)"))
		_self.log_info("")

		# Determine infrastructure type from work order category
		_local infra_type << _self.get_infra_type_from_wo(wo)

		# Get KMZ UUID from work order (from PostgreSQL database)
		_local kmz_uuid << wo[:kmz_uuid].default("")

		# Get infrastructure code field name based on type
		_local infra_code_field << _if infra_type = "cluster"
		                           _then >> :cluster_code
		                           _elif infra_type = "subfeeder"
		                           _then >> :subfeeder_code
		                           _elif infra_type = "feeder"
		                           _then >> :feeder_code
		                           _else >> :cluster_code
		                           _endif

		# Get infrastructure code from database result (already fetched from PostgreSQL)
		_local infra_code << wo[infra_code_field].default(wo[:infra_code])
		infra_code << "PLB006435 " #temp hardcode for testing BOQ
		# Build BOQ parameters from work order data

		_local boq_params << property_list.new_with(
			:infra_type, infra_type,
			infra_code_field, infra_code,           # Dynamic: cluster_code/subfeeder_code/feeder_code
			:vendor_name, wo[:vendor_name].default(_unset),
			:subcont_vendor_name, wo[:subcont_vendor].default(_unset),
			:remarks, "Service",                    # Default
			:phase, "project_opname",               # Default
			:area, wo[:area].default(_unset),
			:area_plant_code, wo[:area_plant_code].default(_unset),
			:override_price_material, _unset,       # Optional
			:override_price_service, _unset         # Optional
		)

		_self.log_info("Step 2: Preparing BOQ parameters...")
		_self.log_info("  Infrastructure Type: " + infra_type)
		_self.log_info("  Infrastructure Code: " + infra_code)
		_self.log_info("  Vendor:              " + wo[:vendor_name].default("(none)"))
		_self.log_info("  Subcont Vendor:      " + wo[:subcont_vendor].default("(none)"))
		_self.log_info("  Area:                " + wo[:area].default("(none)"))
		_self.log_info("  Area Plant Code:     " + wo[:area_plant_code].default("(none)"))
		_self.log_info("")

		write("BOQ Parameters:")
		write("  Infrastructure Type:", infra_type)
		write("  Infrastructure Code:", infra_code)
		write("  Vendor:", wo[:vendor_name].default(""))
		write("  Subcont Vendor:", wo[:subcont_vendor].default(""))
		write("  Area:", wo[:area].default(""))
		write("  Area Plant Code:", wo[:area_plant_code].default(""))
		write("  KMZ UUID:", kmz_uuid)

		# Create BOQ generator instance
		_self.log_info("Step 3: Creating BOQ generator...")
		write("Creating BOQ generator...")
		_local generator << rwwi_astri_boq_generator.new(boq_params)
		_self.log_success("BOQ generator created")
		_self.log_info("")

		# Generate BOQ items
		_self.log_info("Step 4: Generating BOQ items from design...")
		write("Generating BOQ items...")
		_local boq_result << generator.generate()
		_self.log_success("BOQ generation complete")
		_self.log_info("  Total BOQ items: " + boq_result.size.write_string)
		_self.log_info("")

		# Send BOQ data to ASTRI API (only for cluster infrastructure type)
		_local api_success_count << 0
		_local api_error_count << 0
		_local api_skipped_count << 0
		_local success_items << rope.new()  # Track successful items
		_local failed_items << rope.new()   # Track failed items with error details

		_if infra_type = "cluster" _andif boq_result _isnt _unset _andif boq_result.size > 0
		_then
			_self.log_info("Step 5: Sending BOQ items to ASTRI API...")
			_self.log_info("  Infrastructure type is 'cluster' - API submission enabled")
			_self.log_info("  Processing " + boq_result.size.write_string + " BOQ items...")
			_self.log_info("")
			write("Sending BOQ items to ASTRI API...")

			_for key _over boq_result.keys()
			_loop
				_local item << boq_result[key]
				_local equipment_name << item[:equipment_name].default("")
				_local qty_material << item[:quantity_material]
				_local qty_service << item[:quantity_service]

				_try _with apiErrCond
					# Call astri_add_boq_drm_cluster Java procedure
					write("Sending BOQ item:", equipment_name)

					_local json_response << astri_add_boq_drm_cluster(
						infra_code,                                    # cluster_code
						item[:vendor_name].default(""),                # vendor_name
						item[:subcont_vendor_name].default(""),        # subcont_vendor_name
						equipment_name,                                # equipment_name
						item[:description].default(""),                # description
						qty_material,                                  # quantity_material (can be _unset)
						qty_service,                                   # quantity_service (can be _unset)
						item[:remarks].default(""),                    # remarks
						item[:phase].default(""),                      # phase
						item[:area].default(""),                       # area
						item[:area_plant_code].default(""),            # area_plant_code
						item[:override_price_material],                # override_price_material (can be _unset)
						item[:override_price_service]                  # override_price_service (can be _unset)
					)

					# Parse JSON response to check for success/error
					_if json_response _isnt _unset _andif json_response <> ""
					_then
						_try _with parseErr
							# Parse JSON response using json_parser
							_local json_obj << json_parser.parse(json_response)

							# Check for success field
							_local success << json_obj[:success]

							_if success _is _true
							_then
								write("  SUCCESS: BOQ item sent to ASTRI API")
								api_success_count +<< 1
								# Track successful item with quantities
								success_items.add(property_list.new_with(
									:equipment_name, equipment_name,
									:qty_material, qty_material,
									:qty_service, qty_service))
							_else
								# Error response from API
								_local error_msg << json_obj[:error].default("Unknown error")
								write("  ERROR: API returned error:")
								print(error_msg)
								api_error_count +<< 1
								_if error_msg.size > 1
								_then
									error_msg << write_string(error_msg[1], " <==> ", error_msg[2])
								_endif

								# Track failed item with error
								failed_items.add(property_list.new_with(
									:equipment_name, equipment_name,
									:qty_material, qty_material,
									:qty_service, qty_service,
									:error, error_msg))
							_endif

						_when error
							# If JSON parsing fails, treat as error
							write("  ERROR: Failed to parse API response:", parseErr.report_contents_string)
							write("  Response:", json_response)
							api_error_count +<< 1
							failed_items.add(property_list.new_with(
								:equipment_name, equipment_name,
								:qty_material, qty_material,
								:qty_service, qty_service,
								:error, "JSON parse error: " + parseErr.report_contents_string))
						_endtry
					_else
						write("  ERROR: Empty response from ASTRI API")
						api_error_count +<< 1
						failed_items.add(property_list.new_with(
							:equipment_name, equipment_name,
							:qty_material, qty_material,
							:qty_service, qty_service,
							:error, "Empty API response"))
					_endif

				_when error
					write("  ERROR sending BOQ item:", apiErrCond.report_contents_string)
					api_error_count +<< 1
					failed_items.add(property_list.new_with(
						:equipment_name, equipment_name,
						:qty_material, qty_material,
						:qty_service, qty_service,
						:error, apiErrCond.report_contents_string))
				_endtry
			_endloop

			_self.log_info("")
			_self.log_success("API submission complete")
			_self.log_info("  Successfully sent: " + api_success_count.write_string)
			_self.log_info("  Errors:            " + api_error_count.write_string)
			write("API Send Summary:")
			write("  Success:", api_success_count)
			write("  Errors:", api_error_count)
		_else
			_if infra_type <> "cluster"
			_then
				_self.log_info("Step 5: Skipping API submission...")
				_self.log_warning("Infrastructure type '" + infra_type + "' does not support API submission")
				_self.log_info("  API submission is only available for 'cluster' infrastructure type")
				write("Skipping API send - infrastructure type is:", infra_type, "(only 'cluster' supported)")
				api_skipped_count << boq_result.size
			_endif
		_endif
		_self.log_info("")

		# Display result summary
		_if boq_result _isnt _unset _andif boq_result.size > 0
		_then
			_self.log_separator()
			_self.log_success("BOQ GENERATION COMPLETE!")
			_self.log_separator()
			_self.log_info("Design:          " + scheme.name.default("(unnamed)"))
			_self.log_info("Infrastructure:  " + infra_type + " - " + infra_code)
			_self.log_info("Total BOQ Items: " + boq_result.size.write_string)
			_self.log_info("")

			# Add API send summary if cluster type
			_if infra_type = "cluster"
			_then
				_self.log_info("API SUBMISSION SUMMARY:")
				_self.log_info("  Successfully sent: " + api_success_count.write_string)
				_self.log_info("  Errors:            " + api_error_count.write_string)
				_self.log_info("")

				# Display detailed successful items
				_if success_items.size > 0
				_then
					_local success_msg << write_string(
						"SUCCESSFUL ITEMS (", success_items.size, "):", %newline,
						"-" * 80, %newline)

					_for item _over success_items.fast_elements()
					_loop
						_local mat_qty << _if item[:qty_material] _is _unset
						              _then >> "N/A"
						              _else >> write_string(item[:qty_material])
						              _endif
						_local svc_qty << _if item[:qty_service] _is _unset
						              _then >> "N/A"
						              _else >> write_string(item[:qty_service])
						              _endif

						success_msg << success_msg + write_string(
							"  Equipment Name   : ", item[:equipment_name], %newline,
							"  Material Qty     : ", mat_qty, %newline,
							"  Service Qty      : ", svc_qty, %newline,
							"  Status           : SUCCESS", %newline,
							%newline)
					_endloop
					_self.log_info(success_msg)
				_endif

				# Display detailed failed items
				_if failed_items.size > 0
				_then
					_local failed_msg << write_string(
						"FAILED ITEMS (", failed_items.size, "):", %newline,
						"-" * 80, %newline)

					_for item _over failed_items.fast_elements()
					_loop
						_local mat_qty << _if item[:qty_material] _is _unset
						              _then >> "N/A"
						              _else >> write_string(item[:qty_material])
						              _endif
						_local svc_qty << _if item[:qty_service] _is _unset
						              _then >> "N/A"
						              _else >> write_string(item[:qty_service])
						              _endif

						failed_msg << failed_msg + write_string(
							"  Equipment Name   : ", item[:equipment_name], %newline,
							"  Material Qty     : ", mat_qty, %newline,
							"  Service Qty      : ", svc_qty, %newline,
							"  Error            : ", item[:error], %newline,
							%newline)
					_endloop
					_self.log_warning(failed_msg)
				_endif

				_if api_error_count > 0
				_then
					_self.log_warning("  Some BOQ items failed to send to ASTRI API")
				_endif
			_else
				_self.log_info("API SUBMISSION: Skipped (only cluster infrastructure supported)")
			_endif
			_self.log_separator()

			_local msg << write_string(
				"BoQ generation completed successfully", %newline,
				"Design: ", scheme.name, %newline,
				"Infrastructure: ", infra_type, " - ", infra_code, %newline,
				"Total items: ", boq_result.size, %newline,
				%newline)

			# Add API send summary if cluster type
			_if infra_type = "cluster"
			_then
				msg << msg + write_string(
					"API Send Summary:", %newline,
					"  Successful: ", api_success_count, %newline,
					"  Errors: ", api_error_count, %newline,
					%newline)
			_else
				msg << msg + write_string(
					"API Send: Skipped (only cluster infrastructure supported)", %newline,
					%newline)
			_endif

			msg << msg + write_string("BoQ Report Summary:", %newline)

			# Show first 5 items as preview
			_for key _over boq_result.keys()
			_loop
				_local item << boq_result[key]
				msg << msg + write_string(
					"  - Equipment: ", item[:equipment_name].default(""), %newline,
					"    Description: ", item[:description].default(""), %newline,
					"    Quantity Material: ", item[:quantity_material].default("N/A"),
					", Quantity Service: ", item[:quantity_service].default("N/A"), %newline)
			_endloop
			msg << msg + write_string(
				"="*100)

			_self.user_info(msg)
		_else
			_self.log_separator()
			_self.log_warning("BOQ GENERATION COMPLETE - NO ITEMS FOUND")
			_self.log_separator()
			_self.log_warning("No BOQ items were generated from the design")
			_self.log_info("This may indicate:")
			_self.log_info("  - Design has no objects")
			_self.log_info("  - Objects have no STF item codes assigned")
			_self.log_separator()
			_self.user_info("BoQ generation completed but no items found")
		_endif

	_when error
		_self.log_separator()
		_self.log_error("BOQ GENERATION FAILED")
		_self.log_separator()
		_self.log_error("Error generating BoQ:")
		_self.log_error(errCond.report_contents_string)
		_self.log_separator()
		write("LOG: Error generating BoQ:", errCond.report_contents_string)
		_self.user_error(write_string("Error generating BoQ:", %newline,
			errCond.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.mark_construction()
	## Mark selected work order as under construction

	_if .selected_wo _is _unset
	_then
		_self.user_info("Please select a work order first")
		_return
	_endif

	_local wo << .selected_wo
	_local uuid << wo[:uuid]

	_if uuid _is _unset _orif uuid = ""
	_then
		_self.user_error("No UUID available for this work order")
		_return
	_endif

	write("Marking work order as construction:", uuid)

	_try
		_local success << .engine.mark_as_construction(uuid)

		_if success
		_then
			_self.user_info("Work order marked as under construction successfully")
			_self.refresh_data()
		_else
			_self.user_error("Failed to mark work order as under construction")
		_endif

	_when error
		_self.user_error(write_string("Error marking work order:", %newline,
			condition.report_contents_string))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.user_info(message)
	## Display informational message to user

	write("INFO:", message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.user_error(message)
	## Display error message to user

	write("ERROR:", message)
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.export_smallworld_kml()
	## Export Smallworld objects to KML based on selected work order
	## Exports design area with infrastructure type filtering

	_if .selected_wo _is _unset
	_then
		_self.show_alert("No Work Order Selected",
			"Please select a work order to export")
		_return
	_endif

	# Get work order details
	wo_number << .selected_wo[:wo_number]
	infra_type << .selected_wo[:infrastructure_type].default("cluster")

	write("Exporting KML for WO:", wo_number, " Infrastructure:", infra_type)
	_self.log_info(write_string("Exporting KML for WO: ", wo_number, newline_char))

	# Get project and design
	_try _with errCond
		design << .engine.get_design_for_project(wo_number)
		_if design _is _unset
		_then
			_self.show_alert("Design Not Found",
				write_string("No design found for project '", wo_number, "'"))
			_return
		_endif

		# Activate the design before export
		_self.log_info(write_string("Activating design for project: ", wo_number, newline_char))
		.engine.activate_design(wo_number)

		# Get design boundary
		design_area << .engine.get_design_boundary(design)
		_if design_area _is _unset
		_then
			_self.show_alert("Design Area Not Found",
				"Design has no boundary area defined")
			_return
		_endif

		# Show file chooser dialog
		# Sanitize WO number for filename (replace / with _)
		safe_filename << wo_number.substitute_string("/", "_") + ".kmz"
		output_file << _self.get_output_file_from_user(safe_filename)
		_if output_file _is _unset
		_then
			_return  # User cancelled
		_endif

		# Create exporter
		exporter << rwi_export_to_aerial_kmz.new()
		exporter.gc << gis_program_manager.cached_dataset(:gis).collections
		exporter.project_name << wo_number
		exporter.project_area << design_area
		exporter.infrastructure_type << infra_type.as_symbol()

		# Show progress
		_self.log_info(write_string("Starting export...", newline_char))

		# Export with dynamic network detection
		output_path << exporter.export_mixed_network(design_area, output_file)

		# Success message
		_self.show_message("Export Complete",
			write_string("Created: ", output_path))
		_self.log_info(write_string("Export completed: ", output_path, newline_char))

	_when error
		_self.show_alert("Export Failed", errCond.report_contents_string)
		_self.log_info(write_string("Export failed: ", errCond.report_contents_string, newline_char))
	_endtry
_endmethod
$

_pragma(classify_level=debug, topic={astri_integration})
_method rwwi_astri_workorder_dialog.get_output_file_from_user(default_filename)
	## Shows file chooser dialog for KMZ output

	output_dir << system.temp_directory_name

	# Simple file path construction (file chooser not available in SW)
	output_file << system.pathname_from_components(default_filename, output_dir)

	>> output_file
_endmethod
$
